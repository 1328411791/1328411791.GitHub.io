<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机网络期末复习</title>
    <link href="/2023/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="互联网组成"><a href="#互联网组成" class="headerlink" title="互联网组成"></a>互联网组成</h2><p>互联网组成：核心部分——路由器为主、边缘部分——终端为主</p><p>边缘：网络服务模式；P2P——对等网、C&#x2F;S——客户机&#x2F;服务器</p><p>核心：交换方式； 电路交换与分组交换、面向连接与面向无连接</p><p>电路交换过程：一条通路，传输效率？交换机雏形，人工交换——&gt;程控交换，计算机程控交换</p><p>分组交换过程：多路并发，数据传输效率高，但转发有时延</p><p>报文转发可理解为一个分组的转发，效率低、时延大，……</p><p>我国计算机网络应用发展：后来居上</p><h2 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h2><p><strong>LAN（PAN）、MAN、WAN地理范围</strong></p><ul><li>PAN——个人区域网，10m以内</li><li>LAN——局域网，局限在较小的范围，1km左右</li><li>Man——城域网，一个城市，5~50km</li><li>WAN——广域网，城市之间，几十到几千km</li></ul><p><strong>网络性能指标</strong><br>速率:   bit per second，    如 1Mb&#x2F;s<br>带宽：频带宽度，与速率成正比   用速率描述之。同上<br>呑吐量：单位时间内正确接收的bit数，1秒发1Mbit，正确接收6Kbit，……</p><p>时延：发送、传播、处理、排队中四类时间延迟，传播时延可忽略，发送时延取于带宽，处理时延、排队时两者延取决于主机和网络。总时延由此四部分组成，具体问题要按实际分析得出。</p><p>通信原语——请求(Request) 、指示(Indication)、响应(Response)、确认(Confirm)</p><p>通信协议：——约定、规则、规程，……，统一称之为“协议”，双方通信开始时，要进行“协商”（用什么通信规则、统一文件格式、纠错、流量控制，……）</p><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br><strong>OSI七层模型：ISO7498标准，理想模型； TCP&#x2F;IP模型，实用模型，两者特点与差异分析</strong><br>一、结构差异</p><ol><li>OSI&#x2F;RM<br>OSI&#x2F;RM是开放的标准，一个系统就可以和位于世界上任何地方的、也遵循同一标准的其他任何系统进行通信，仅考虑与互连有关的那些部分，最终形成了一个七层协议的体系结构<br>OSI划分为7层结构：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</li><li>TCP&#x2F;IP：<br>TCP&#x2F;IP划分为4层结构：应用层、传输层、互联网络层和主机-网络层。</li></ol><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>OSI七层模型：ISO7498标准，理想模型； TCP&#x2F;IP模型，实用模型，两者特点与差异分析</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>76fcdab4929b8a8591f2b614ab15d099587bbfd7</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p>通信协议分层的作用：分而治之、降低难度。</p><p>协议三要素是：语法、主义、同步</p><p>分层原则：每层功能独立、层数合适，上下层之间有接口，上层调用下层的服务，下层为上层提供服务。以快递一本书为例，用户层，快递层，物流层。对等层有协议，上下层之间有接口，最底层是真实通信，上面的对等层是虚通信。</p><p>实体：在某一对等层上收、发的规则集合，通常是一个特定的模块</p><p>协议：对等层之间通信的规则（Protocol），是通信模型中的水平关系</p><p>服务：收、发某一方上下层次之间的服务接口（SAP），是垂直关系。</p><p>网络体系结构就是：网络通信模型中的各层（层数、层名）+对等层协议、层间接口、……、相关内容的集合。</p><h2 id="重点概念"><a href="#重点概念" class="headerlink" title="重点概念"></a>重点概念</h2><p><strong>internet与Internet之区别</strong><br>“internet”是一个通用名词，指的是由多个计算机网络相互连接而成的全球性网络。它是一个广义的概念，可以用来描述任何由多个网络组成的互联网络。</p><p>“Internet”是一个特定的名词，指的是全球范围内最大的计算机网络，由许多互联的计算机网络组成。它是由大写字母”I”开头的专有名词，用来指代我们通常所说的互联网。</p><p><strong>电路交换与分组交换的特点对比</strong><br>电路交换是一种传输方式，其中在通信开始之前，建立了一个专用的物理连接，该连接在整个通信过程中保持不变。这意味着在通信期间，发送方和接收方之间的通信路径是专用的，不会被其他用户共享。这种方式类似于电话系统中的拨号连接，其中在通话期间，电话线路是专门为两个用户保留的。</p><p>分组交换是另一种传输方式，其中数据被分割成小的数据包（或称为分组），然后通过网络传输。每个数据包都包含有关发送方和接收方的地址信息，以便在网络中正确路由。这些数据包可以通过不同的路径传输，并且在接收方重新组装以恢复原始数据。这种方式类似于邮件系统，其中信件被分成小的信封，并通过邮递员逐个传递。</p><p><strong>C&#x2F;S模式与P2P模式的区别与相同点</strong><br>C&#x2F;S模式与P2P模式的区别与相同点 C&#x2F;S模式（Client&#x2F;Server模式）是一种网络服务模式，其中客户端和服务器之间存在明确的角色分工。客户端向服务器发送请求，服务器提供相应的服务和资源。P2P模式（Peer-to-Peer模式）是一种对等网络模式，其中所有参与者都可以充当客户端和服务器的角色，彼此之间共享资源和服务。</p><p><strong>LAN（PAN）、MAN、WAN之地理范围</strong></p><ul><li>PAN——个人区域网，10m以内</li><li>LAN——局域网，局限在较小的范围，1km左右</li><li>Man——城域网，一个城市，5~50km</li><li>WAN——广域网，城市之间，几十到几千km</li></ul><p><strong>带宽、时延</strong></p><p>时延：发送、传播、处理、排队中四类时间延迟，传播时延可忽略，发送时延取于带宽，处理时延、排队时两者延取决于主机和网络。总时延由此四部分组成，具体问题要按实际分析得出。</p><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p><strong>1-07 小写和大写开头的英文名字 internet 和 Internet 在意思上有何重要区别?</strong><br>以小写字母i开始的 internet（互连网）是一个通用名词，它泛指由多个计算机网络互连而成的计算机网络。在这些网络之间的通信协议可以任意选择，不一定非要使用 TCP&#x2F;IP 协议。<br>以大写字母I开始的 Internet（互联网）则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，它采用 TCP&#x2F;IP 协议族作为通信的规则，其前身是美国的 ARPANET。</p><p><strong>客户-服务器方式与P2P对等通信方式的主要区别是什么？有没有相同的地方？</strong><br>客户-服务器方式严格区分服务请求方与服务提供方<br>P2P方式是指两台主机在通信时，并不区分哪一个是服务请求方，哪一个是服务提供方。</p><p><strong>网络协议的三个要素是什么？各有什么含义？</strong><br>网络协议:为进行网络中的数据交换而建立的规则、标准或约定<br>（1）语法：即数据与控制信息的结构或格式。<br>（2）语义：即需要发出何种控制信息，完成何种动作以及做出何种响应。<br>（3）同步：即事件实现顺序的详细说明。</p><p><strong>试解释以下名词：协议栈、实体、对等层、协议数据单元、服务访问点、客户、服务器、客户-服务器方式。</strong></p><p>(1)协议栈:指计算机网络体系结构采用分层模型后,每层的主要功能由对等层协议的运行来实现,因而每层可用一些主要协议来表征,几个层次画在一起很像一个栈的结构</p><p>(2)实体:表示任何可发送或接收信息的硬件或软件进程</p><p>(3)对等层:网络体系结构中,通信双方实现同样功能的层</p><p>(4)协议数据单元:对等层实体进行信息交换的数据单位</p><p>(5)服务访问点:在同一系统中相邻两层的实体进行交互（即交换信息）的地方.服务访问点SAP是一个抽象的概念,它实体上就是一个逻辑接口</p><p>(6)客户:服务的请求方</p><p>(7)服务器:服务的提供方</p><p>(8)客户-服务器方式:描述的是进程之间服务和被服务的关系</p><p>(9)协议:控制两个对等实体进行通信的规则的集合</p><p><strong>试解释以下名词：数据，信号，模拟数据，模拟信号，基带信号，带通信号，数字数据，数字信号，码元，单工通信，半双工通信，全双工通信，串行传输，并行传输。</strong></p><p>数据：是运送信息的实体。</p><p>信号：则是数据的电气的或电磁的表现。</p><p>模拟数据：运送信息的模拟信号。</p><p>模拟信号：连续变化的信号。</p><p>基带信号：来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</p><p>带通信号：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输。</p><p>数字数据：取值为不连续数值的数据。</p><p>数字信号：取值为有限的几个离散值的信号。</p><p>码元：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。</p><p>单工通信：即只有一个方向的通信而没有反方向的交互。</p><p>半双工通信：即通信和双方都可以发送信息，但不能双方同时发送（当然也不能同时接收）。这种通信方式是一方发送另一方接收，过一段时间再反过来。</p><p>全双工通信：即通信的双方可以同时发送和接收信息。</p><p>串行传输：使用一根数据线传输数据，一次传输1个比特，多个比特需要一个接一个依次传输。</p><p>并行传输：使用多根数据线一次传输多个比特。</p><h1 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h1><h2 id="物理层功能"><a href="#物理层功能" class="headerlink" title="物理层功能"></a>物理层功能</h2><p>物理层是网络通信的最底层，是真实的通信</p><p>物理层要研究的是：屏蔽不同通信媒体之间的差异，提出其共性的技术要求，使上层感觉不到底层差异。</p><p>实际上，物理层研究的是接口特性：如通信接口的机械、电气、功能、过程四方面特性。</p><p>物理层通信都是在一根 线上“串行”传输的，收、发可一个信道，也可丰不同的信道上。</p><p>物理层协议早期称之为“规程”</p><p>物理层因具体抛入媒体及方式众多，物理层规程（协议）也很多。</p><p>接口与通信课程中，有更详细的介绍。</p><h2 id="物理层基础"><a href="#物理层基础" class="headerlink" title="物理层基础"></a>物理层基础</h2><p>通信系统模型：源、发送器，传输系统，接收器、终点</p><p>常用概念：Data、信号（模拟、数字），单工、双工、半双工通信</p><p>基带、调制、编码，调制（带通）信号</p><p>几种编码方式：归零、不归零编码，曼彻思特、差分曼彻思特编码，……</p><p>带通调制：调幅、调频、调相</p><p>信道极限容量——失真，通信频带确定，信噪比，</p><p>Nyquist定理——理想信道速率；</p><p>Shannon公式——实际信道，有噪声的最大速率。</p><h2 id="通信媒体"><a href="#通信媒体" class="headerlink" title="通信媒体"></a>通信媒体</h2><p>电磁波谱</p><p>双绞线：UTP 100Base-T（100米）的解释，10GBASE-T（35~100米），……，</p><p>同轴电缆</p><p>光纤：工作原理，单模&#x2F;多模</p><p>无线（非引导型）媒体：方便。</p><p>微波（1mm~1m）,50km-，需要中继，特点：容量大，质量高；但视距内，环境影响大，维护成本高。</p><p>卫星通信：距离远（3万km+）,三颗卫星覆盖全球，有固定时延（250~300ms）。特点：发射成本高，维护成本低；</p><p>高轨（3万+），低轨（2千-），星链系统是低轨首卫星通信系统。</p><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><p>复用：在一条线路上开辟多条信道，传送多信号；</p><p>频分FDM：分成多个子频带，每个子频带传送一路信号</p><p>时分TDM：分成11 个时间片，每个时间片传送一路信号</p><p>波分WDM：光的频分复用</p><p>码分CDMA：每个站点一个特定码片，+1发码片，0发反码片，（自学）……</p><p>工作原理，复用器、分用器，以有线电话为例：电话频带267KHz，每个话带4KHz，实用中最多分出24个子频带</p><h2 id="数字传输与带宽接入"><a href="#数字传输与带宽接入" class="headerlink" title="数字传输与带宽接入"></a>数字传输与带宽接入</h2><p>数字传输系统：承载语音、图像、视频多种数据，现在均用光纤网络媒体</p><p>高速宽带网络的关键技术：</p><p>速率统一问题：T1（北美、日本） 1.544Mbit&#x2F;s，E1（欧洲）2.048Mbit&#x2F;s；</p><p>全球同步问题：全球时钟一致问题，</p><p>同步光纤网（美国）SONET，第一级 51.840Mbit&#x2F;s，其它见教材P62 表2-2</p><p>ITU-T推出SDH（国际标准同步系列），与SONET有关联，划分等级不一样。同上查表2-2</p><p>SDH&#x2F;SONET使得北美，日本，欧洲的标准统一起来。对世界电信网络的发展意义重大</p><p>ADSL／VSDL，10M／50M，</p><p>宽带网接入：以太网互连</p><p>光纤接入　200～1000MBit&#x2F;s</p><h2 id="重点概念-1"><a href="#重点概念-1" class="headerlink" title="重点概念"></a>重点概念</h2><p><strong>通信系统模型，通信方式（单 工、双工、半双工）</strong></p><ul><li><p>单工（Simplex）：数据只能在一个方向上流动，不能双向传输。例如，广播就是单工通信，信息只能从广播站传输到接收者，接收者不能向广播站发送信息。</p></li><li><p>双工（Duplex）：数据可以同时在两个方向上流动，即设备可以同时发送和接收数据。例如，电话就是双工通信，两个人可以同时说话和听对方说话。</p></li><li><p>半双工（Half Duplex）：数据可以在两个方向上流动，但不能同时。在任何时候，数据只能在一个方向上流动。例如，对讲机就是半双工通信，一方说话时，另一方只能听，不能同时说话。</p></li></ul><p><strong>带宽调制——调幅、调频、调相及复合调制</strong></p><ul><li><p>调幅（Amplitude Modulation）：在调幅中，信号的幅度或强度会根据要发送的信息进行变化。这是最早的和最简单的无线电广播技术。</p></li><li><p>调频（Frequency Modulation）：在调频中，信号的频率会根据要发送的信息进行变化。这种技术通常用于FM广播。</p></li><li><p>调相（Phase Modulation）：在调相中，信号的相位会根据要发送的信息进行变化。这种技术常用于数字数据的传输。</p></li><li><p>复合调制（Composite Modulation）：复合调制是指同时使用两种或更多种调制技术。例如，调幅调相键控（AM-PSK）就是一种复合调制技术。</p></li></ul><p><strong>双绞线、光纤的性能特点与应用</strong></p><ul><li><p>双绞线（Twisted Pair）：双绞线是一种常见的有线传输介质，由两根互相绞合的铜线组成。双绞线的主要优点是成本低，安装简单。然而，双绞线的传输距离和速度都相对较低，而且容易受到电磁干扰。双绞线通常用于电话线和局域网（LAN）。</p></li><li><p>光纤（Optical Fiber）：光纤是一种使用光信号进行数据传输的介质。光纤的主要优点是传输距离远，速度快，不受电磁干扰。然而，光纤的成本较高，安装和维护也相对复杂。光纤通常用于广域网（WAN），如互联网的主干网络。</p></li></ul><p><strong>微波、卫星通信的特点</strong></p><ul><li><p>微波（Microwave）：微波通信是一种使用高频率的无线电波进行数据传输的方式。微波通信的主要优点是传输速度快，延迟低，而且设备成本相对较低。然而，微波通信的传输距离受到限制，通常需要直线视距（LOS）连接，而且容易受到天气和其他无线电设备的干扰。微波通信通常用于城市之间或大楼之间的数据连接。</p></li><li><p>卫星通信（Satellite Communication）：卫星通信是一种使用地球轨道上的卫星进行数据传输的方式。卫星通信的主要优点是覆盖范围广，可以覆盖地球的大部分地区。然而，卫星通信的延迟较高，而且设备和运营成本也较高。卫星通信通常用于电视广播、全球定位系统（GPS）和远程通信。</p></li></ul><p><strong>信道复用——FDM、TDM、WDM、CDMA</strong></p><ul><li><p>FDM（Frequency Division Multiplexing，频分复用）：在FDM中，整个频带被划分为多个子频带，每个子频带被分配给一个信号。这种技术常用于无线广播和电视系统。</p></li><li><p>TDM（Time Division Multiplexing，时分复用）：在TDM中，时间被划分为多个时隙，每个时隙被分配给一个信号。这种技术常用于数字电话系统。</p></li><li><p>WDM（Wavelength Division Multiplexing，波分复用）：在WDM中，光纤的不同波长被用于传输不同的信号。这种技术常用于光纤通信系统。</p></li><li><p>CDMA（Code Division Multiple Access，码分多址）：在CDMA中，每个信号都有一个唯一的代码，通过这个代码可以在同一频带上同时传输多个信号。这种技术常用于无线通信，如3G和4G手机网络。</p></li></ul><p><strong>SONET与SDH的关系及区别</strong></p><ul><li><p>SONET（Synchronous Optical Network，同步光纤网络）：SONET是一种在光纤上进行同步数字传输的标准，由美国的ANSI组织制定。SONET的主要优点是它的高速度和大容量，以及它的灵活性和可扩展性。</p></li><li><p>SDH（Synchronous Digital Hierarchy，同步数字体系）：SDH是一种与SONET兼容的国际标准，由国际电信联盟（ITU）制定。SDH在SONET的基础上增加了一些新的特性，如网络管理和保护机制。</p></li></ul><h2 id="作业-1"><a href="#作业-1" class="headerlink" title="作业"></a>作业</h2><p><strong>物理层的接口有哪几个方面的特性？各包含些什么内容？</strong><br>机械特性:指明接口所用的接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。<br>电气特性:指明在接口电缆的各条线上出现的电压的范围。<br>功能特性:指明某条线上出现的某一电平的电压表示何意。<br>规程特性:说明对于不同功能的各种可能事件的出现顺序。</p><p><strong>为什么要使用信道复用技术？常用的信道复用技术有哪些？</strong></p><p>原因:为了通过共享信道，最大限度提高信道利用率</p><p>常见的信道复用技术:</p><p>频分复用(FDM):频分复用的各路信号在同样的时间占用不同的带宽资源</p><p>时分复用(TDM):时分复用的所有用户是在不同的时间占用同样的频带宽度</p><p>波分复用(WDM):波分复用就是光的频分复用</p><p>码分复用(CDM):码分复用是另一种共享信道的方法，码分复用信道为多个不同地址的所共享</p><p><strong>试写出下列英文缩写的全文，并做简单的解释。FDM,TDM,STDM,WDM,DWDM,CDMA,SONET,SDH,STM-1 ,OC-48.</strong></p><p>FDM:Frequency Division Multiplexing，频分多路复用技术，是一种将多个信号通过分配不同的频率带宽来进行传输的技术。</p><p>TDM:Time Division Multiplexing，时分多路复用技术，是一种将多个信号通过分配不同的时间段来进行传输的技术。</p><p>STDM:Statistical Time Division Multiplexing，统计时分多路复用技术，是一种根据不同信号的需求动态分配时间片进行传输的技术。</p><p>WDM:Wavelength Division Multiplexing，波分多路复用技术，是一种将多个信号通过分配不同的波长进行传输的技术</p><p>DWDM:Dense Wavelength Division Multiplexing，密集波分多路复用技术，是一种通过更加紧密地分配波长来实现更高带宽的波分多路复用技术。</p><p>CDMA:Code Division Multiple Access，码分多址技术，是一种通过将不同的信号编码成唯一的码来实现多个信号同时传输的技术。</p><p>SONET:Synchronous Optical Network，同步光纤网络，是一种通过光纤传输数据的网络标准</p><p>SDH:Synchronous Digital Hierarchy，同步数字分层技术，是一种通过数字信号传输数据的网络标准</p><p>STM - 1:Synchronous Transport Module level-1，同步传输模块一级，是SDH网络中的传输速率标准之一，是155.52 Mbps</p><p>OC - 48: Optical Carrier level 48，光纤传输速率48，是SONET网络中的传输速率标准之一，是2.5 Gbps。</p><h1 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h1><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>数据链层的四大功能：组装成帧，差错控制，流量控制，链路管理。</p><p>物理只管传送bit流，链路层要定界、纠错，流控、管理，链路层数据包称为“帧”，是链路层的传送、处理单位。</p><p><img src="https://pic.liahnu.top/img/202312271458285.png" alt="图3-1"></p><p><img src="https://pic.liahnu.top/img/202312271459884.png" alt="图3-2"><br>真实通信与对等层虚通信的图形示例，教材P71图3-1，P72图3-2</p><p>物理链路和数据链路的区别：通+纠错+流控+……</p><p>“帧”的成型——发送方从网络层向下时，加上帧头、帧尾，接收收方网络层再去掉帧头、帧尾。 链路层虚通信——发：加上帧头、尾，收：去掉</p><p>帧的封装：帧头为 ASCII 1，SOH 0000 0001， 帧尾为 ASCII  4 ，EOT 0000 0100——用控制字符来包装。</p><p>透明传输：如果帧内bit组成SOH、EOT时，在其前面插入一个转义字符ESC（ASCII 27 0001 1011），将期中影响削除，实现所谓的“透明”</p><p>检测错误—— CRC（冗余校验）原理： k_bit 数据，n_bit冗余，共传送  （k+n）bit，n_bit 冗余码如确定？P76页例题可分析之。</p><p>接收方，收到（k+n）bit，用n位冗余码（双方相同）去校验（整除），结果为0时，说明传输无误！否则有错，要求重传（简单粗爆的纠错方法）</p><p> CRC_16&#x3D;X16+X15+X2+1    1100 0000 0000 0011</p><p>广泛使用的CRC生成多项式。选择的好的话，漏检率极低（&lt;1E-4）</p><p>检测出错的帧一定丢弃，因而不能保证可靠传输，但声无关错的帧一寂接收，数据链路——只接收正确的帧。</p><p>目前通信系统质量提高，出错率极低，这些底层检错方法逐渐少用了。</p><h2 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a>PPP</h2><p>接入互联网必须要有ISP，PPP协议就是用户向ISP进行通信时所用。</p><p>PPP协议应当：简单、封装、透明，支持多用户、多协议，</p><p>PPPoE——PPP over Ethernet；将PPP封装在以太网帧中，多用户可共享一条链路</p><p>还应当：差错检测、连接状态检测，……</p><p>PPP协议组成：封装IP数据包至串行链路PPP帧中，Link Control Protocol，Network Control Protocol，三种类型的帧，传送IP包，LCP、NCP。</p><p>PPP帧组成分析：P83图3-1，协议字段为0x0021——IP数据报，0xC021——LCP数据，0x8021——NCP数据</p><p>首、尾标志：0x7E（0111 1110），转义字符 0x7D（0111 1101）</p><p>信息部分出现0x7E时，变换成 0x7D(0111 1101)，0x5E（0101 1110）</p><p>信息部分出现0x7D时，变换成 0x7D(0111 1101)，0x5D（0101 1101）</p><p>信息部分出现ASCII&lt;32为控制字符，不可显示，转换为  0x7D，0x20+ASCII 值</p><p>在发送端如此填充，接收端逆解去掉——实现透明传输</p><p>0 bit填充法：首尾标志0x7E(0111 1110)中间为连续的6个’1’，如果数据信息bit流中有5个‘1’时就填充一个‘0’，就能保证数据部分不会出连续6个‘1’，不会与首尾标志重复，从避免影响。接收端将连续5个‘1’后的‘0’去掉即可。</p><p>PPP工作状态：</p><p>P82 图3-12解释，基本了解即可。</p><h2 id="广播链路"><a href="#广播链路" class="headerlink" title="广播链路"></a>广播链路</h2><p>PPP协议是“点对点”（1:1）协议，广播信道是“一点对多点”，一个站点发送，多个站点都可接收。</p><p>LAN之特点：地理范围小（&lt;10km）、私有、广播式通信、基带、高速率、低误码率，高可靠性，……</p><p>网络拓扑：总线形、星形、环形之特点，目前常用星形。</p><p>LAN信道，不划分信道，发送、接收信道各行其道。</p><p>多点接入（如何发数据？）</p><p>随机接入——竞争（发言权），冲突不可避免！</p><p>受控接入——轮询（流）</p><p>Ethernet发展简介： DIX V2对标IEEE 802.3，以太网统一LAN天下，只剩MAC，……</p><p>网卡：Adapter， 集成在主板上。网络适配器主要作用是“串-并”转换，少不了缓存，……，同时有CRC冗余校验芯片，出错帧挂接丢弃！在网卡上独立完成帧的处理（有自己的CPU），……</p><p>CSMA&#x2F;CD 协议：载波侦听多路访问&#x2F;冲突检测，工作原理：总线式LAN，一个信道、广播，目标站点接收；</p><p>发前先听：侦听到信道空闲时，便可发数据；忙则不可发送。</p><p>边发边听：一边发数据，一边接收，与已发数据比较，如果不同，则说明出现了冲突。</p><p>冲突退避：检测到冲突，发出报警，之后停止，再等待、竞争下一个空闲 。</p><p>冲突退避过程分析：P89图3-17，截断的二进制指数退避算法，双方收到警报时，停止发送，信道空闲，再次捕捉机会发送，……；重传时，等待优先级会降低。</p><p>争用期为2τ（往返时延），51.2μs，（对10Mb&#x2F;s以太网，此期间可发512bit数据），重传时间向后推迟 r 倍争用期，</p><p>r &#x3D;[0,1,2,……，2^k -1]，从中随机取一个值</p><p>k&#x3D;1, r&#x3D;[0，1] , 在0或个等待后再次偿试发出</p><p>k&#x3D;2, r&#x3D;[0,1,2,3]，在0，1，2，3，4中随机取一个值为等待时间，再次发送。</p><p>k&#x3D;3, r&#x3D;[0,1,2,3,4,5,6,7]，  ……</p><p>重复次数增加，等待更时间的概率也在加大。</p><p>只所以还要随机取一个等待时间，因为两个以上站点发数据，用同一等待时间后再重发，冲突的概率太大。</p><p>无效帧——争用期可发64字节（512bit ），如果 一次发送数据不足64字节（512bit），冲突信息还检测出来就结束了，不能保证无冲突发生，本次发送是否失败不得而知。故有效帧长必须大于64字节，小于64字节的是无效帧，接收方丢弃。</p><h2 id="星形拓扑、MAC"><a href="#星形拓扑、MAC" class="headerlink" title="星形拓扑、MAC"></a>星形拓扑、MAC</h2><p> 交换机（集线器）构成的星形拓扑：以中央通信设备为中心，任意两个站点通过中央节点均可通信——星形拓扑，比总线拓扑优越的多（可分析比较）。集线器中10Mb&#x2F;s带宽，共享信道，现已淘汰。交换机是100Mb&#x2F;s起，还千兆、万兆口，独立信道，不可堆叠使用，有可配置与不可配置Switch之分 ，二层、三层以太网Switch，性能优良，组网成本低。……</p><p>信道复用率：发送时延T，最后一个Bit到达，再用传输时延τ后才能空闲，取</p><p>  α&#x3D;τ&#x2F;T, 信道利用率：S&#x3D;T&#x2F;(T+τ)&#x3D;1&#x2F;(1+α)，当α-&gt;0时（τ&lt;&lt;T）时，S-&gt;1。实际信道复用率&gt;30%就很不错了。</p><p>MAC层及地址：数据链路层分为LLC逻辑链路子层与MAC媒体访问子层，由于以太网统一了LAN江湖，LLC子层没有存在的必要了，现在只剩下MAC子层了。</p><p>MAC媒体访问子层主要功能是：接入什么样媒体？如何控制其通信？完成链路层的组装成帧，差错控制与流量控制、链路管理。有一个标识（ID）编号是最基本的，网络各站点主机依靠此编号相互通信——６字节(48bit)，称为MAV地址，硬件地址，制造时写入，永不会变。</p><p>MAC地址购买——厂商从IEEEE专门委员会购买一个组号，高24bit（2^24个），可生产2^24个网络设备。（2^24&#x3D;16,777,216）</p><p>接收帧：<br>单播——一对一<br>广播——一对全体<br>组播——一对多（组）</p><p>监听——全部接收，事后分析，……</p><p>MAC帧格式：目的６＋源６＋类型２＋数据（46~1500）+FCS4</p><p>帧之间用0101bit流，一旦出现11，则说明新的一帧开始了。</p><p>IEEE8023.3帧格式与DIX Ethernet VII的差别极小，可混 为一谈。</p><pre><code class="hljs">无效帧：bit流长度不是整数字节FCS校验出错数据帧长&lt;64字节（数据部分不在46~1500之间</code></pre><p>出错帧直接丢弃，由上层纠正！</p><h1 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h1><p>以太网扩展——增加站点数，增加范围。</p><p>物理层扩展——用集线器（网桥）扩展，共享10M带宽，碰撞域增大是主要缺点</p><p> 链路层扩展——用交换机（多端口网桥），任一对通信构成独立的碰撞域，不影响其它。以太网交换机共享N对端口（一般是24个100M口，紧支持12对独立通信）。总带宽是 N*100M，可堆叠（级联）使用，成本低廉。</p><p>以太网交换机有自学习功能：交换帧表建立过程模拟。</p><p>总线网与星形网丰工作原理上是一致的。星形网可看作是多个两站点的总线网组成的，仅是任意两点组合，交换极快而已。</p><p>虚拟局域网VLAN——在链路上多4字节的标签则可。以太网中站点太多时，引起“广播风暴”的概率就大的多，这就需要人为的把网络又细分 为多个小网，每小组专员相同的组号的，还能增强安全性。</p><p>高速以太网：100M、1000M、10000M，传输媒体可以 是双绞线，也可以 光纤（多模、单模），……</p><p>以太网升级容易（结构不变，更新传输媒体、设备，帧格式不变，软件改动极少，），其它LAN都被淘汰了。</p><h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><p>物理链路与数据链路的区别？</p><p>链路层的功能有哪几个方面？</p><p>PPP帧的组成及透明传输是如何实现的？</p><p>以太网的发展简史、名称由来是什么？</p><p>CSMA&#x2F;CD协议工作分为哪三个步骤？冲突退避算法有哪些步骤？</p><p>什么是无效帧？如何处理？</p><p>估算一下，IEEE向制造商出卖MAC地址组号，每个$1000，最高价值多少？</p><p>以太网交换机与集线器的不同之处有哪些？</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><strong>数据链路(即逻辑链路)与链路(即物理链路)有何区别? “电路接通了”与”数据链路接通了”的区别何在?</strong></p><p>数据链路与链路的区别在于数据链路出链路外，还必须有一些必要的规程来控制数据的传输，因此，数据链路比链路多了实现通信规程所需要的硬件和软件。</p><p>“电路接通了”表示链路两端的结点交换机已经开机，物理连接已经能够传送比特流了，但是，数据传输并不可靠，在物理连接基础上，再建立数据链路连接，才是“数据链路接通了”，此后，由于数据链路连接具有检测、确认和重传功能，才使不太可靠的物理链路变成可靠的数据链路，进行可靠的数据传输当数据链路断开连接时，物理电路连接不一定跟着断开连接。</p><p><strong>网络适配器的作用是什么?网络适配器工作在哪一层?</strong><br> 适配器（即网卡）来实现数据链路层和物理层这两层的协议的硬件和软件。<br>网络适配器工作在TCP&#x2F;IP协议中的网络接口层（OSI中的数据链路层和物理层）**</p><p><strong>一个PPP帧的数据部分（用十六进制写出）是7D 5E FE 27 7D 5D 7D 5D 65 7D 5E。试问真正的数据是什么（用十六进制写出）？</strong><br>7E-&gt;7D,5E   7D-&gt;7D,5D    03-&gt;7D,23</p><p>(1)当信息字段中出现0x7E字节转变为2字节序列(0x7D,0x5E)</p><p>(2)当信息字段中出现一个0x7D字节转变为2字节序列(0x7D,0x5D)</p><p>那么实际的数据为7E FE 27 7D 7D 65 7E</p><p><strong>PPP协议使用同步传输技术传送比特串0110111111111100。试问经过零比特填充后变成怎样的比特串？若接收端收到的PPP帧的数据部分是0001110111110111110110，问删除发送端加入的零比特后变成怎样的比特串？</strong><br>每5个1加一个0，防止判断成F</p><p>零比特填充后:011011111011111000</p><p>删除零比特后:00011101111111111110</p><p><strong>什么叫做传统以太网？以太网有哪两个主要标准？</strong><br>DIX Ethernet V2 标准的局域网<br>DIX Ethernet V2 标准与 IEEE 的 802.3 标准</p><p><strong>试说明10BASE-T中的“10”、“BASE”和“T”所代表的意思。</strong><br>10BASE-T中的<br>“10”表示信号在电缆上的传输速率为10MB&#x2F;s<br>“BASE”表示电缆上的信号是基带信号<br>“T”代表双绞线星形网<br>但10BASE-T的通信距离稍短，每个站到集线器的距离不超过100m</p><p><strong>以太网使用的CSMA&#x2F;CD协议是以争用方式接入到共享信道。这与传统的时分复用TDM相比优缺点如何？</strong></p><p>CSMA&#x2F;CD协议:载波监听多路访问&#x2F;碰撞检测协议</p><p>传统的时分复用TDM是静态时隙分配，均匀高负荷时信道利用率高，低负荷或符合不均匀时资源浪费较大，CSMA&#x2F;CD可动态使用空闲信道资源，低负荷时信道利用率高，但控制复杂，高负荷时信道冲突大。</p><p><strong>假定在使用CSMA&#x2F;CD协议的10Mb&#x2F;s以太网中某个站在发送数据时检测到碰撞，执行退避算法时选择了随机数r&#x3D;100。试问这个站需要等待多长时间后才能再次发送数据？如果是100Mb&#x2F;s的以太网呢？</strong></p><p>对于10Mb&#x2F;s的以太网，以太网把争用期时间定为51.2微秒，要退后100个争用期，等待时间是51.2微秒×100&#x3D;5.12ms<br>对于100Mb&#x2F;s的以太网，以太网把争用期定为5.12微秒，要退后100个争用期，等待时间是5.12微秒×100&#x3D;0.512ms</p><p><strong>有10个站连接到以太网上。试计算一下三种情况下每一个站所能得到的带宽。</strong><br>（1）10个站都连接到一个10Mb&#x2F;s以太网集线器；<br>（2）10个站都连接到一个100Mb&#x2F;s以太网集线器；<br>（3）10个站都连接到一个10Mb&#x2F;s以太网交换机。</p><p>（1）10个站都连接到一个10Mb&#x2F;s以太网集线器：1mbs<br>（2）10个站都连接到一个100mb&#x2F;s以太网集线器：10mbs<br>（3）10个站都连接到一个10mb&#x2F;s以太网交换机：100mbs</p><p><strong>以太网交换机有何特点？用它怎样组成虚拟局域网？</strong></p><p>以太网交换机作为链路层设备，可实现透明交换。虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组。这些网段具有某些共同的需求。虚拟局域网协议允许在以太网的帧格式中插入一个 4 字节的标识符，称为 VLAN 标记 (tag)，用来指明发送该帧的工作站属于哪一个虚拟局域网</p><h1 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>网络层主要功能——转发IP分组</p><p>面向连接的服务——建立(虚)电路，通信、释放三步骤。</p><p>不用中间转发，适宜于长时间、大数据量的通信。是可靠的通信服务、通信质量高，亦称虚电路服务模式——电信通信采用。</p><p>不足是：建立链路要时间，不利于猝发式通信。</p><p>面向无连接的服务——不用建立连接，直接发分组到网络（想发就发，任性），由每一个路由器根据分组的目的地址（IP）决定如何转发，从一个网络到另一个网络，直至目的网络与主机。</p><p>不用频繁建立连接，多路齐头并进，快！适宜于猝发式通信。</p><p>不足是：通信质量、可靠性都不能保证，是一种尽最大努力的服务。有转发时延，有分组丢失和重复。亦称数据报模式——网络通信采用。</p><p>虚电路报务与数据报服务的特点对比见教材P117，表4-11.</p><p>每个IP分组都按路由表来转发的，现在的问题是：路由表是如何建立？如何控制的。</p><p>本路由器向所有端口转发，成功者被记录在案——洪泛法，建立路由表，这样操作是由软件控制，非常慢！（秒级时间占用）</p><p>由路由算法建立路由表，互连网多个路由协调，由网络中心枢纽分发路由表至各个路由器并定期刷新，每个路由器则挂按表转发（IP）分组，非常快（纳秒级时间占用）。</p><p>数据层面是要分组按一定算法自我寻找最优路径，到达目的网络用主机。路由控制层面则是由网络集中分发路由信息到各个路由器，各路由器按转发表转发各个分组——集中式路由，抗打击能力差。</p><h2 id="IP概念"><a href="#IP概念" class="headerlink" title="IP概念"></a>IP概念</h2><p>IP——Internet Protocol是TCP&#x2F;IP网络的灵魂（IPv4、IPv6）</p><p>网际层实际有四个协议：ARP地址解析协议，ICMP网际报文协议、IGMP网际组管理协议，再加上IP协议（主要）。逆向地址解析协议RARP已淘汰。</p><p>IP层四个协议也有更详细的层次关系，ARP是在局域网中起作用的，不依赖IP传播，故在下面。ICMP和IGMP要依赖IP分组传播，在IP之上。</p><pre><code class="hljs">网络中间设备工作层次：物理层：中继器（转发器）——扩大网络地理范围数据链路层： 网桥，交换机（多端口网桥）——构建局域网网际层：路由器——网络互连网际层之上，传输层、应用层有网络互连设备称之为“网关”，过去把路由器和网关混为一谈，现在区分开了：应用层网关——工作在应用层。</code></pre><p>虚拟互连网：不同网络互连要解决的技术问题很多：寻址方式、数据格式、差错控制、接入控制、路由转发、服务质量、……，如何解决？把整个互连网看作是由内部路由器、边缘为站点计算机的虚拟互连网，网际层每个路由器要按路由表转发IP分组，从源网络逐步转发到目的网络。</p><p><img src="https://pic.liahnu.top/img/202312271501667.png" alt="实际网络通信过程"></p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址是网络设备（路由器、交换机端口、站点计算机或终端）必须有的一个编号，网络通信寻址就是按IP地址进行的。</p><p>IPv4是32bit的IP地址，IPv6是128bit的IP地址，后面再讲。最多可有2^32&#x3D;43亿+，实际可用接近40亿。为了便于理解与记忆，32B的IP地址分为四段，每段8Bit，一般用十进制表示；如：</p><p>10.129.1.1  二进制  0000 101 0  1000 0001 0000 0001 0000 0001<br>——十进制点分法之来由<br>IP：：&#x3D;｛<NetID>，<HostID>｝，分为网络号、主机号两部分。</HostID></NetID></p><p>分类如下：</p><pre><code class="hljs">A类： 网络号8bit（‘0’打头，最高127），主机号24bit（16777216-2）B类：网络号16bit(‘10’打头，16384)，主机号16bit(65536-2)C类：24bit(‘110’打头2097152),  主机8bit (256-2)D类——多播、E类——保留，用于测试，这两类IP地址没有商用。</code></pre><p>几个特殊IP地址：</p><pre><code class="hljs">网络号全‘0’，表示本网络；主机号全‘0’代表本主机，主机号全‘1’表示本网内广播；127.0.0.1——本机网络迴转地址，ping 127.0.0.1，用于测试本机网络软件系统是否正常。</code></pre><p>几组保留IP地址：</p><pre><code class="hljs">A类   10.0.*    ——   10.16.*B类     128.0.*  ——C类     192.168.* ——</code></pre><p>非正式IP地址，为LAN保留。目前已修改为可用的正式IP地址。</p><p>A、B、C类网络分法形式简单，管理方便，但网络规格相差很大，造成IP地址在使用上浪费极大，为了提高资源复用率，减少浪费，又提出了子网设计法，在主机号中取出几bit作为子网号，将大网络划分成多个子（小）网络，目前这种方法已淘汰。</p><p>无分类编地址：不用ABC等分类网络编址方法，直接用网络前缀（32位以内任意bit）和主机号，</p><p>IP::&#x3D;{&lt;网络前缀&gt;，&lt;主机号&gt;｝，网络前缀用   “IP地址&#x2F;前缀”形式表示，如：128.14.35.7&#x2F;20，这说明前20bit是网络号。</p><p>*&#x2F;20, 表示网络（号）前缀20bit，主机号为12bit，产生的地址块为</p><p>0000 0000  0000 ——1111 1111 1111，大小2^12-2&#x3D;4094</p><p>前缀从13——23能产生的地址块大小如教材P27图4-3所示。</p><p>CIDR地址块必须指明前缀值，即网络位多少。</p><p>网络号&#x3D;IP地址 ”按位与“ 前缀值个 ”1“，如教材P27图4-12</p><p>前缀&#x3D;32，没有主机号，主机路由</p><pre><code class="hljs">前缀=32，主机号为0，1两个，是点对点链路前缀=0同时IP地址也是全0时，默认路由。</code></pre><p>CIDR之优点：</p><pre><code class="hljs">CIDR分配IP地址几乎没有浪费；易于实现网络地址聚合。网络前缀就是网络号，路由寻址时就要向目的网络转发即可，到达目的网络后再向目的主机发送，……</code></pre><p><img src="https://pic.liahnu.top/img/202312271504206.png" alt="图4-14"><br>网络前缀相同的多个主机处在同一个网络中，当然，下面还可划分子网。</p><h2 id="IP地址和MAC地址的区别"><a href="#IP地址和MAC地址的区别" class="headerlink" title="IP地址和MAC地址的区别"></a>IP地址和MAC地址的区别</h2><p>MAC地址是固化在网卡上的，硬件（物理）地址，不可改变！</p><p>IP地址是写在IP分组中，是软件地址，可人工改变的！</p><p>上级（传输层）数据加上IP首部（共其中有IP地址），构成IP分组，路由器按目的IP地址转发IP分组。</p><p>实际数据通信过程可抽象为IP层上，IP分组的转发。教材P131表4-4、P132图4-16(a),(b)解释，网际层上虚通信，传送IP分组。</p><p>问题：如何知道MAC地址？IP~MAC映射表是如何生成的?</p><p>ARP——地址解析协议，已知IP地址，如何获得MAC地址？（RARP已淘汰）。IP分组做为链路层的负载（上层数据），到达链路层时、如何获得目的MAC地址？ARP cache的内容——IP~~MAC映像表，ARP~IP缓冲区内容逐步积累（先查表，从IP找MAC，找不到时再广播IP，接收应答）</p><p><img src="https://pic.liahnu.top/img/202312271556564.png" alt="图4-18"><br>IP~MAC缓存有表生存时间，定期刷新以适应网络拓扑结构的变化。</p><p><img src="https://pic.liahnu.top/img/202312271556421.png" alt="图4-19"><br>ARP只在LAN内起作用，实际中有四种场景： 图4-19</p><p>（1） 在LAN内，在N1网内广播ARP请求即可，可获得H2的MAC。</p><p>（2）N1网内找不到H3，发给R１（目的IP不变，R1的MAC在H１缓存中，没有则广播），</p><p>（３）再由R1在N2中发ARP请求，找H3的MAC，发给H3。</p><p>（４)H1–&gt;H4时，R1没找到H4时，再发给R2，由R2找H4，同前过程。</p><p>教材P135图4-19解释。</p><h2 id="IPV4的首部"><a href="#IPV4的首部" class="headerlink" title="IPV4的首部"></a>IPV4的首部</h2><p><img src="https://pic.liahnu.top/img/202312271557063.png" alt="IPv4分组首部构成"><br>(1) 版本4bit , IPv4：0100 ，IPv6： 0110；</p><p>(2)首部长度4bit，最为1111&#x3D;15段（每段4字节），最大60字节 ，其中：固定部分5段（20）字节，可变部分最长10段（40字节），使用不足一段时，要填充成整数段。常用20字节首部，没有可变部分。</p><p>(3)区分服务8bit，区别不同的服务及质量标准，目前没有使用。</p><p>(4)总长度16bit ，IP分组最长2^16-1 &#x3D;64k字节，实际以太网最大长度为1500字节，故IP分组最大长度不可能超过1500字节。</p><p>(5)标识16bit，数据报计数器，同一个包分出的片有相同的标识，便于组装。</p><p>(6)标志3bit，表示后面有、无分片，0表示是最后一个分片。</p><p>(7)片偏移——举例：数据包3800字节，分为1400，1400，1000三个分片</p><p>   第1片， 0字节处开始，片偏移 0&#x2F;8&#x3D;0;<br>   第2片，1400字节处开始，片偏移 1400&#x2F;8&#x3D;175;<br>   第3片，2800字节处开始 片偏移2800&#x2F;8&#x3D;350；</p><p>注：片偏移以8字节为一个单位。以太网最大长度1500字节，IP分组必须小于1500字节。</p><p>（8）生存时间TTL，占8bit(初值 0000 1111)，路由“跳数”限制，经过15个路由器还没到达终点则丢弃。每绳索一个路由器，称之为一个跳数，TTL–，当TTL&#x3D;&#x3D;0时，放弃转发。</p><p>（9）协议：8bit，指出本数据包使用何种协议；</p><p>(10) 首部校验和——16bit, 只检验首部，为的是节约（包装无损即可），方法：</p><p>发方：先将本段置”0“，对首部（固定20字节），两字节（16bit）为一段，反码求和（0+0&#x3D;0,1+0&#x3D;1,0+1&#x3D;1,1+1&#x3D;10有进位，最高位有进位时，末位+1），将其结果求反，置于本段中。</p><p>收方：同样进行反码求和，结果为 0 时，说明首部无差错。</p><h2 id="IP分组转发过程"><a href="#IP分组转发过程" class="headerlink" title="IP分组转发过程"></a>IP分组转发过程</h2><p><img src="https://pic.liahnu.top/img/202312271558219.png"><br>基于终点的转发：由目的IP地址确定向哪个端口转发；路由表中每一行是目的NetID与Port对应，从目的IP中找出目的Net后转发即可。见教材P141例4-2</p><p>源IP：       128.1.2.194（1100 0100），</p><p>源网络：   128.1.2(0000 0010).192(1100 0000)&#x2F;26 ，</p><p>目的IP:       128.1.2.132（1000 0100），</p><p>目的网络：128.1.2(0000 0010).128(1000 0000)&#x2F;26</p><p>N3：         128.1.3(0000 0011).64(0100 0000)&#x2F;26</p><p>  R1路由表：</p><table><thead><tr><th>前缀匹配</th><th>下一跳</th></tr></thead><tbody><tr><td>128.1.2.192&#x2F;26</td><td>端口0（直连）</td></tr><tr><td>128.1.2.128&#x2F;26</td><td>端口1（直连）</td></tr><tr><td>128.1.3.64&#x2F;26</td><td>R2</td></tr></tbody></table><p> R2路由表：</p><table><thead><tr><th>前缀匹配</th><th>下一跳</th></tr></thead><tbody><tr><td>128.1.2.128&#x2F;26</td><td>端口0（直连）</td></tr><tr><td>128.1.3.64&#x2F;26</td><td>端口1（直连）</td></tr><tr><td>128.1.2.192&#x2F;26</td><td>R1</td></tr></tbody></table><p>最长前缀匹配：前缀越长，网络块越小，匹配愈具体；故：最长前缀匹配！</p><p>主机路由——特定路由，专门指定的，处于路由表顶部 *&#x2F;32，一般用于测试</p><p>默认路由——从上到下匹配不上时，交由默认路由处理。在底部，0.0.0.0&#x2F;0</p><p>分组转发算法：（转发表按前缀有序，长者在前）</p><pre><code class="hljs">a. 从IP分组中提取目标IP；b. 符合特定路由后按其“下一跳”转发；c. 从上到下，按前缀匹配，成功则取其“下一跳”转发，否则向下一行进行。d. 到最底行，按默认路由转发。</code></pre><p>没有默认路由，全不匹配时，报告转发失败。</p><h2 id="ICMP简介"><a href="#ICMP简介" class="headerlink" title="ICMP简介"></a>ICMP简介</h2><p>Internet控制报文协议： IP分组转发时，只管转发，不管有无差错或异常。这些处理差错或异常的事务由ICMP来完成。控制报文——由路由器产生，表明本路由器转发某分组时发生了什么，向源主机汇报的报告，再用IP包装，沿某分组的来路回到源主机。（内容、包装、方向、路径，高层不可见）</p><p><img src="https://pic.liahnu.top/img/202312271559461.png" alt="图4-28"><br>ICMP报文格式：图4-28</p><p>ICMP报文分为差错报告和询问两大类，差错报告如：终点不可到达，超时，解释之。询问如：回送请求、回送回答。</p><p>ICMP典型举例：Ping命令</p><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>IPv6：地址空间更大，更简单，更安全，自动配置</p><p><img src="https://pic.liahnu.top/img/202312271559582.png" alt="图4-33"><br>IPv6首部：见图4-33，固定首部长度_40字节，简化了许多。</p><p>IPv6地址：十六进制冒号分法，八段、每段两字节，冒号分隔；</p><p>IPv6地址举例，“0”压缩法使用。特殊地址简介</p><p>从IPv4向IPv6过渡：</p><p>A、双协议栈法（v4、v6均有），通信时，对方是IPv6主机就用IPv6协议通信，……；</p><p>B、 隧道技术：将IPv6数据报在IPv4隧道中传递即可。</p><h2 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a>路由选择</h2><p>算法要求：正确、完整、简单、自适应、稳定、公平、最佳</p><p> 自治系统AS——可自主抉择、管理的内部网络，其带宽、路由选择策略等都由内部决定。</p><p>静态路由——路由表（转发表）内容不变，动态路由——路由表内容随网络的变化而变化、适应。</p><p>内部网关协议IGP——在AS内部使用的路由选择协议（要最佳），EGP——外部网关协议——AS之间的选择协议（通则可）。自治系统可大可小，按需要划分。</p><p>RIP——路由信息协议，属内部路由协议，适用于小型互连网。核心内容：每过一个路由器，跳数+1；最多15个路数。与相邻路由器交换信息生成路由表举例。距离向量算法，3个路由器，4个网络，……，路由信息是与相邻路由器交换而来，特点：好消息传的快，坏消息传的慢——见下图。</p><pre><code class="hljs">R1路由表                    R2路由表                   R3路由表N1，0，1                    N2，0，1                   N3，0，1N2， 1， 1                  N3，1，1                   N4，1，1+++++++++++++++第一轮交换++++++++++++++++++N3，R2, 2                   N1，R1，2                  N2，R2，2                            N4，R3，2++++++++++++++++第二轮交换+++++++++++++++++N4，R2，3                                              N1，R2，3</code></pre><p>OSPF——最短路径优先：RIP只与相邻路由器交换路由信息，OSPF与全网路由器交换路由信息——链路状态协议，算法复杂，适应性强。</p><p>OSPF将网络分为主干AS区和其它AS，所有其它AS都与主干区AS联系，每一个AS区内部的路由信息交流，……</p><p>BGP-4外部网关协议，RIP、OSPF是AS内部适用，以最佳路径，代价最低为目标建立路由表，BGP-4只选择”可通信“即可，AS之间还政治、安全经济多方考虑，选择最优不现实，较优就行了！</p><p>路由器硬件构成：多I&#x2F;O端口的专用计算机。路由选择处理机、输入&#x2F;输出端口及对应缓冲区、交换结构。</p><h2 id="多播、VPN、NAT、MPLS、SDN-介绍"><a href="#多播、VPN、NAT、MPLS、SDN-介绍" class="headerlink" title="多播、VPN、NAT、MPLS、SDN 介绍"></a>多播、VPN、NAT、MPLS、SDN 介绍</h2><p><strong>多播</strong><br>视频播放时，服务器只播放一次，由多播路由器复制多份，向网络中群发。运行多播协议——多播路由器。多播IP地址——D类 “1110”打头。在局域网上多播，MAC地址上第一字节最低位为”1“，……，在互连网上多播，要用到IGMP，……</p><p><strong>VPN</strong><br>解决IP地址资源紧张、保障内网安全。利用IP隧道、或建立虚拟局域网，连接两个相距很远的专用网络进行通信。</p><p><strong>非正式IP</strong><br>10&#x2F;8,  172.16&#x2F;12，192.168&#x2F;24，做为LAN站点的IP地址，不用付费。</p><p><strong>NAT</strong><br>网内主机只有非正式IP地址，又要与外网通信，如何做？再申请一个正式IP，没必要！安装NAT软件的路由器称之为NAT路由器，外网客户要访问网内某参主机，由NAT路由器代转访问请求。即，外部客户是在与NAT代理服务直接打交道。</p><p><strong>MPLS——多协议标签交换</strong><br>上层可以有多种协议，每种协议有不同的标记（签），便于路由器快速转发。进入MPLS域时加上标签，在域内用硬件快速转发——标签路由器按相应标签转发，出此MPLS域时解除标签，……。</p><p><strong>SDN——设计、构建和管理网络的新方法或新概念</strong><br>OpenFlow是控制层面和数据层面的接口。数据层面：匹配+动作，SDN呈，有广义的”匹配+动作”，其匹配内容更多（链路层、网络层，运输层）动作不光是转发，还可重写IP首部，阻挡或丢弃一些分组，……。是一种OpenFlow分组交换机。</p><h2 id="本章重点"><a href="#本章重点" class="headerlink" title="本章重点"></a>本章重点</h2><p>网络层传送IP分组。提供的无连接的、尽最大努力的服务。</p><p>IP网络是由器相互连接起来、转发IP分组的虚拟互连网。</p><p>A、B、C类网络就是前缀分别为8，16，24的无分类网络，每类地址块是？</p><p>一个路由器互少有两个端口、每个端口一个IP地址。</p><p>互连网中按IP地址转发，将分组从源网络转发互目的网络；局域网中按MAC地址传送数据帧。IP是软地址，在互连网中起作用，MAC是硬地址，在LAN中起作用。如何根据IP地址在目的网络中找到目的MAC地址，用什么协议？</p><p>IPv6首部与IPv4首部相比，IPv6首部地址空间扩大，精练简化，取消选项字段更安全。</p><p>IPv4表示：十进制点分法，IPv6：十六进制冒号分法。IPv6地址可使用“0”压缩写法以简化表示。</p><p>RIP路由选择协议适用于小型网络，路由表生成练习。OSPF适用于大型网络。</p><p>ICMP协议的作用和传输目的地、方向。Ping命令的使用。</p><p>AS自治系统是独立路由的网络，AS内部使用RIP或OSPF协议，AS之间的外部路由是BGP-4。</p><h2 id="课本例题"><a href="#课本例题" class="headerlink" title="课本例题"></a>课本例题</h2><p><strong>试说明IP地址和MAC地址的区别。为什么要使用这两种不同的地址？</strong></p><p>IP地址：被称为虚拟地址、软件地址或逻辑地址，IP地址是网络层和以上各层使用的地址，是一种逻辑地址（称IP地址为逻辑地址是因为IP地址是用软件实现的）。</p><p>MAC地址：由于MAC地址已固化在网卡的ROM中，因此常将MAC地址称为硬件地址或物理地址。MAC地址是数据链路层使用的地址。</p><p>IP地址放在IP数据报的首部，而MAC地址则放在MAC帧的.首部。</p><p>为什么要使用这两种不同的地址？</p><p>   由于全世界存在着各式各样的网络，它们使用不同的MAC地址。要使这些异构网络能够互相通信就必须进行非常复杂的MAC地址转换工作，因此由用户或用户主机来完成这项工作几乎是不可能的事。</p><p>  即使是对分布在全世界的以太网MAC地址进行寻址，也是极其困难的。</p><p>  然而IP编址解决了这个问题，连接到互联网的主机只需各自拥有一个IP地址，它们之间的通信就可以像连接在同一个网络上那样简单方便，即便必须多次调用ARP来找到MAC地址，但这个过程都是由计算机软件自动进行的，用户看不见。</p><p><strong>有如下的4个&#x2F;24地址块，试进行最大可能的聚合。</strong><br>212.56.132.0&#x2F;24<br>212.56.133.0&#x2F;24<br>212.56.134.0&#x2F;24<br>212.56.135.0&#x2F;24<br>由于四个地址块前两个字节都相同，只需将每个地址块的第三个字节转换为二进制：<br>到第22位之后开始变<br>     212.56.1000 0100.0<br>     212.56.1000 0101.0<br>     212.56.1000 0110.0<br>     212.56.1000 0111.0</p><p>可以发现，212.56.1000 01这一部分是相同的，因此可以聚合成212.56.132.0&#x2F;22</p><p><strong>某单位分配到一个地址块136.23.12.64&#x2F;26.现在需要进一步划分为4个一样大的子网。试问：</strong></p><p>（1）每一个子网的网络前缀有多长？</p><p>（2）每一个子网中有多少个地址？</p><p>（3）每一个子网的地址块是什么？</p><p>（4）每一个子网可分配给主机使用的最小地址和最大地址是什么？</p><p>1）划分为4个子网需要两位子网号，因此每一个子网的网络前缀为26+2&#x3D;28位</p><p>2）每一个子网中有32-28 &#x3D; 4位主机号，因此一共有2^4个地址</p><p>3）每一个子网的地址块为：</p><p>4136.23.12.64&#x2F;28；②136.23.12.80&#x2F;28；③136.23.12.96&#x2F;28；④136.23.12.112&#x2F;28；</p><p>4）<br>64是1000000，加一；79是1011111，减一（32减28等于4，所以后四位不能全0或1）</p><pre><code class="hljs">      可分配的最小地址          可分配的最大地址</code></pre><p>①      136.23.12.65&#x2F;28                136.23.12.78&#x2F;28</p><p>②      136.23.12.81&#x2F;28                136.23.12.94&#x2F;28</p><p>③      136.23.12.97&#x2F;28                136.23.12.110&#x2F;28</p><p>④      136.23.12.113&#x2F;28               136.23.12.126&#x2F;28</p><p><strong>假设一段地址的首地址为146.102.29.0，末地址为146.102.32.255，求这个地址段的地址数。 相减加一然后乘起来</strong><br>（32-29+1）x（255-0+1） &#x3D; 1024（个）</p><p><strong>收到一个分组，其目的地址D &#x3D; 11.1.2.5。要查找的转发表有这样的三项：</strong><br>  路由一    到达网络 11.0.0.0&#x2F;8<br>  路由二    到达网络 11.1.0.0&#x2F;16<br>  路由三    到达网络 11.1.2.0&#x2F;24<br>试问在转发这个分组时应当选择哪一个路由？<br>根据最长前缀匹配原则，虽然三个路由都能匹配上，但是路由3是最长的，因此应该选择路由3.</p><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="TCP和UDP协议"><a href="#TCP和UDP协议" class="headerlink" title="TCP和UDP协议"></a>TCP和UDP协议</h2><p>运输层的功能：实现两端主机之间的通信——UDP不用建立连接而TCP要建立。端口、套接字应用，可靠通信——ARQ（自动请求重发），流量控制。</p><p>主机进程、套接字等事务：主机同时(本质上是分时操作)可进行多种计算，建立多个进程，用代号区别——进程号。通信双方主机的同一个通信，双方主机的进程号并不一定相同，如何连接起来，就需要套接（字）。流量控制、拥塞控制、连接管理，这些事务正是主机层次要完成的工作。</p><p>运输层协议是为应用层服务的，是面向两端主机的，可理解为双方主机借助于通信网络实现运输层服务。</p><p>用户数据报：UDP协议是面向无连接的协议，传送UDP数据报，简单有效，不提供可靠交付。传输控制协议：TCP是面向连接的协议，可靠交付、有质量保证；比较复杂，处理费时。应用层上协议不同，在运输层上要使用不同的协议——UDP或TCP（高质量要求）。见教材P213表5-1.</p><p>主机在OS支持下，可同时执行多道任务，每道一个编号。可将任务分成多个子任务，分通道进行——分用；亦可反之，将多个任务汇集在一个任务中进行——复合。而服务器上一些专门的应用处理用指定进程号来处理，可简化处理负担。应用层某种应用要求指定进程来处理——协议进程号，亦称协议端口，简称端口，如HTTP用80端口，……；端口是软件定义的。</p><p>端口呈占16Bit，前1024是熟知端口，1024<del>49151是登记端口，49152</del>65535是用户端口是客户端口。例：本机访问某台服务器上的主页，本机任意指定50000号端口，去访问服务器上80端口；……</p><p>UDP协议：无连接，尽最大努力交付，面向报文——对报文大小不限，照样发送，应用层要考虑报文大小问题。无拥塞控制，支持一对一，一对多，多对一的交互式通信；首部开锁小。</p><p>UDP首部格式：见教材P127图5-5；分析UDP首部组成，校验和需要伪首部，校验和计算方法：顺序两字节一段，二进制反码求和——可进位、最高位进位补到末尾（非偶数字节补一字节0），最终结果再取反，为发方校验和，收方同样反码求和，全0则说明无误。IP地址暗含其中。</p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>面向连接的协议，一对一，提供可靠交付——高质量全双工通信，传送字节流（以字节为单位）。</p><p>TCP连接之涵义：发、收双方主机之间建立TCP连接，其连接终点是套接字：</p><p><code>socket 套接字=（IP地址：端口号）</code></p><p><code>TCP连接=｛socket1,socket2｝=&#123;(IP1, port1), (IP2, port2)｝</code></p><p>socket还有更多有涵义，在以后的应用中再逐步使用之。</p><p>可靠传输原理——利用纠正错误的机制来保证传输不出差错！</p><p><strong>stop-waite协议</strong><br>发送一次，停下来等待收方回答，确认ACK后再发下一次，否认NAK则重发一次，超时亦重发！</p><p>在不可靠的信道上实现可靠传输——自动传输请求ARQ。</p><p>信道效率：  <code>U=Td/(Td+RTT+Ta)</code>；RTT较大时，信道利用率很低。</p><p>连续ARQ协议：连续发分组，收文回答一个组号，说明此组号之间的分组都已确认，发方退到此组号处，再重新发送，犹如发送窗口在滑动一样。</p><p><img src="https://pic.liahnu.top/img/202312271622767.png" alt="图5-13"><br>TCP报文首部，同IPv4首部类似，见图5-13。</p><pre><code class="hljs">4字节为一段，固定首部4段（20Bit），还有可选道部最多10段；目的、源端口各占16Bit；序号和确认号各占一段（32bit）,每字节一个编号，且不会重复。确认号是指此号之前字节都已正确接收，下次从此确认号开始发送。ACK=1有效，ACK=0无效。</code></pre><p>窗口是指自身接收窗口数——字节（最大64K字节），向对方表明自身最多接收多少字节。</p><p>其它如校验和、紧急指针、选项等不再详述。</p><p>TCP可靠传输实现——纠正错误、控制流量。滑动窗口协议：设一次最大允许发送10字节，开始可发1~10字节，但发到第7字节时，收一个4，表明第4 个字节之前的确认，现在可发从4，5，6,……，13字节；假若又收到10，退回从11，12，……，10发送；</p><pre><code class="hljs"> 发送窗口【1，10】，【4，13】，【11，20】，……</code></pre><p>超时重传——超过规定时间没收到确认，认为传送失败，再重传一次即可。问题是：超时时间定为多少合理？下面网络情况复杂，用下面式了确定：</p><p><code> 新RTTs=（1-a ）*旧RTTs+a*（新RTT）</code>  简单解释之，不宜深究。</p><p>TCP流量控制——发送方发送速率与接收方的接收速率相匹配。</p><p>由接收方告诉发方，还有多少窗口。这样，发方根据收方窗口数 发送数据，从而保证收方能正确接收。</p><pre><code class="hljs">Wf——发方窗口数，Ws——收方窗口，实发窗口&lt;=Ws，收方窗口数是动态变化的，要随时报告给发方。每个连接有一计数器，首先发0字节进行探测，打开此计数器 ，可防止收文窗口数丢失造成的死锁。</code></pre><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>网络拥塞——资源不足造成！带宽不大、缓冲大小、处理太慢、排队过长，……，造成：需求&lt;资源，网络性能恶化，网编从变慢，再到瘫痪，直至卡死。</p><p>增加资源（增大带宽、提高处理速率、……）并不能从根本上解决问题，瓶颈会转移到其它地方。全网改善也是非常难的一件事。</p><p>拥塞控制与流量控制的不同：流量控制关心“点——点”的发、收匹配，是局部解决问题，拥塞控制关心的是全网是还通畅，哪里有网络变慢问题，都要设法改善。两者有联系，但本质有区别。</p><p>实施拥塞控制要付出的代价：占用一些资源，所起作用见教材P240图5-23。</p><p>实际中要闭环控制思维，才能获得较好效果——利用监测系统找出拥塞发生的地点、时间，可解决问题的方法和地方等。</p><p>网络拥塞指标可以 有：分组丢弃百分数，平均队列长度，平均分组时延，……</p><p>TCP拥塞控制方法1：慢开始与拥塞避免，拥塞窗口 Wc，一开始为1，Wc&#x3D;Wf，拥塞现象没出现时，Wc可增加，有超时现象时，Wc就缓慢增加或不增加。见教材P242图5-24， P243图 5-25，详细解释拥塞控制曲线之涵义。</p><p>Wf&#x3D;min(Wc,Ws);         实际发送窗口取拥塞窗口和接收窗口中最小者。</p><p>取初值Wc&#x3D;1，没拥塞时，Wc翻番增加，检测到轻度拥塞时，Wc线性（加法 、++）增加；有超时出现，拥塞发生，又开始慢开始算法，……。</p><p>快重传与快恢复：有丢失时，立即确认！当发送方发出：M1，M2，M3，M4，M5，M6时，M3丢失，则确认M1，M2，M2，M2，M2，后确认三个M2，表明M3丢失，应当立即重发M3！……P243图 5-25的第二部分解释之，后面按线性增加拥塞窗口数。</p><p>小结：当拥塞窗口Wc&#x3D;1时，无拥塞时，慢开始算法，Wc翻番；当轻度拥塞时，拥塞避免算法，Wc++；在拥塞出现（超）时，第1 次调整，Wc&#x3D;1，又慢开始，在前次超时的一半时，执行Wc++，在要求重传时，下降到最点的一半（乘法减小），再Wc++；</p><p>实际发送窗口是： Wf上限&#x3D;min(Ws,Wc)</p><p>主动队列管理：在接收等待队列没达最长长度聘用制时，有意识的丢掉一些分组，……</p><h2 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h2><p>TCP连接建立：三次握手连接过程分析，客户端打开连接</p><p><img src="https://pic.liahnu.top/img/202312271652057.png"><br>1）C——&gt;S:        SYN&#x3D;1， seq&#x3D;x</p><pre><code class="hljs">客户端要求建立同步连接及序号是x;</code></pre><p>2）S——&gt;C：      ACK&#x3D;1，ack&#x3D;x+1;    SYN1&#x3D;1, seq&#x3D;y</p><pre><code class="hljs">服务器端确认（客户申请的）及序号为x+1，正向连接建立；同时，服务器申请建立反向连接及序号为y;</code></pre><p> 3） C——&gt;S:    ACK&#x3D;1, ack&#x3D;y+1,  seq&#x3D;x+1</p><pre><code class="hljs">客户端接受服务器端的连接请求，建立反向连接。</code></pre><p>三次握手（通信开始的协商称之为握手）实际是四次，中间确认正向、申请反向并为一起了。</p><p>正向、反向分别建立连接，可防止无意义的等待。第一个连接滞留网络，超时重发第二闪连接 ，B方收到第二个后建立了连接，失效报文迟到后，又重复建立连接。</p><p><img src="https://pic.liahnu.top/img/202312271653439.png"><br>四次终止：A方请求终止，Fin&#x3D;1，seq&#x3D;m;    我方数据传输完毕，请求终止</p><pre><code class="hljs">B方同意，    ACK=1,ack=m+1;  seq=n;    同意终止；    ……（反向数据传输仍在继续）    B方请求终止，Fin=1,seq=n;     ACK=1,ack=m+1(ACK=1,ack=m+1 表示反向终止请求同最后传的数据分组一同到达)    A方同意，  ACK=1,   ack=n+1, seq=m+1</code></pre><p><img src="https://pic.liahnu.top/img/202312271653954.png" alt="图5-30"><br>TCP有限状态机：图5-30</p><h2 id="本章重点-1"><a href="#本章重点-1" class="headerlink" title="本章重点"></a>本章重点</h2><p>运输建立的是两个主机之间的连接，“端——端”，是双方主机各自的某个进程之间的通信，这个进程号称之为“端口”；端口号16bit，前1024是熟知端口，网络常用服务在服务器一方的端口是固定的，客户端的端口号是随机的。套接字是 socket&#x3D;(IP:Port)</p><p>UDP协议是无连接协议，不用连接直接发送即可。TCP是面向连接的协议，要先建立连接成功后才能发送数据，发送结束后拆除连接。</p><p>Stop-Waite协议——在不可靠的通信链路实现可靠传输。每发一个数据，等待确认后再发下一个；如果否认，重发该数据；这样保障正确接收。</p><p>ARQ——自动请求重发，连续ARQ协议可大提高信道效率。</p><p>TCP首部组成</p><p>TCP使用滑动窗口机制进行收、发双方的能力匹配。流量控制就是发方发送速率要匹配收方的处理速率，……</p><p>拥塞就是网络资源不足时，变慢、卡顿、分组丢失等现象出现——性能变坏</p><p>流量控制是“端——端”一对通信的局部问题，拥塞控制是改善整个网络的性能 的全局性问题。</p><p>Wf&#x3D; min(Ws,Wc);    发送窗口最大数取接收窗口与拥塞窗口之间的较小的。</p><p>拥塞窗口算法四种——慢开始、拥塞避免、快重传、快恢复。</p><p>TCP三次连接过程剖析</p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><strong>端口的作用是什么？为什么端口号要划分为三种？</strong></p><p>我们知道，通信的实体是主机之间的进程。在单个计算机中的进程是用进程标识符来标志的，但是在互联网中，计算机的操作系统种类很多，不同的操作系统又使用不同格式的进程标识符。为了使运行在不同操作系统上的计算机中的进程能够相互通信，就必须用统一的方法对应用进程进行标志。</p><p>但是，将一个特点机器上运行的特定进程，指明为互联网上通信的最后终点时不可行的。这是因为进程是动态的程序，进程的创建和撤消都是动态的，通信的一方几乎无法知道和识别对方机器上的进程。另外，我们往往需要利用目的主机提供的功能来识别终点，但是不一定要知道这个服务器的功能是由目的主机的哪一个进程实现的。</p><p>因此，端口就应运而生了。在应用层和运输层之间的界面上，设置一个特殊抽象的“门”，应用层中的应用要通过运输层发送到互联网，就必须通过这个“门”，这个“门”就是端口。</p><p>简而言之，端口的作用就是对TCP&#x2F;IP体系的应用进程进行统一的标志，使运行在不同操作系统的计算机的应用进程能够互相通信。</p><p>将端口号分为3类是因为：避免端口号重复，无法区分应用进程。二是因特网上的计算机通信都是采用C&#x2F;S方式，在客户发起通信请求时，必须知道服务器的端口，对于一些主要<br> 的应用程序，必须让所有用户知道。</p><p><strong>一个UDP用户数据报的首部的十六进制表示是：06 32 00 45 00 1C E2 17.试求源端口、目的端口、用户数据报的总长度、数据部分长度。这个用户数据报是从客户发给服务器还是从服务器发送给客户？使用UDP这个服务器程序是什么？</strong></p><p>根据UDP的首部组成,可知，</p><p>源端口: 0<em>16^3+6</em>16^2+3<em>16+2</em>16^0 &#x3D; 1586（十进制）0632</p><p>目的端口: 0<em>16^3+0</em>16^2+4<em>16+5</em>16^0 &#x3D; 69（十进制）0045</p><p>用户数据报总长度：0<em>16^3+0</em>16^2+1<em>16+12</em>16^0 &#x3D; 28(十进制）001C</p><p>数据部分长度 &#x3D; 总长度 - 首部长度 &#x3D; 20（字节）28减8</p><p>目的端口为69&lt;1023(0~1023为熟知端口），所以数据报是从客户端发送给服务器的，经查询，这个服务器程序是TFTP。</p><p><strong>在停止等待协议中如果不使用编号是否可行？为什么？</strong></p><p>不可以。</p><p>“停止等待”就是每发送完一个分组就停止发送，等待对方确认。在收到确认后再发送下一个分组。</p><p>分组和确认分组都必须进行编号，这样才能明确是哪一个发送出去的分组收到了确认，而哪一个分组还没有收到确认。</p><p><strong>为什么在TCP首部中要把TCP的端口号放入最开始的4个字节？</strong></p><p>在ICMP的差错报文中要包含紧随IP头部后面的8个字节的内容，让在TCP头部最开始的4个字节是TCP的端口号，就可以在ICMP的差错报文的上述8个字节中包含TCP的源端口和目的端口。</p><p>当发送IP分组的源收到ICMP差错报文时需要用这两个端口来确定是哪个应用进程的网络通信出了差错。</p><p><strong>TCP的拥塞窗口cwnd大小与RTT的关系如下所示:</strong></p><p>(1)试画出如图5-25所示的拥塞窗口与RTT的关系曲线。</p><p> (2)指明TCP工作在慢开始阶段的时间间隔。</p><p> (3)指明TCP工作在拥塞避免的时间间隔。</p><p> (4)在RTT &#x3D; 16和RTT &#x3D; 22之后发送方是通过收到三个重复的确认还是通过超时检测到丢失了报文段？</p><p> (5)在RTT &#x3D; 1、RTT &#x3D; 18 和RTT &#x3D; 24时，门限ssthresh分别被设置为多大？</p><p> (6)在RTT等于多少时发送出第70个报文段？</p><p> (7)假定在RTT &#x3D; 26 之后收到了三个重复的确认，因而检测出了报文段的丢失，那么拥塞窗口cwnd和门限ssthresh有多大?<br>（1）<br>（2）慢开始:[1，6]，[23，26]</p><p>（3）拥塞避免:[6,16]，[17，22]</p><p>（4）RTT &#x3D; 16时，发送方是通过收到三个重复的确认，RTT &#x3D; 22后发送方是检测到超时<br>重复确认不会到1，超时会到1<br>（5）RTT &#x3D; 1时，门限为32 ; RTT &#x3D; 18 时，门限为21；RTT &#x3D; 24时，门限为13<br>1时门限到拥塞位置，其他时候看上一次的重复确认&#x2F;超时的cwnd，然后除2<br>（6）<br>RTT已发送的报文段<br>11<br>23<br>37<br>415<br>531<br>663<br>7127<br>所以RTT&#x3D;7时发送出第70个报文段。<br>（7）检测出报文段丢失时，拥塞窗口cwnd是8，因此拥塞窗口cwnd的数值应当减半，等于4，而门限ssthresh应设置为报文段丢失时拥塞窗口8的一半，即4</p><p>5-49 下面是以十六进制格式存储的一个 UDP 首部：<br>CB84000D001C001C<br>试问:<br>(1) 源端口号是什么？CB84<br>(2) 目的端口号是什么？000D<br>(3) 这个用户数据报的总长度是什么？001C<br>(4) 数据长度是多少？001C-8（首部是8）<br>(5)这个分组是从客户到服务器还是从服务器到客户？<br>(6) 客户进程是什么？</p><p>5-74 流量控制和拥塞控制的最主要的区别是什么？发送窗口的大小取决于流量控制还是拥塞控制？</p><p>简单地说，流量控制是在一条 TCP 连接中的接收端才用的措施，用来限制对方（发送端）发送报文的速率，以免在接收端来不及接收。流量控制只控制一个发送端。<br>拥塞控制是用来控制 TCP 连接中发送端发送报文段的速率，以免使互联网中的某处产生过载。拥塞控制可能会同时控制许多个发送端，限制它们的发送速率。不过每一个发送端只知道自己应当怎样调整发送速率，而不知道在互联网中还有哪些主机被限制了发送速率。<br>我们知道，发送窗口的上限值是 Min [rwnd, cwnd]，即发送窗口的数值不能超过接收窗口和拥塞窗口中娇小的一个。接收窗口的大小体现了接收端对发送端施加的流量控制，而拥塞窗口的大小则是整个互联网的负载情况对发送端施加的拥塞控制。因此，当接收窗口小于拥塞窗口时，发送窗口的大小取决于流量控制，即取决于接收端的接收能力。但当拥塞窗口小于接收窗口时，则发送窗口的大小取决于拥塞控制，即取决于整个网络的拥塞状况。</p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>互联网上用IP地址通信，但IP地址难记、难用，常用名字来操作！</p><p>域——区域、地域、行业范围，……；给互联网上的计算机命名。单层次取名肯定不行，多层次的互联网计算机名称涵义丰富、完整、好用！</p><pre><code class="hljs">举例：  www.GDOU.edu.cn  解释其意义。</code></pre><p>为互联网上的计算机取名，多个层次包括：服务+主机名+行业+区域：</p><p>国家或地区顶级域名：cn,hk,tw,om,us,jp,rs,……两个字符，共有180+个</p><p>行业顶级域名：  com,edu,net,gov,org,……三个字符，共有三批20+个。</p><p>服务：www,ftp,mail,……，应用层服务基本都有对应服务名称。</p><p>行业或地域域名都是一级域名，服务是三级域名，主机名称是二级域名</p><p>域名与IP地址有对应数据库，互联网DNS与IP对应数据库有上、下级联系，用此数据库可从任何地点寻找全球任何主机的IP地址。Domain Name System构成是：根（地域）——顶级域名（行业）——各种不同的互联网服务，……，国家根之上还有全球根。</p><p>每个管辖区内（zone）的DNS负责保存本区内“域名<del>IP”对照表，对本区风所有主机的“域名</del>IP”进行分配，批准，解析，并与上级关联。本解析了不了的交上级DNS，……，直至找到。</p><p>DNServer：全球根Server，13个；国家或地区根，1~多个，省、市 DNServer还有若干；</p><p>zone内DNServer三种角色：main DNS负责本地“域名<del>IP”解析，后备DNServer与主DNS内容同步，但不进行解析，在主DNS故障时，自动转为主DNS，原来的主DNS转为后甶并修复。绥冲DNServer是将本地客户访问过的zone外的“域名</del>IP”对照表项保存，方便下个本地客户访问；缓冲DNS运行时间愈长、积累的zone外“域名~IP”内容愈多，本地客户访问愈快。</p><p>DNS端口：53</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>World Wide Web是目前互联网上最大规模的应用，网络信息的发布、传播、浏览、获取、存储、相互关联（联机存储）等，都能轻松的应付自如。通过超链接，可以在全球范围内的主机页面上任意跳转，实现信息高速公路的畅通无阻。</p><p>超文本、超媒体、超链接、……，概念说明。最网页雏形：超文本标记语言，扩充才有后面的一切。文本仅指文字表达形式，超文本则可以表达图形、图像、视频等信息——超媒体！</p><p>网页页面是一个万维网文档，不同主机之间的页面如何关联（交流、通信）？——如何标志？如何相互链接？怎样才能清晰表达并方便使用？</p><p>Uniform Resource Locator——URL，统一资源定位器，标志网络资源在互联网哪台主机的文件目录路径下，用什么通信协议可访问。如：</p><p><code>http:\\www.GDOU.edu.cn:80\default.html</code></p><p><code>协议:\\主机域名:端口\网页文件名</code><br>实际中，可省略为：<a href="http://www.gdou.edu/">www.GDOU.edu</a></p><p>本质上，URL是一个网络资源指针。超链接hyperLink的参象就是URL。</p><p>HyperText Transfer Protocol——HTTP，是万维网上主机之间传送网页的协议，运输层是TCP连接，端口80，是可靠传输协议。端口80是一个连续监听的端口，收到HTTP连接请求后立即响应，传送网页数据到客户端。HTTP三次连接过程分析。第三次握手时，将HTTP请求报文带上发给Server，Server端再回传响应报文。</p><p>请求和获得响应HTTP报文花费2<em>RTT时间，HTTP &#x2F;1.0是：每个请求花费2</em>RTT时间，多个请求则多个2*RTT时间，多个客户还要有不同的绥冲区，这对主机负担很大。同一个客户的非连续请求时间开销大，而HTTP&#x2F;1.1采用连续请求方式，对同一个客户，其申请一次建立的TCP连接会长时保留，多次请求只花费一次建立连接时间。这种流水线工作方式，响应速度加快，主机负担也减轻不少。</p><p>HTTP&#x2F;2又改进了不少，客户可连续发出多个TCP连接请求，建立同一个TCP连接，相当于并行多个TCP连接工作，再次提高了响应速率。，……</p><p>代理服务器是万维网高速缓存，右为内网客户提供更快的响应，将内网客户访问过的链接暂存在代理服务器上，有客户访问同一连接时，本地提供，……；当内网对外接入链路带宽较小时，在内网建立一个代理服务器，让内网客户感觉到上网快了好多。</p><p>HTTP报文结构：请求与响应的格式有一定的区别。请求报文实例介绍：</p><p> (1)   方法  URL  版本Crlf</p><p> (2)   ……</p><p>教材P281实例——请求报文，解释之。  响应报文、状态码等解释之。最好现场捕捉一对HTPP请求、响应报文分析。</p><p>HyperText Markup Language——实例解释“标记语言”</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>静态网页与动态网页的概念区分——引入计算能力的网页是动态网页。</p><h2 id="FTP-Telnet-DHCP"><a href="#FTP-Telnet-DHCP" class="headerlink" title="FTP,Telnet,DHCP"></a>FTP,Telnet,DHCP</h2><p>文件传输要考虑双方的文件格式、命名规则、OS操作命令、访问控制方法等诸多方面的不同。</p><p>FileTrasfer Protocol ——FTP，TCP连接，双端口，21是监听端口，长开，随时接受FTP请求，20是数据端口，传输数据时打开，传完则关闭。</p><p>TFTP是简单文件传输协议，运输层UDP连接，端口69，简单（每次512字节）快速。</p><p>FTP、TFTP是早期互联网应用规模最好的应用，1995年后，WWW应用超过了FTP 、TFTP。</p><p>FTP双TCP连接的工作过程剖析。P270图6-5解释。</p><p>网络文件系统NFS可从文件的任意部位开始改写或读取，避免了整个大文件在网络上重复传输。</p><p>Telnet ——远程登录，TCP端口 23，通过网络，管理员可异地登录到自已所管理的主机上，进行相应权限的操作。目前已很少应用了，有网络安全隐患。</p><p>DHCP——动态主机配置协议，为网络计算机分配一个动态IP地址，地址池中存放一批IP地址，网络中有申请就为其分发。无静态IP地址的站点，入网时发出申请，要求分配一个IP，多个DHCPServer收到申请，为其分配一个IP地址，最先收到的有效。</p><h2 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h2><p>www、FTP、eMail是目前互联网应用前三，微信、APP、网络游戏，头条、抖音，……是移动互联网应用的前几名，……</p><p>发、收双方各自有自已的邮箱（mail box），邮箱之间传送电子邮件。电子邮件系统组成的主要部分，教材P294页图6-16解释之。</p><p>用户代理的主要功能是撰写邮件，送到已方邮件Server中(1)，再由已方邮件Server发出，(2)通过网络送到收方邮件Server中，收方用户从已方邮件Server中读取邮件(3)。</p><p>(1)用SMTP协议，(2)用SMTP协议，(3)用POP3（Post Office Protocol）。</p><p>push——将撰写好的邮件“推入”自已的Server、或从已方e-mail Server   “push”到收方e-mail server，均用SMTP。</p><p>pull ——将邮件从收方e-mail Srever拉出来（读取），用POP3协议。</p><p>电子邮箱名称构成：   用户名@邮箱域名</p><p>SMTP——TCP连接，端口号：25，双方e-mail Server之间建立连接。有一系列的命令对应操作，还有POP、IMAP，MIME（通途互联网邮件扩充）等内容，略。</p><p>某于WEB的电子邮件系统（目前常用），撰写&#x2F;读取邮件，HTTP，e-mail Server之间传送：SMTP，用的更广泛。</p><p>电子邮件安全性——病毒、木马等有害程序的载体，传播媒体，……，当前电子邮件系统中，有严格的审查程序，防止有害程序通过电子邮件系统传播。</p><h2 id="重点概念-2"><a href="#重点概念-2" class="headerlink" title="重点概念"></a>重点概念</h2><p>Domin Name (System,Service,Server)之解释，顶级域名分地域、行业，认识： cn,hk,tw,.com,.edu.net等顶级域名。根DNS，主DNS，后备DNS，缓存DNS等角色，理解DNS的工作原理，</p><p>WWW，URL，HTTP，HTML名词解释</p><p>HTTP请求&#x2F;响应报文格式理解</p><p>网页设计入门——三个主要标记的作用。</p><p>FTP的两个端口，各自的功能与工作方式有何不同？</p><p>SMTP、POP3</p><p>基于WEB的电子邮件系统，用户与本邮件服务器之间用HTTP，发、收双方的邮件服务器之间用SMTP。</p><p>应用层DNS，WWW，FTP，TFTP，Telnet，SMTP在运输层的连接方式与端口。</p><h2 id="课本例题-1"><a href="#课本例题-1" class="headerlink" title="课本例题"></a>课本例题</h2><p><strong>解释以下名词。各英文缩写词的原文是什么？</strong></p><p>www,URL.HTTP,HTML,CGI,浏览器，超文本，超媒体，超链，页面，活动文档，搜索引擎。</p><p>答：www:万维网WWW（World Wide Web）并非某种特殊的计算机网络。万维网是一个大规模的、联机式的信息储藏所，英文简称为Web.万维网用链接的方法能非常方便地从因特网上的一个站点访问另一个站点（也就是所谓的“链接到另一个站点”），从而主动地按需获取丰富的信息。<br>URL:为了使用户清楚地知道能够很方便地找到所需的信息，万维网使用统一资源定位符URL（Uniform Resource Locator）来标志万维网上的各种文档，并使每一个文档在整个因特网的范围内具有唯一的标识符URL.<br>HTTP:为了实现万维网上各种链接，就要使万维网客户程序与万维网服务器程序之间的交互遵守严格的协议，这就是超文本传送协议HTTP.HTTP 是一个应用层协议，它使用TCP 连接进行可靠的传送。<br>CGI:通用网关接口CGI 是一种标准，它定义了动态文档应该如何创建，输入数据应如何提供给应用程序，以及输出结果意如何使用。CGI 程序的正式名字是CGI脚本。按照计算机科学的一般概念。<br>浏览器:一个浏览器包括一组客户程序、一组解释程序，以及一个控制程序。<br>超文本:超文本的基本特征就是可以超链接文档；你可以指向其他位置，该位置可以在当前的文档中、局域网中的其他文档，也可以在因特网上的任何位置的文档中。这些文档组成了一个杂乱的信息网。目标文档通常与其来源有某些关联，并且丰富了来源；来源中的链接元素则将这种关系传递给浏览者。<br>超媒体：超级媒体的简称,是超文本（hypertext）和多媒体在信息浏览环境下的结合。<br>超链：超链接可以用于各种效果。超链接可以用在目录和主题列表中。浏览者可以在浏览器屏幕上单击鼠标或在键盘上按下按键，从而选择并自动跳转到文档中自己感兴趣的那个主题，或跳转到世界上某处完全不同的集合中的某个文档。超链接（hyper text），或者按照标准叫法称为锚（anchor），是使用标签标记的，可以用两种方式表示。锚的一种类型是在文档中创建一个热点，当用户激活或选中（通常是使用鼠标）这个热点时，会导致浏览器进行链接。<br>页面：页面，类似于单篇文章页面，但是和单篇文章不同的是：1.每个页面都可以自定义样式，而单篇文章则共用一个样式。2.页面默认情况一般不允许评论，而单篇文章默认情况允许评论。3.页面会出现在水平导航栏上，不会出现在分类和存档里，而单篇文章会出现在分类和存档里，不会出现在水平导航栏上。<br>活动文档：即正在处理的文档。在Microsof t Word 中键入的文本或插入的图形将出现在活动文档中。活动文档的标题栏是突出显示的。一个基于Windows 的、嵌入到浏览器中的非HTML 应用程序，提供了从浏览器界面访问这些应用程序的功能的方法。<br>搜索引擎：搜索引擎指能够自动从互联网上搜集信息，经过整理以后，提供给用户进行查阅的系统。</p><p><strong>试述电子邮件的最主要的组成部件。用户代理 UA 的作用是什么？没有 UA 行不行？</strong></p><p>答：电子邮件系统的最主要组成部件：用户代理、邮件服务器、以及电子邮件使用的协议。UA就是用户与电子邮件系统的接口。用户代理使用户能够通过一个很友好的接口来发送和接收邮件。没有 UA 不行。因为并非所有的计算机都能运行邮件服务器程序。有些计算机可能没有足够的存储器来运行允许程序在后台运行的操作系统，或是可能没有足够的 CPU 能力来运行邮件服务器程序。更重要的是，邮件服务器程序必须不间断地运行，每天 24 小时都必须不间断地连接在互联网上，否则就可能使很多外面发来的邮件丢失。这样看来，让用户的 PC 机运行邮件服务器程序显然是很不现实的。</p><p><strong>基于万维网的电子邮件系统有什么特点？在传送邮电时使用什么协议？</strong></p><p>答：特点：不管在什么地方，只要能上网，在打开万维网浏览器后，就可以收发电子邮件。这时，邮件系统中的用户代理就是普通的万维网。<br>电子邮件从 A 发送到网易邮件服务器是使用 HTTP 协议。两个邮件服务器之间的传送使用 SMTP。邮件从新浪邮件服务器传送到 B 是使用 HTTP 协议。</p><p><strong>DHCP 协议用在什么情况下？当一台计算机第一次运行引导程序时，其 ROM 中有没有该 IP 地址，子网掩码或某个域名服务器的 IP 地址？</strong></p><p>答：动态主机配置协议 DHCP 提供了即插即用连网的机制。这种机制允许一台计算机加入新的网络和获取 IP 地址而不用手工参与；ROM中没有IP地址，子网掩码或某个域名服务器的IP地址</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySql的表空间</title>
    <link href="/2023/09/14/MySql%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4/"/>
    <url>/2023/09/14/MySql%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="独立表空间结构"><a href="#独立表空间结构" class="headerlink" title="独立表空间结构"></a>独立表空间结构</h1><h2 id="区（extent）"><a href="#区（extent）" class="headerlink" title="区（extent）"></a>区（extent）</h2><p>空间中的页实在是太多了，为了更好的管理这些页面，设计InnoDB的提出了区（英文名：extent）的概念。对于16KB的页来说，连续的64个页就是一个区，也就是说一个区默认占用1MB空间大小。不论是系统表空间还是独立表空间，都可以看成是由若干个区组成的，每256个区被划分成一组。</p><p><img src="https://pic.liahnu.top/img/202309142121057.png"></p><p>第一个组最开始的3个页面的类型是固定的，也就是说extent 0这个区最开始的3个页面的类型是固定的，分别是：</p><ul><li><p>FSP_HDR类型：这个类型的页面是用来登记整个表空间的一些整体属性以及本组所有的区，也就是extent 0 ~ extent 255这256个区的属性。需要注意的一点是，整个表空间只有一个FSP_HDR类型的页面。</p></li><li><p>IBUF_BITMAP类型：这个类型的页面是存储本组所有的区的所有页面关于INSERT BUFFER的信息。</p></li><li><p>INODE类型：这个类型的页面存储了许多称为INODE的数据结构。</p></li></ul><p>其余各组最开始的2个页面的类型是固定的，也就是说extent 256、extent 512这些区最开始的2个页面的类型是固定的，分别是：</p><ul><li><p>XDES类型：全称是extent descriptor，用来登记本组256个区的属性，也就是说对于在extent 256区中的该类型页面存储的就是extent 256 ~ extent 511这些区的属性，对于在extent 512区中的该类型页面存储的就是extent 512 ~ extent 767这些区的属性。上边介绍的FSP_HDR类型的页面其实和XDES类型的页面的作用类似，只不过FSP_HDR类型的页面还会额外存储一些表空间的属性。</p></li><li><p>IBUF_BITMAP类型：上边介绍过了。</p></li></ul><h3 id="为什么要提出区"><a href="#为什么要提出区" class="headerlink" title="为什么要提出区"></a>为什么要提出区</h3><p>我们每向表中插入一条记录时，也就是想索引添加记录，B+树的每一层中的页都会形成一个双向链表，如果是以页为单位来分配存储空间的话，双向链表相邻的两个页之间的物理位置可能离得非常远。我们介绍B+树索引的适用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的随机I&#x2F;O。这对于速度影响恒大，所以我们需要尽量减少随机I&#x2F;O的次数。</p><p>引入了区（extent）的概念，一个区就是在物理位置上连续的64个页。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区为单位分配，甚至在表中的数据十分非常特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费，但是从性能角度看，可以消除很多的随机I&#x2F;O，功大于过嘛！</p><h2 id="段（segment）"><a href="#段（segment）" class="headerlink" title="段（segment）"></a>段（segment）</h2><p>InnoDB对B+树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个段（segment），存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。</p><p>默认情况下一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的。，一个区默认占用1M存储空间，对于不足以填满一个区的情况，提出了碎片（fragment）区的概念。也就是在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。所以此后为某个段分配存储空间的策略是这样的：</p><ul><li><p>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</p></li><li><p>当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间。</p></li></ul><h3 id="区的分类"><a href="#区的分类" class="headerlink" title="区的分类"></a>区的分类</h3><ul><li><p><strong>空闲的区（FREE）</strong>现在还没有用到这个区中的任何页面。</p></li><li><p><strong>有剩余空间的碎片区（FREE_FRAG）</strong>表示碎片区中还有可用的页面。</p></li><li><p><strong>没有剩余空间的碎片区（FULL_FRAG）</strong>表示碎片区中的所有页面都被使用，没有空闲页面。</p></li><li><p><strong>附属于某个段的区（FSEG）</strong>每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位。</p></li></ul><p>为了方便管理这些区，设计InnoDB的设计了一个称为XDES Entry的结构（全称就是Extent Descriptor Entry），每一个区都对应着一个XDES Entry结构，这个结构记录了对应的区的一些属性。</p><p><img src="https://pic.liahnu.top/img/202309181643532.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC与多线程</title>
    <link href="/2023/09/04/RPC%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2023/09/04/RPC%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么使用Go不使用C-等语言"><a href="#为什么使用Go不使用C-等语言" class="headerlink" title="为什么使用Go不使用C++等语言"></a>为什么使用Go不使用C++等语言</h1><ol><li>因为Go语言有go程，可以方便创建以及使用线程</li><li>Go是类型安全和内存安全的，不需要像c++一样处理复杂的内存问题</li><li>同时，这门语言比C++简单</li></ol><h1 id="分布式下的多线程操作"><a href="#分布式下的多线程操作" class="headerlink" title="分布式下的多线程操作"></a>分布式下的多线程操作</h1><p>在分布式下，客户端可能需要对多个进行处理，这时候就要使用多线程对其进行操作。</p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><h2 id="并行性"><a href="#并行性" class="headerlink" title="并行性"></a>并行性</h2>]]></content>
    
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySql-索引</title>
    <link href="/2023/07/17/MySql-%E7%B4%A2%E5%BC%95/"/>
    <url>/2023/07/17/MySql-%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="没有索引的情况"><a href="#没有索引的情况" class="headerlink" title="没有索引的情况"></a>没有索引的情况</h1><h2 id="在一个页中的查找"><a href="#在一个页中的查找" class="headerlink" title="在一个页中的查找"></a>在一个页中的查找</h2><p>假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p><ul><li>以主键为搜索条件</li></ul><p>在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p><ul><li>以其他列作为搜索条件</li></ul><p>对非主键列的查找的过程可就不这么幸运了，因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</p><h2 id="在很多页中查找"><a href="#在很多页中查找" class="headerlink" title="在很多页中查找"></a>在很多页中查找</h2><p>大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：</p><p>定位到记录所在的页。<br>从所在的页内中查找相应的记录。<br>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们刚刚唠叨过的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是非常耗时的，这时候就要用到索引了。</p><h1 id="InnoDB中的索引方案"><a href="#InnoDB中的索引方案" class="headerlink" title="InnoDB中的索引方案"></a>InnoDB中的索引方案</h1><h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>InnoDB是使用页来作为管理存储空间的基本单位，也就是最多能保证16KB的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。</p><p>InnoDB中，目录页索引复用了最基础的页。只不过目录项中的两个列是主键和页号而已，所以他们复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为目录项记录。</p><p>同时，InnoDB会将所有的目录项记录都存放到一张叫做聚集索引的B+树中，这棵B+树的叶子节点就是目录项记录，而非叶子节点则是目录项记录的页号。这样，我们就可以通过B+树来快速的定位到目录项记录所在的页，然后再根据目录项记录中的页号找到对应的数据页，最后再在数据页中查找相应的记录。</p><p><img src="https://pic.liahnu.top/img/202307190018774.png"></p><p>我们上边介绍的B+树本身就是一个目录，或者说本身就是一个索引。它有两个特点：</p><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p><ol><li><p>页内的记录是按照主键的大小顺序排成一个单向链表。</p></li><li><p>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。</p></li><li><p>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</p></li></ol><p>B+树的叶子节点存储的是完整的用户记录。</p><p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p><p>我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX语句去创建（后边会介绍索引相关的语句），InnoDB存储引擎会自动的为我们创建聚簇索引。另外有趣的一点是，在InnoDB存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据，数据即索引。</p><h2 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h2><p>上边介绍的聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件时，这时候就需要用到二级索引了。</p><p>我们可以多建几棵B+树，不同的B+树中的数据采用不同的排序规则。如下图</p><p><img src="https://pic.liahnu.top/img/202309102235281.png"></p><p>这颗B+树与聚类索引的树有以下几方面的不同</p><ol><li><p>页内的记录是按照<strong>索引参数</strong>的大小顺序排成一个单向链表。</p></li><li><p>各个存放用户记录的页也是根据页中记录的<strong>索引参数</strong>大小顺序排成一个双向链表。</p></li><li><p>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的<strong>索引参数</strong>列大小顺序排成一个双向链表。</p></li><li><p>B+树的叶子节点存储的并不是完整的用户记录，而只是<strong>索引参数</strong>+主键这两个列的值。</p></li><li><p>目录项记录中不再是主键+页号的搭配，而变成了<strong>索引参数</strong>列+页号的搭配</p></li></ol><p>因为这个B+树的叶子节点中的记录只存储了<strong>索引参数</strong>和主键两个列，所以我们必须再根据主键值去聚簇索引中再查找一遍，才能得到完整的用户记录。这个过程也被称为回表。因为需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为二级索引（英文名secondary index），或者辅助索引。</p><div class="note note-success">            <p><strong>为什么不能把用户记录放到叶子节点中</strong></p><p>如果把完整的用户记录放到叶子节点是可以不用回表，但是太占地方。相当于于每建立一棵B+树都需要把所有的用户记录再都拷贝一遍。</p>          </div><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引,此时建立的索引叫做联合索引。但是其任然属于二级索引的一种。</p><p><img src="https://pic.liahnu.top/img/202309102244158.png"></p><p>每条目录项记录都由c2、c3、页号这三个部分组成，页面和记录先按照联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序。</p><h2 id="InnoDB的B-树索引的注意事项"><a href="#InnoDB的B-树索引的注意事项" class="headerlink" title="InnoDB的B+树索引的注意事项"></a>InnoDB的B+树索引的注意事项</h2><h3 id="根页面万年不动窝"><a href="#根页面万年不动窝" class="headerlink" title="根页面万年不动窝"></a>根页面万年不动窝</h3><p>一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是InnoDB存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。</p><h3 id="内节点中目录项记录的唯一性"><a href="#内节点中目录项记录的唯一性" class="headerlink" title="内节点中目录项记录的唯一性"></a>内节点中目录项记录的唯一性</h3><p>为了让新插入记录能找到自己在那个页里，我们需要保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><p>这样我们再插入记录(9, 1, ‘c’)时，由于页3中存储的目录项记录是由c2列 + 主键 + 页号的值构成的，可以先把新记录的c2列的值和页3中各目录项记录的c2列的值作比较，如果c2列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的c2列 + 主键的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到页5中。</p><h3 id="一个页面最少存储2条记录"><a href="#一个页面最少存储2条记录" class="headerlink" title="一个页面最少存储2条记录"></a>一个页面最少存储2条记录</h3><p>我们前边说过一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度杠杠的！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中只能存放一条记录。费了半天劲只能存放一条真实的用户记录？逗我呢？所以InnoDB的一个数据页至少可以存放两条记录。</p><h1 id="B-树索引的使用"><a href="#B-树索引的使用" class="headerlink" title="B+树索引的使用"></a>B+树索引的使用</h1><h2 id="使用的代价"><a href="#使用的代价" class="headerlink" title="使用的代价"></a>使用的代价</h2><ul><li><strong>空间上的代价</strong></li></ul><p>这个是显而易见的，每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用16KB的存储空间，一棵很大的B+树由许多数据页组成，那可是很大的一片存储空间呢。</p><ul><li><strong>时间上的代价</strong></li></ul><p>每次对表中的数据进行增、删、改操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收啥的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，这还能不给性能拖后腿么？</p><p>所以说，一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。</p><h2 id="B-树索引适用查找匹配的情况"><a href="#B-树索引适用查找匹配的情况" class="headerlink" title="B+树索引适用查找匹配的情况"></a>B+树索引适用查找匹配的情况</h2><p><strong>全值匹配</strong><br>如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM person_info WHERE name = &#x27;Ashburn&#x27; AND birthday = &#x27;1990-09-27&#x27; AND phone_number = &#x27;15123983239&#x27;;<br></code></pre></td></tr></table></figure><p>在查询过程中会按照<code>name</code>、<code>birthday</code>、<code>phone_number</code>的顺序进行查找，因为这三个列都是联合索引的一部分，所以可以快速的定位到目录项记录所在的页，然后再根据页号找到对应的数据页，最后再在数据页中查找相应的记录。</p><p>其中,查询的顺序对索引是没有影响的,MySQL有一个叫查询优化器,可以优化查询语句.</p><p><strong>匹配左边的列</strong></p><p>在搜索中,包含匹配左边的项,就可以使用到这个索引,原因和上面的一样,mysql会按照索引从左到右的顺序进行查找.</p><p><strong>匹配范围值</strong></p><p>在搜索中,包含匹配范围值,就可以使用到这个索引,原因和上面的一样,mysql会按照索引从左到右的顺序进行查找.</p><p><strong>字符串前缀匹配</strong></p><p>在搜索中,字符串是按照其的值进行排序,所以可以使用到这个索引进行排序,但是如果使用到了字符串的后缀,就不能使用到这个索引了.</p><p><strong>精确匹配某一列并范围匹配另外一列</strong></p><p>对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找.</p><p><strong>用于排序</strong></p><p>使用ORDER BY子句按照某种规则进行排序时,一般情况下，我们只能把记录都加载到内存中(或者文件做暂存)，通过排序算法对其进行排序，然后再返回给客户端。</p><p>但是如果ORDER BY子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤,直接输出排序结果</p><p><strong>用于分组</strong></p><p>然后针对那些分组进行统计，比如在我们这个查询语句中就是统计每个分组包含的记录条数。如果没有索引的话，这个分组过程全部需要在内存里实现，而如果有了索引的话，恰巧这个分组顺序又和我们的B+树中的索引列的顺序是一致的，而我们的B+树索引又是按照索引列排好序的，这不正好么，所以可以直接使用B+树索引进行分组。</p><h3 id="使用索引的总结"><a href="#使用索引的总结" class="headerlink" title="使用索引的总结"></a>使用索引的总结</h3><p>能不能使用索引关键在于查询的列是否是索引的一部分,同时其排序与索引结构相同.那么就可以使用索引，如果不是索引的一部分，那么就不能使用索引。</p><h3 id="回表的代价"><a href="#回表的代价" class="headerlink" title="回表的代价"></a>回表的代价</h3><p>回表的代价是非常高的，因为回表的过程需要再次访问数据页，而且还需要再次访问数据页中的目录项记录，这个过程需要进行两次磁盘IO操作，所以回表的代价是非常高的。</p><p>在mysql中有<strong>查询优化器</strong>,查询优化器会事先对表中的记录计算一些统计数据,然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数,需要回表的记录数越多，就越倾向于使用全表扫描,反之倾向于使用二级索引 + 回表的方式.</p><p>为了彻底告别回表操作带来的性能损耗，我们最好在查询列表里只包含索引列.</p><h2 id="如何建立索引"><a href="#如何建立索引" class="headerlink" title="如何建立索引"></a>如何建立索引</h2><p><strong>只为用于搜索、排序或分组的列创建索引</strong></p><p>只为出现在WHERE子句中的列、连接子句中的连接列，或者出现在ORDER BY或GROUP BY子句中的列创建索引。</p><p><strong>考虑列的基数</strong></p><p>列的基数指的是某一列中不重复数据的个数,其中基数越大,索引的效果越好.因为当基数小的时候,数的离散程度越小,在排序的时候,需要进行的比较次数越少多,所以效率越低.</p><p><strong>索引列的类型尽量小</strong></p><ul><li><p>数据类型越小，在查询时进行的比较操作越快（这是CPU层次的东东）</p></li><li><p>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I&#x2F;O带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</p></li></ul><p><strong>索引字符串值的前缀</strong></p><p>原因同上,对于字符串只存储前缀,可以减少索引的大小,从而减少磁盘I&#x2F;O带来的性能损耗.</p><p><strong>让索引列在比较表达式中单独出现</strong></p><p>如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。</p><p><strong>主键插入顺序</strong></p><p>当向项中间插入一个页面时候,如果该页面已经存满,此时会发生页面分裂和记录移位,此时就会发生性能损耗.因此最好将主键设置为自动递增的形式</p><p><strong>减少冗余索引</strong></p><p>给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。</p>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法设计课程期末考试笔记</title>
    <link href="/2023/06/28/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/06/28/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="逆序对计算的分治算法"><a href="#逆序对计算的分治算法" class="headerlink" title="逆序对计算的分治算法"></a>逆序对计算的分治算法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 逆序对计算的分治算法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">count_inversions_dc</span>(<span class="hljs-params">A</span>):<br>    lenA = <span class="hljs-built_in">len</span>(A)<br>    <span class="hljs-keyword">if</span> lenA &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, A<br>    middle = lenA // <span class="hljs-number">2</span><br>    leftA = A[:middle]<br>    rightA = A[middle:]<br>    countLA, leftA = count_inversions_dc(leftA)<br>    countRA, rightA = count_inversions_dc(rightA)<br>    countLRA, mergedA = mac(leftA, rightA)<br><br>    <span class="hljs-keyword">return</span> countLA + countRA + countLRA, mergedA<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mac</span>(<span class="hljs-params">A, B</span>):<br>    i, j, count = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    alist = []<br>    lenA = <span class="hljs-built_in">len</span>(A)<br>    lenB = <span class="hljs-built_in">len</span>(B)<br>    <span class="hljs-keyword">while</span> i &lt; lenA <span class="hljs-keyword">and</span> j &lt; lenB:<br>        <span class="hljs-keyword">if</span> A[i] &lt; B[j]:<br>            alist.append(A[i])<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            count += lenA - i<br>            alist.append(B[j])<br>            j += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> i &lt; lenA:<br>        alist.append(A[i])<br>        i += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> j &lt; lenB:<br>        alist.append(B[j])<br>        j += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> count, alist<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    a = [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<br>    c, b = count_inversions_dc(a)<br>    <span class="hljs-built_in">print</span>(c, b)<br><br></code></pre></td></tr></table></figure><h1 id="硬币找零的贪心算法"><a href="#硬币找零的贪心算法" class="headerlink" title="硬币找零的贪心算法"></a>硬币找零的贪心算法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gmc</span>(<span class="hljs-params">amt</span>):<br>    coin = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">25</span>, <span class="hljs-number">100</span>]<br>    cl = []<br>    sc = <span class="hljs-built_in">sorted</span>(coin, reverse=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">for</span> cv <span class="hljs-keyword">in</span> sc:<br>        cc = <span class="hljs-built_in">int</span>(amt / cv)<br>        cl += [cv, ] * cc<br>        amt -= cv * cc<br>        <span class="hljs-keyword">if</span> amt &lt;= <span class="hljs-number">0.0</span>:<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> cl<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(gmc(<span class="hljs-number">38</span>))<br></code></pre></td></tr></table></figure><h1 id="连续子序列和最大值动态规划算法"><a href="#连续子序列和最大值动态规划算法" class="headerlink" title="连续子序列和最大值动态规划算法"></a>连续子序列和最大值动态规划算法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">zxlmax</span>(<span class="hljs-params">alist</span>):<br>    table = [<span class="hljs-number">0</span>] * (<span class="hljs-built_in">len</span>(alist) + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(alist) + <span class="hljs-number">1</span>):<br>        table[i] = <span class="hljs-built_in">max</span>(table[i - <span class="hljs-number">1</span>] + alist[i - <span class="hljs-number">1</span>], alist[i-<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> table<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tbs</span>(<span class="hljs-params">alist, table</span>):<br>    <span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>    select = []<br>    max_sum = <span class="hljs-built_in">max</span>(table)<br>    ind_max = np.argmax(table)<br>    <span class="hljs-keyword">while</span> ind_max &gt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">if</span> table[ind_max] == alist[ind_max - <span class="hljs-number">1</span>] + table[ind_max - <span class="hljs-number">1</span>]:<br>            select.append(alist[ind_max - <span class="hljs-number">1</span>])<br>            ind_max -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            select.append(alist[ind_max - <span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> select<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    a = [<span class="hljs-number">2</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>, <span class="hljs-number">13</span>, -<span class="hljs-number">5</span>]<br>    table = zxlmax(a)<br>    s=tbs(a,table)<br>    <span class="hljs-built_in">print</span>(s, table)<br><br></code></pre></td></tr></table></figure><h1 id="矩阵连乘最优结合问题"><a href="#矩阵连乘最优结合问题" class="headerlink" title="矩阵连乘最优结合问题"></a>矩阵连乘最优结合问题</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">gk = <span class="hljs-keyword">lambda</span> i,j :<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&#x27;,&#x27;</span>+<span class="hljs-built_in">str</span>(j)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mmc</span>(<span class="hljs-params">p</span>):<br>    n=<span class="hljs-built_in">len</span>(p)-<span class="hljs-number">1</span><br>    m=&#123;&#125;<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (i,n+<span class="hljs-number">1</span>):<br>            m[gk(i,j)]=<span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>)<br>    <span class="hljs-keyword">return</span> lc(m,p,<span class="hljs-number">1</span>,n)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lc</span>(<span class="hljs-params">m,p,i,j</span>):<br>    <span class="hljs-keyword">if</span> m[gk(i,j)]&lt;<span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>):<br>        <span class="hljs-keyword">return</span> m[gk(i,j)]<br>    <span class="hljs-keyword">if</span> i==j :<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i,j):<br>            q=lc(m,p,i,k)+lc(m,p,k+<span class="hljs-number">1</span>,j)+p[i-<span class="hljs-number">1</span>]*p[k]*p[j]<br>        <span class="hljs-keyword">if</span> q&lt; m[gk(i,j)]:<br>            m[gk(i,j)]=q<br>    <span class="hljs-keyword">return</span> m[gk(i,j)]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    p=[<span class="hljs-number">30</span>,<span class="hljs-number">35</span>,<span class="hljs-number">15</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">25</span>]<br>    <span class="hljs-built_in">print</span>(gk(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<br>    <span class="hljs-built_in">print</span>(mmc(p))<br></code></pre></td></tr></table></figure><h1 id="二维0-1背包问题"><a href="#二维0-1背包问题" class="headerlink" title="二维0-1背包问题"></a>二维0-1背包问题</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bb</span>(<span class="hljs-params">W,wt,val,n</span>):<br>    K=[[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(W+<span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (n+<span class="hljs-number">1</span>)]<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (n+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(W+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> w==<span class="hljs-number">0</span>:<br>                K[i][w]=<span class="hljs-number">0</span><br>            <span class="hljs-keyword">elif</span> wt[i-<span class="hljs-number">1</span>]&lt;=w:<br>                K[i][w]=<span class="hljs-built_in">max</span>(val[i-<span class="hljs-number">1</span>]+K[i-<span class="hljs-number">1</span>][w-wt[i-<span class="hljs-number">1</span>],K[i-<span class="hljs-number">1</span>][w]])<br>            <span class="hljs-keyword">else</span>:<br>                K[i][w]=K[i-<span class="hljs-number">1</span>][w]<br>    <span class="hljs-keyword">return</span> K<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">aa</span>(<span class="hljs-params">w,wt,val,n</span>):<br>    <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> w==<span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> wt[n-<span class="hljs-number">1</span>]&gt;w:<br>        <span class="hljs-keyword">return</span> aa(w,wt,val,n-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(val[n-<span class="hljs-number">1</span>]+aa(w-wt[n-<span class="hljs-number">1</span>],wt,val,n-<span class="hljs-number">1</span>),aa(w,wt,val,n-<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><h1 id="间隔任务规划"><a href="#间隔任务规划" class="headerlink" title="间隔任务规划"></a>间隔任务规划</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gmi</span>(<span class="hljs-params">joblist</span>):<br>    js=[]<br>    nj=<span class="hljs-built_in">len</span>(joblist)<br>    joblist.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">2</span>])<br>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nj):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> js:<br>            js.append(joblist[n])<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> js[-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]&lt;joblist[n][<span class="hljs-number">1</span>]:<br>                js.append(joblist[n])<br>    <span class="hljs-keyword">return</span> js<br><br></code></pre></td></tr></table></figure><h1 id="求最大岛屿问题"><a href="#求最大岛屿问题" class="headerlink" title="求最大岛屿问题"></a>求最大岛屿问题</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python">dx = [<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br>dy = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br>vis = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>)] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>)]<br>res = <span class="hljs-number">0</span><br>ans = <span class="hljs-number">0</span><br>graph = [[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],<br>         [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],<br>         [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>         [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>         [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>         [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>         [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>], ]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x, y</span>):<br>    flag = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">global</span> res<br>    <span class="hljs-keyword">global</span> ans<br>    <span class="hljs-keyword">global</span> graph<br>    <span class="hljs-keyword">global</span> dx<br>    <span class="hljs-keyword">global</span> dy<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>):<br>        tox = x + dx[i]<br>        toy = y + dy[i]<br>        <span class="hljs-keyword">if</span> tox &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> tox &gt; <span class="hljs-number">6</span> <span class="hljs-keyword">or</span> toy &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> toy &gt; <span class="hljs-number">6</span>:<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> vis[tox][toy] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> graph[tox][toy]:<br>            vis[tox][toy] = <span class="hljs-number">1</span><br>            ans = ans + <span class="hljs-number">1</span><br>            dfs(tox, toy)<br>    <span class="hljs-keyword">return</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>):<br>            <span class="hljs-keyword">if</span> graph[i][j] == <span class="hljs-number">1</span>:<br>                vis[i][j] = <span class="hljs-number">1</span><br>                ans = <span class="hljs-number">1</span><br>                dfs(i, j)<br>                res = <span class="hljs-built_in">max</span>(res, ans)<br>    <span class="hljs-built_in">print</span>(res)<br><br></code></pre></td></tr></table></figure><h1 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pdb<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Place</span>(<span class="hljs-params">k</span>):<br>    <span class="hljs-comment"># 注意：k从索引0开始</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(k - j) == <span class="hljs-built_in">abs</span>(rect[k] - rect[j]) <span class="hljs-keyword">or</span> rect[k] == rect[j]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">QueensLV</span>(<span class="hljs-params">n</span>):  <span class="hljs-comment"># 返回一个bool值，得到解返回True，否则False</span><br>    k = <span class="hljs-number">0</span>  <span class="hljs-comment"># 第一个索引为0</span><br>    rect[k] = random.randint(<span class="hljs-number">0</span>, n)<br>    <span class="hljs-keyword">while</span> (Place(k)):<br>        <span class="hljs-keyword">if</span> k == n - <span class="hljs-number">1</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;八皇后问题的一个解为：&#x27;</span>, rect)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        k += <span class="hljs-number">1</span><br>        rect[k] = random.randint(<span class="hljs-number">0</span>, n)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    n = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入皇后数量：&#x27;</span>)<br>    n = <span class="hljs-built_in">int</span>(n)<br>    rect = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;输入的棋盘：&#x27;</span>, rect)<br>    errorcount = <span class="hljs-number">0</span>  <span class="hljs-comment"># 失败次数</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">not</span> QueensLV(n)):<br>        errorcount += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;共尝试了&#123;&#125;次放置皇后的位置&#x27;</span>.<span class="hljs-built_in">format</span>(errorcount))<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL InnoDB存储引擎</title>
    <link href="/2023/06/19/MySQL-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <url>/2023/06/19/MySQL-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h1><h2 id="存储引擎的概念"><a href="#存储引擎的概念" class="headerlink" title="存储引擎的概念"></a>存储引擎的概念</h2><p>MySQL服务器把数据的存储和提取操作都封装到了一个叫存储引擎的模块里。为了实现不同的功能，MySQL提供了各式各样的存储引擎，不同存储引擎管理的表具体的存储结构可能不同，采用的存取算法也可能不同。</p><p>为了管理方便，人们把连接管理、查询缓存、语法解析、查询优化这些并不涉及真实数据存储的功能划分为MySQL server的功能，把真实存取数据的功能划分为存储引擎的功能。各种不同的存储引擎向上边的MySQL server层提供统一的调用接口实现。</p><h2 id="常用存储引擎"><a href="#常用存储引擎" class="headerlink" title="常用存储引擎"></a>常用存储引擎</h2><p><img src="https://pic.liahnu.top/img/202306190246424.png"></p><p>在此之中，最常用的是InnoDB和MyISAM，InnoDB是MySQL的默认存储引擎。</p><h1 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>InnoDB是一个将表中的数据存储到磁盘上的存储引擎。众所周知，磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时，InnoDB存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死，InnoDB采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16 KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。</p><h2 id="InnoDB行格式"><a href="#InnoDB行格式" class="headerlink" title="InnoDB行格式"></a>InnoDB行格式</h2><p>我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为行格式或者记录格式。目前InnoDB存储引擎的有4种不同类型的行格式，分别是Compact、Redundant、Dynamic和Compressed行格式。</p><h3 id="Compact行格式"><a href="#Compact行格式" class="headerlink" title="Compact行格式"></a>Compact行格式</h3><p><img src="https://pic.liahnu.top/img/202306191927854.png"></p><p>Compact行格式分为，记录的额外信息和记录的真实数据两大部分。</p><h4 id="记录的额外信息"><a href="#记录的额外信息" class="headerlink" title="记录的额外信息"></a>记录的额外信息</h4><p>记录的额外信息包括：变长字段长度列表、NULL列列表、记录头信息。</p><p><strong>变长字段长度列表</strong></p><p>变长字段长度列表是一个按照列顺序记录的变长字段的长度列表，每个长度占用1或2个字节，1个字节表示长度小于等于255，2个字节表示长度大于255。</p><p>这个列表的作用是：当我们要获取某条记录的某个变长字段时（例如VARCHAR），其存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。通过这样，形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放。</p><p>另外需要注意的一点是，变长字段长度列表中只存储值为 非NULL 的列内容占用的长度，值为 NULL 的列的长度是不储存的 。</p><p><strong>NULL列列表</strong></p><p>NULL列列表是一个按照列顺序记录的NULL列的列表，每个NULL列占用1个字节，1个字节表示有NULL值，0个字节表示没有NULL值。</p><p>这个列表的作用是：当我们要获取某条记录的某个列时，我们可以通过这个列表快速的定位到该列是否有NULL值。这样可以减少<code>记录的真实数据</code> 存储的空间。</p><p><strong>记录头信息</strong></p><p>记录头信息是由固定的5个字节组成。5个字节也就是40个二进制位，不同的位代表不同的意思</p><p><img src="https://pic.liahnu.top/img/202306191938103.png"></p><h4 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h4><p>记录的真实数据是由各个列的数据组成的，每个列的数据占用的字节数是固定的，不会因为数据的实际长度而改变。</p><p>记录的真实数据除了我们自己定义的列的数据以外，MySQL会为每个记录默认的添加一些列（也称为隐藏列），具体的列如下：</p><p><img src="https://pic.liahnu.top/img/202306201654028.png"></p><p>实际记录的格式如下</p><p><img src="https://pic.liahnu.top/img/202306201657516.png"></p><h3 id="Redundant行格式"><a href="#Redundant行格式" class="headerlink" title="Redundant行格式"></a>Redundant行格式</h3><p><img src="https://pic.liahnu.top/img/202306211215814.png"></p><p>Compact行格式的开头是变长字段长度列表，而Redundant行格式的开头是字段长度偏移列表，与变长字段长度列表有两处不同：</p><p>没有了变长两个字，意味着Redundant行格式会把该条记录中所有列（包括隐藏列）的长度信息都按照逆序存储到字段长度偏移列表。</p><p>多了个偏移两个字，这意味着计算列值长度的方式不像Compact行格式那么直观，它是采用两个相邻数值的差值来计算各个列值的长度。</p><h4 id="Redundant行格式中的char类型"><a href="#Redundant行格式中的char类型" class="headerlink" title="Redundant行格式中的char类型"></a>Redundant行格式中的char类型</h4><p>Compact行格式在CHAR(M)类型时，分变长字符集和定长字符集的情况，而在Redundant行格式中，只要是使用CHAR(M)类型，占用的真实数据空间就是该字符集表示一个字符最多需要的字节数和M的乘积。比方说使用utf8字符集的CHAR(10)类型的列占用的真实数据空间始终为30个字节，使用gbk字符集的CHAR(10)类型的列占用的真实数据空间始终为20个字节。由此可以看出来，使用Redundant行格式的CHAR(M)类型的列是不会产生碎片的。</p><h3 id="Dynamic和Compressed行格式"><a href="#Dynamic和Compressed行格式" class="headerlink" title="Dynamic和Compressed行格式"></a>Dynamic和Compressed行格式</h3><p>这俩行格式和Compact行格式很像，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。</p><h1 id="InnoDB的索引页结构"><a href="#InnoDB的索引页结构" class="headerlink" title="InnoDB的索引页结构"></a>InnoDB的索引页结构</h1><p>页是InnoDB管理存储空间的基本单位，一个页的大小一般是16KB。InnoDB为了不同的目的而设计了许多种不同类型的页，比如存放表空间头部信息的页，存放Insert Buffer信息的页，存放INODE信息的页，存放undo日志信息的页等等。表中记录的那种类型的页叫做索引（INDEX）页。</p><h2 id="页的结构"><a href="#页的结构" class="headerlink" title="页的结构"></a>页的结构</h2><p>InnoDb主要分为以下七个部分，下面是其相关的介绍。</p><p><img src="https://pic.liahnu.top/img/202306301545053.png"></p><h3 id="记录在页中的存储"><a href="#记录在页中的存储" class="headerlink" title="记录在页中的存储"></a>记录在页中的存储</h3><p>在页的7个组成部分中，我们自己存储的记录会按照我们指定的行格式存储到User Records部分。</p><p><img src="https://pic.liahnu.top/img/202307030036212.png"></p><p>mysql的页会在创建的时候生成一个制定大小的Free Space空间；当增加行时候，尚未使用的存储空间中（Free Space）申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了。</p><h3 id="记录在页中的创建"><a href="#记录在页中的创建" class="headerlink" title="记录在页中的创建"></a>记录在页中的创建</h3><p>这里回到刚开始的，Compact行格式中的记录头信息。</p><p><img src="https://pic.liahnu.top/img/202306191938103.png" alt="记录头信息"></p><p>Mysql在创建一个新的页的时候，会自动创建两记录，分别为Infimum Supremum，分别代表最大记录和最小记录。这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成（对应参数）。</p><p>它们并不存放在页的User Records部分，他们被单独放在一个称为Infimum + Supremum的部分。</p><p><img src="https://pic.liahnu.top/img/202307030050368.png"></p><p>在创建了这两条记录之后，我们自己的记录就可以被插入到页的User Records部分了。其中，记录会按照主键的顺序插入到页中，如果主键相同，那么会按照主键以外的唯一索引的顺序插入到页中。</p><p>我们自己的创建的记录会通过单链表的方式连接起来，这个单链表的头部就是Infimum记录，尾部就是Supremum记录。通过<code>next_record</code>指针可以找到下一条记录。<code>next_record</code>值代表与下一条记录的偏移量（实际指向<strong>记录头信息和真实数据之间的位置</strong>），如果<code>next_record</code>值为0，那么就代表这是最后一条记录。</p><div class="note note-success">            <p>因为这个位置对于数据和信息的位置正好，向左读取就是记录头信息，向右读取就是真实数据。</p>          </div><h3 id="记录在页中的删除"><a href="#记录在页中的删除" class="headerlink" title="记录在页中的删除"></a>记录在页中的删除</h3><p>删除一条记录主要有以下几个变化，如图所示：</p><p><img src="https://pic.liahnu.top/img/202307030056362.png"></p><ul><li>第二条记录并没有从存储空间中移除，而是把该条记录的delete_mask值设置为1。</li><li>第二条记录的next_record值变为了0，意味着该记录没有下一条记录了。</li><li>第一条记录的next_record指向了第3条记录。</li><li>最大记录的n_owned值从5变成了4</li></ul><p>主键值为2的记录被我们删掉了，但是存储空间却没有回收，如果我们再次把这条记录插入到表中，会发生什么事呢？</p><p>InnoDB并没有因为新记录的插入而为它申请新的存储空间，而是直接复用了原来被删除记录的存储空间。</p><p>当数据页中存在多条被删除掉的记录时，这些记录的next_record属性将会把这些被删除掉的记录组成一个垃圾链表，以备之后重用这部分存储空间。</p><h3 id="记录在页中的查找"><a href="#记录在页中的查找" class="headerlink" title="记录在页中的查找"></a>记录在页中的查找</h3><p>我们知道记录在页中是以单链表的形式存储的，那么我们如何通过主键值来查找记录呢？</p><p>在数据结构课上学过链表的查找。最为简单的查找是顺序查找。从Infimum记录（最小记录）开始，知道招到链表，但是这种方式显而易见，效率很低。</p><p>因此InnoDB引入了页目录（Page Directory）机制，通过这个来简化查找。</p><ul><li>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。</li><li>每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该记录拥有多少条记录，也就是该组内共有几条记录。</li><li>将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方，这个地方就是所谓的Page Directory，也就是页目录（此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为槽（英文名：Slot），所以这个页面目录就是由槽组成的。</li></ul><p><img src="https://pic.liahnu.top/img/202307030109220.png"></p><p><img src="https://pic.liahnu.top/img/202307030111124.png"></p><p>其中，对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1<del>8 条之间，剩下的分组中记录的条数范围只能在是 4</del>8 条之间。</p><p>通过这样的分组方式，我们就可以通过二分查找的方式来快速定位到我们想要的记录所在的分组，然后再通过顺序查找组的方式快速定位到我们想要的记录。</p><h3 id="Page-Header（页面头部）"><a href="#Page-Header（页面头部）" class="headerlink" title="Page Header（页面头部）"></a>Page Header（页面头部）</h3><p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，它是页结构的第二部分，这个部分占用固定的56个字节，专门存储各种状态信息。</p><p><img src="https://pic.liahnu.top/img/202307030128384.png"></p><h3 id="File-Header（文件头部）"><a href="#File-Header（文件头部）" class="headerlink" title="File Header（文件头部）"></a>File Header（文件头部）</h3><p>File Header描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁之类的信息，这个部分占用固定的38个字节</p><p><img src="https://pic.liahnu.top/img/202307030130410.png"></p><h3 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h3><p>每个页的尾部都加了一个File Trailer部分，用来校验页信息，这个部分由8个字节组成，可以分成2个小部分：</p><ul><li>前4个字节代表页的校验和</li></ul><p>这个部分是和File Header中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在File Header中的校验和就代表着已经修改过的页，而在File Trailer中的校验和代表着原先的页，二者不同则意味着同步中间出了错。</p><ul><li>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）</li></ul><p>这个File Trailer与File Header类似，都是所有类型的页通用的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><p>InnoDB为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做数据页。</p></li><li><p>InnoDB会把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个槽，存放在Page Directory中，所以在一个页中根据主键查找记录是非常快的，分为两步：通过二分法确定该记录所在的槽；通过记录的next_record属性遍历该槽所在的组中的各个记录。</p></li><li><p>每个数据页的File Header部分都有上一个和下一个页的编号，所以所有的数据页会组成一个双链表。</p></li><li><p>为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的LSN值，如果首部和尾部的校验和和LSN值校验不成功的话，就说明同步过程出现了问题。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2023/05/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/05/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式的目的是帮助我们编写可复用的代码，提高代码的耦合性。降低对其他组件的修改</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/the-relationship-between-design-patterns.jpg"></p><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><p>通过构造一个迭代器来实现对元素的遍历操作</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在java中可以使用util中提供的<code>Iterator&lt;?&gt;</code>接口实现，主要为 hasnext与next方法，分别判断迭代器是否有下一个和获取下一个元素。</p><p>其实java中 拓展for使用使用了迭代器模式，c++中同样存在迭代器for遍历。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>引入迭代器后，可以使遍历与实现分离开，不暴露该对象的内部表示。</li></ol><h1 id="Adapter模式-（适配器模式）"><a href="#Adapter模式-（适配器模式）" class="headerlink" title="Adapter模式 （适配器模式）"></a>Adapter模式 （适配器模式）</h1><p>Adapter模式又称为Wrapper模式，其设计模式的目的是实现两个对象间的互相转换，主要有以下两种</p><ol><li>类适配器模式</li><li>对象适配器模式</li></ol><h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><p>类适配器模式是实现类与接口间实现对接的方式。通过中间类 Banner 类继承对象和实现接口的相关功能实现</p><p><img src="https://pic.liahnu.top/img/202305082019449.png"></p><h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><p>对象适配器模式是实现对类与类间实现对接的方式。由于java中只能单继承，通过中间类 Banner 类继承一个类和保存对象，实现对数据处理的转交。</p><p><img src="https://pic.liahnu.top/img/202305082020330.png"></p><h1 id="Template-Method-模式-（模板方式模式）"><a href="#Template-Method-模式-（模板方式模式）" class="headerlink" title="Template Method 模式 （模板方式模式）"></a>Template Method 模式 （模板方式模式）</h1>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成与设计-第二章-笔记</title>
    <link href="/2023/04/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/04/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="2-1-引言"><a href="#2-1-引言" class="headerlink" title="2.1 引言"></a>2.1 引言</h1><p>计算机语言中的单词称为<strong>指令</strong>，其词汇表称为<strong>指令系统</strong></p><h2 id="RISV-V-指令系统"><a href="#RISV-V-指令系统" class="headerlink" title="RISV-V 指令系统"></a>RISV-V 指令系统</h2><p><img src="https://pic.liahnu.top/img/202304280111811.png" alt="RISV-V 汇编语言 表一"></p><p><img src="https://pic.liahnu.top/img/202304280113631.png" alt="RISV-V 汇编语言 表二"></p><p><a href="http://riscvbook.com/chinese/RISC-V-Reader-Chinese-v2p1.pdf">做pa时候的risv32参考手册</a></p><h1 id="2-2-计算机硬件的操作"><a href="#2-2-计算机硬件的操作" class="headerlink" title="2.2 计算机硬件的操作"></a>2.2 计算机硬件的操作</h1><p>下面就是一个基础的risv指令，固定使用三个变量进行操作；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">add a, b, c<br></code></pre></td></tr></table></figure><p><strong>设计原则1 ：简单源于规整</strong></p><p>操作数数量可变的硬件比固定数拭的硬件更复杂。</p><p>riscv指令主要包含一下几几种指令</p><h1 id="2-3-计算机硬件的操作数"><a href="#2-3-计算机硬件的操作数" class="headerlink" title="2.3 计算机硬件的操作数"></a>2.3 计算机硬件的操作数</h1><p>在RISC-V 体系结构中，寄存器的大小为64 位；成组的64 位频繁出现，因此它们在RISC-V 体系结构中被命名为双字。（另一个常见大小是成组的32位，在RISC-V 体系结构中称为字。）</p><p>相较于变量，在RISC-V处理器中，寄存器数量优先，在当前RISC-V 等计算机上通常为32 个寄存器。</p><p><strong>设计原则2 ：更少则更快</strong></p><p>数量过多的寄存器可能会增加时钟周期，因为电信号传输的距离越远，所花<br>费的时间就越长。</p><h2 id="2-3-1-存储器操作数"><a href="#2-3-1-存储器操作数" class="headerlink" title="2.3.1 存储器操作数"></a>2.3.1 存储器操作数</h2><p>RISC-V 指令中的算术运算只作用于寄存器，因此，RISC-V 必须包含在内存和寄存器之间传输数据的指令。这些指令称为数据传输指令。</p><p>将数据从内存复制到寄存器的数据传输指令通常称为载入指令ld(load);<br>将数据从寄存器复制到内存的数据传输指令通常称为存储指令lw(store);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">ld x9, 8(x22) // 8(x22) 指相对于x22地址，有8个偏移<br><br></code></pre></td></tr></table></figure><p>计算机分为两种， 一种使用最左边或“ 大端”字节的地址作为双字地址，另一种使用最右端或“小端” 字节的地址作为双字地址。RISC-V 属于后者，称为小端编址。由于仅在以双字形式和八个单独字节访问相同数据时， 字节顺序才会有影响， 因此大多数情况下不需要关心”大小端”。</p><h2 id="2-3-2-常数或立即数操作数"><a href="#2-3-2-常数或立即数操作数" class="headerlink" title="2.3.2 常数或立即数操作数"></a>2.3.2 常数或立即数操作数</h2><p>程序经常会在一次操作中用到常数，下列是一些常数指令</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">addi <span class="hljs-keyword">x</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-keyword">x</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成与设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>南大 pa2</title>
    <link href="/2023/04/23/%E5%8D%97%E5%A4%A7-pa2/"/>
    <url>/2023/04/23/%E5%8D%97%E5%A4%A7-pa2/</url>
    
    <content type="html"><![CDATA[<h1 id="理解YEMU如何执行程序"><a href="#理解YEMU如何执行程序" class="headerlink" title="理解YEMU如何执行程序"></a>理解YEMU如何执行程序</h1><div class="note note-warning">            <p>YEMU可以看成是一个简化版的NEMU, 它们的原理是相通的, 因此你需要理解YEMU是如何执行程序的. 具体地, 你需要画出在YEMU上执行的加法程序的状态机<br>通过RTFSC理解YEMU如何执行一条指令<br>思考一下, 以上两者有什么联系?</p>          </div><p>YEMU执行指令通过 取值-&gt;译码-&gt;执行-&gt;更新pc操作. 首先从M(内存)中取出一条指令,通过操作码判断所属于的指令类型,然后读取指令内容并更新寄存器执行,最后更新pc指针+1，指向内存中的下1字节数据，通过while(true)指令来实现不断循环。</p><p>状态机不想画了（）</p><h1 id="RTFSC理解指令执行的过程"><a href="#RTFSC理解指令执行的过程" class="headerlink" title="RTFSC理解指令执行的过程"></a>RTFSC理解指令执行的过程</h1><div class="note note-warning">            <p>这一小节的细节非常多, 你可能需要多次阅读讲义和代码才能理解每一处细节. 根据往届学长学姐的反馈, 一种有效的理解方法是通过做笔记的方式来整理这些细节. 事实上, 配合GDB食用效果更佳.</p><p>为了避免你长时间对代码的理解没有任何进展, 我们就增加一道必答题吧:</p><p>请整理一条指令在NEMU中的执行过程.</p><p>除了nemu&#x2F;src&#x2F;device和nemu&#x2F;src&#x2F;isa&#x2F;$ISA&#x2F;system之外, NEMU的其它代码你都已经有能力理解了. 因此不要觉得讲义中没有提到的文件就不需要看, 尝试尽可能地理解每一处细节吧! 在你遇到bug的时候, 这些细节就会成为帮助你调试的线索.</p>          </div><p>指令执行过程类似于YEMU。首先NEMU从内存中读取一条指令数据，然后对对指令中的操作码和操作数依次进行译码。在指令译码阶段结束后，NEMU会执行代码，运用rtl语句，从而完成指令语义层面上的逻辑行为。最后，只需把下一条动态PC赋值给PC即可完成一次指令执行循环。</p><h1 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h1><p>在运行navtic时候报错<br>error: variably modified ‘sigstack’ at file scope</p><p>这个原因是因为版本库更新，数组中的数字不再是常量。</p><p><a href="https://stackoverflow.com/questions/69719688/buildroot-error-when-building-with-ubuntu-21-10/69722830#69722830">https://stackoverflow.com/questions/69719688/buildroot-error-when-building-with-ubuntu-21-10/69722830#69722830</a></p><p>解决方法，手动改为8192</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint8_t</span> sigstack[<span class="hljs-number">8192</span>];<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>校园内vpn模拟登录</title>
    <link href="/2023/04/23/%E6%A0%A1%E5%9B%AD%E5%86%85vpn%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/"/>
    <url>/2023/04/23/%E6%A0%A1%E5%9B%AD%E5%86%85vpn%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用学校webvpn时候，访问内网地址被加密为一串字符串，</p><p>例如：<a href="https://webvpn.gdou.edu.cn/http/77726476706e69737468656265737421a1a70fce77602606305adcf9/">https://webvpn.gdou.edu.cn/http/77726476706e69737468656265737421a1a70fce77602606305adcf9/</a></p><h1 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h1><p>通过前端js代码，可以很清楚的找到加密函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> textRightAppend = <span class="hljs-keyword">function</span> (<span class="hljs-params">text, mode</span>) &#123;<br>    <span class="hljs-keyword">var</span> segmentByteSize = mode === <span class="hljs-string">&#x27;utf8&#x27;</span> ? <span class="hljs-number">16</span> : <span class="hljs-number">32</span><br><br>    <span class="hljs-keyword">if</span> (text.<span class="hljs-property">length</span> % segmentByteSize === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> text<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> appendLength = segmentByteSize - text.<span class="hljs-property">length</span> % segmentByteSize<br>    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> (i++ &lt; appendLength) &#123;<br>        text += <span class="hljs-string">&#x27;0&#x27;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> text<br>&#125;<br><br><span class="hljs-keyword">var</span> encrypt = <span class="hljs-keyword">function</span> (<span class="hljs-params">text, key, iv</span>) &#123;<br>    <span class="hljs-keyword">var</span> textLength = text.<span class="hljs-property">length</span><br>    text = <span class="hljs-title function_">textRightAppend</span>(text, <span class="hljs-string">&#x27;utf8&#x27;</span>)<br>    <span class="hljs-keyword">var</span> keyBytes = utf8.<span class="hljs-title function_">toBytes</span>(key)<br>    <span class="hljs-keyword">var</span> ivBytes = utf8.<span class="hljs-title function_">toBytes</span>(iv)<br>    <span class="hljs-keyword">var</span> textBytes = utf8.<span class="hljs-title function_">toBytes</span>(text)<br>    <span class="hljs-keyword">var</span> aesCfb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AesCfb</span>(keyBytes, ivBytes, <span class="hljs-number">16</span>)<br>    <span class="hljs-keyword">var</span> encryptBytes = aesCfb.<span class="hljs-title function_">encrypt</span>(textBytes)<br>    <span class="hljs-keyword">return</span> hex.<span class="hljs-title function_">fromBytes</span>(ivBytes) + hex.<span class="hljs-title function_">fromBytes</span>(encryptBytes).<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, textLength * <span class="hljs-number">2</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 key &#x3D; “wrdvpnisthebest!” iv &#x3D; “wrdvpnisthebest!” 默认参数</p><p>加密方式根据函数猜测为Aes加密，模式为cfb方式</p>]]></content>
    
    
    
    <tags>
      
      <tag>协议分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github page 自动部署服务器</title>
    <link href="/2023/04/22/github-page-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2023/04/22/github-page-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>这个博客是同时部署在<a href="https://1328411791.github.io/">github page</a> 和 <a href="https://www.liahnu.top/">我自己的服务器</a>上，通常在更新博客内容时，会产生数据同步问题。即使用<code>hexo d</code>指令后，上传到 Github page 仓库，不同时更新自己服务器上的内容。在更新完成仓库后，需要手动登录服务器进行拉取仓库。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>首先，在上传到github仓库时，所产生的网页文件已经是被打包好的了，因此在部署到服务器只需要拉取仓库。因此，可以使用github中Webhooks功能来拉取更新时候的代码。</p><h2 id="Webhooks是什么"><a href="#Webhooks是什么" class="headerlink" title="Webhooks是什么"></a>Webhooks是什么</h2><p>Webhook 允许在某些事件发生时通知外部服务。当指定的事件发生时，我们将向您提供的每个 URL 发送一个 POST 请求。</p><h2 id="启动github-webhook"><a href="#启动github-webhook" class="headerlink" title="启动github webhook"></a>启动github webhook</h2><p>在github的设置页设置webhook参数</p><p><img src="https://pic.liahnu.top/img/202304221908717.png"></p><h2 id="编写sh脚本处理post请求"><a href="#编写sh脚本处理post请求" class="headerlink" title="编写sh脚本处理post请求"></a>编写sh脚本处理post请求</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># 启动 HTTP 监听服务</span><br>nc -l 7000 | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line<br><span class="hljs-keyword">do</span><br>    <span class="hljs-comment"># 检查是否为 POST 请求</span><br>    <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$line</span>&quot;</span> == <span class="hljs-string">&quot;POST&quot;</span>* ]]<br>    <span class="hljs-keyword">then</span><br>        <span class="hljs-comment"># 返回 OK 响应</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;HTTP/1.1 200 OK&quot;</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Content-Length: 2&quot;</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;ok&quot;</span><br>    <br>        <span class="hljs-comment"># 执行 git pull 操作</span><br>        <span class="hljs-built_in">cd</span> /www/hexo/1328411791.GitHub.io/<br>        git pull origin<br><br><br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>这段代码这有基础的功能，没有对请求进行验证，同时也没有http返回状态和参数（shell不如py）</p><p>shell真不如py写脚本，下面是python的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> git<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/update&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>():<br>    <span class="hljs-comment"># github hook 辨别</span><br>    <span class="hljs-keyword">if</span>(request.headers.get(<span class="hljs-string">&#x27;X-GitHub-Hook-ID&#x27;</span>) != <span class="hljs-string">&quot;11&quot;</span>):<br>        <span class="hljs-keyword">return</span> json.dumps(&#123;<span class="hljs-string">&#x27;msg&#x27;</span>: <span class="hljs-string">&#x27;Not a valid github hook&#x27;</span>&#125;)<br>    repo = git.Repo(<span class="hljs-string">&#x27;/path/to/repo&#x27;</span>)<br>    <span class="hljs-comment"># 更新本地仓库</span><br>    origin = repo.remotes.origin<br>    <span class="hljs-comment"># 删除本地仓库</span><br>    repo.git.reset(<span class="hljs-string">&#x27;--hard&#x27;</span>)<br>    <span class="hljs-comment"># 拉取远程仓库内容到本地仓库</span><br>    origin.pull(<span class="hljs-string">&quot;master&quot;</span>)<br>    <span class="hljs-comment"># 输出更新日志  </span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Updated PythonAnywhere source to commit &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">str</span>(repo.head.commit))) <br>    ret = &#123;<span class="hljs-string">&#x27;msg&#x27;</span>: <span class="hljs-string">&#x27;Updated PythonAnywhere source to commit &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">str</span>(repo.head.commit))&#125;<br>    <span class="hljs-keyword">return</span> ret<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run(host= <span class="hljs-string">&#x27;0.0.0.0&#x27;</span>,port= <span class="hljs-number">4000</span>, debug=<span class="hljs-literal">True</span>)<br><br></code></pre></td></tr></table></figure><p>安装对应的依赖，代码仅供参考</p><p>写完后,发送测试请求，发现成功被接收</p><p><img src="https://pic.liahnu.top/img/202304221909827.png"></p><p>下面将脚本进行后台运行即可</p><p>nohup 命令可以用来处理脚本后台运行，将输出重定向到log文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> ./update.sh &gt; ./log 2&gt;&amp;1 &amp; <br></code></pre></td></tr></table></figure><p>查看log 发现代码被正确拉取</p><p><img src="https://pic.liahnu.top/img/202304221912578.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>博客，部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线段树入门</title>
    <link href="/2023/03/28/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/"/>
    <url>/2023/03/28/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。</p><p>线段树是中常用的用来维护区间信息的数据结构。对于其每一个子节点而言，都表示整个序列中的一段子区间；对于每个叶子节点而言，都表示序列中的单个元素信息；子节点不断向自己的父亲节点传递信息，而父节点存储的信息则是他的每一个子节点信息的整合。</p><h2 id="线段树的基本形态"><a href="#线段树的基本形态" class="headerlink" title="线段树的基本形态"></a>线段树的基本形态</h2><p>线段树每个区间所管理的关系图<br><img src="https://pic.liahnu.top/img/202303290823030.png" alt="线段树关系图"></p><h2 id="线段树的构建"><a href="#线段树的构建" class="headerlink" title="线段树的构建"></a>线段树的构建</h2><p>我们可以通过递归的方式构建出一棵二叉树。参考代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-comment">// 对 [s,t] 区间建立线段树,当前根的编号为 p</span><br>  <span class="hljs-keyword">if</span> (s == t) &#123; <br>    <span class="hljs-comment">// s==t时候，说明为叶子节点</span><br>    d[p] = a[s];<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 去s-t的中点分割</span><br>  <span class="hljs-comment">// 移位运算符的优先级小于加减法，所以加上括号</span><br>  <span class="hljs-comment">// 如果写成 (s + t) &gt;&gt; 1 可能会超出 int 范围</span><br>  <span class="hljs-built_in">build</span>(s, m, p * <span class="hljs-number">2</span>), <span class="hljs-built_in">build</span>(m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 递归对左右区间建树</span><br>  d[p] = d[p * <span class="hljs-number">2</span>] + d[(p * <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线段树的区间查询"><a href="#线段树的区间查询" class="headerlink" title="线段树的区间查询"></a>线段树的区间查询</h2><p>再回到开头的图，你会发现，查询[1,10]之间的节点，只需要查询其根节点的值即可。</p><p>如果要查询的区间为 [3,5]，此时就不能直接获取区间的值，但是 [3,5] 可以拆成 [3,3] 和 [4,5]，可以通过合并这两个区间的答案来求得这个区间的答案。</p><p><img src="https://pic.liahnu.top/img/202303290823030.png" alt="线段树关系图"></p><p>参考代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-comment">// [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号</span><br>  <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r)<br>    <span class="hljs-keyword">return</span> d[p];  <span class="hljs-comment">// 当前区间为询问区间的子集时直接返回当前区间的和</span><br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>), sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (l &lt;= m) sum += <span class="hljs-built_in">getsum</span>(l, r, s, m, p * <span class="hljs-number">2</span>);<br>  <span class="hljs-comment">// 如果左儿子代表的区间 [s, m] 与询问区间有交集, 则递归查询左儿子</span><br>  <span class="hljs-keyword">if</span> (r &gt; m) sum += <span class="hljs-built_in">getsum</span>(l, r, m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 如果右儿子代表的区间 [m + 1, t] 与询问区间有交集, 则递归查询右儿子</span><br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线段树的区间修改与懒惰标记"><a href="#线段树的区间修改与懒惰标记" class="headerlink" title="线段树的区间修改与懒惰标记"></a>线段树的区间修改与懒惰标记</h2><p>如果要求修改区间 [l,r]，把所有包含在区间 [l,r] 中的节点都遍历一次、修改一次，时间复杂度无法承受。我们这里引入做 「懒惰标记」。通过延迟对节点信息的更改，从而减少可能不必要的操作次数。每次执行修改时，我们通过打标记的方法表明该节点对应的区间在某一次操作中被更改，但不更新该节点的子节点的信息。实质性的修改则在下一次访问带有标记的节点时才进行。</p><p><strong>区间修改</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-comment">// [l, r] 为修改区间, c 为被修改的元素的变化量, [s, t] 为当前节点包含的区间, p</span><br>  <span class="hljs-comment">// 为当前节点的编号</span><br>  <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) &#123;<br>    <span class="hljs-comment">// 区间内有几个在范围内的点*val值</span><br>    d[p] += (t - s + <span class="hljs-number">1</span>) * c, b[p] += c;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;  <span class="hljs-comment">// 当前区间为修改区间的子集时直接修改当前节点的值,然后打标记,结束修改</span><br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (b[p] &amp;&amp; s != t) &#123;<br>    <span class="hljs-comment">// 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值</span><br>    d[p * <span class="hljs-number">2</span>] += b[p] * (m - s + <span class="hljs-number">1</span>), d[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += b[p] * (t - m);<br>    b[p * <span class="hljs-number">2</span>] += b[p], b[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += b[p];  <span class="hljs-comment">// 将标记下传给子节点</span><br>    b[p] = <span class="hljs-number">0</span>;                                <span class="hljs-comment">// 清空当前节点的标记</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (l &lt;= m) <span class="hljs-built_in">update</span>(l, r, c, s, m, p * <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">if</span> (r &gt; m) <span class="hljs-built_in">update</span>(l, r, c, m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>  d[p] = d[p * <span class="hljs-number">2</span>] + d[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>区间查询</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-comment">// [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号</span><br>  <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) <span class="hljs-keyword">return</span> d[p];<br>  <span class="hljs-comment">// 当前区间为询问区间的子集时直接返回当前区间的和</span><br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (b[p]) &#123;<br>    <span class="hljs-comment">// 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值</span><br>    d[p * <span class="hljs-number">2</span>] += b[p] * (m - s + <span class="hljs-number">1</span>), d[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += b[p] * (t - m);<br>    b[p * <span class="hljs-number">2</span>] += b[p], b[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += b[p];  <span class="hljs-comment">// 将标记下传给子节点</span><br>    b[p] = <span class="hljs-number">0</span>;                                <span class="hljs-comment">// 清空当前节点的标记</span><br>  &#125;<br>  <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (l &lt;= m) sum = <span class="hljs-built_in">getsum</span>(l, r, s, m, p * <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">if</span> (r &gt; m) sum += <span class="hljs-built_in">getsum</span>(l, r, m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一些优化"><a href="#一些优化" class="headerlink" title="一些优化"></a>一些优化</h2><p>一些优化<br>这里总结几个线段树的优化：</p><ol><li><p>在叶子节点处无需下放懒惰标记，所以懒惰标记可以不下传到叶子节点。</p></li><li><p>下放懒惰标记可以写一个专门的函数 pushdown，从儿子节点更新当前节点也可以写一个专门的函数 maintain（或者对称地用 pushup），降低代码编写难度。</p></li><li><p>标记永久化：如果确定懒惰标记不会在中途被加到溢出（即超过了该类型数据所能表示的最大范围），那么就可以将标记永久化。标记永久化可以避免下传懒惰标记，只需在进行询问时把标记的影响加到答案当中，从而降低程序常数。具体如何处理与题目特性相关，需结合题目来写。这也是树套树和可持久化数据结构中会用到的一种技巧。</p></li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P3372">https://www.luogu.com.cn/problem/P3372</a></p><p>具体来说就是在线段树上完成一下操作</p><ol><li>将某区间每一个数加上k。</li><li>求出某区间每一个数的和。</li></ol><p>使用模板的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SegTreeLazyRangeAdd</span><br>&#123;<br>    vector&lt;T&gt; tree, lazy;<br>    vector&lt;T&gt; *arr;<br>    <span class="hljs-type">int</span> n, root, n4, end;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maintain</span><span class="hljs-params">(<span class="hljs-type">int</span> cl, <span class="hljs-type">int</span> cr, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> cm = cl + (cr - cl) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (cl != cr &amp;&amp; lazy[p])<br>        &#123;<br>            lazy[p * <span class="hljs-number">2</span>] += lazy[p];<br>            lazy[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += lazy[p];<br>            tree[p * <span class="hljs-number">2</span>] += lazy[p] * (cm - cl + <span class="hljs-number">1</span>);<br>            tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += lazy[p] * (cr - cm);<br>            lazy[p] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">range_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> cl, <span class="hljs-type">int</span> cr, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r)<br>            <span class="hljs-keyword">return</span> tree[p];<br>        <span class="hljs-type">int</span> m = cl + (cr - cl) / <span class="hljs-number">2</span>;<br>        T sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">maintain</span>(cl, cr, p);<br>        <span class="hljs-keyword">if</span> (l &lt;= m)<br>            sum += <span class="hljs-built_in">range_sum</span>(l, r, cl, m, p * <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (r &gt; m)<br>            sum += <span class="hljs-built_in">range_sum</span>(l, r, m + <span class="hljs-number">1</span>, cr, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">range_add</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, T val, <span class="hljs-type">int</span> cl, <span class="hljs-type">int</span> cr, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r)<br>        &#123;<br>            lazy[p] += val;<br>            tree[p] += (cr - cl + <span class="hljs-number">1</span>) * val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> m = cl + (cr - cl) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">maintain</span>(cl, cr, p);<br>        <span class="hljs-keyword">if</span> (l &lt;= m)<br>            <span class="hljs-built_in">range_add</span>(l, r, val, cl, m, p * <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (r &gt; m)<br>            <span class="hljs-built_in">range_add</span>(l, r, val, m + <span class="hljs-number">1</span>, cr, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        tree[p] = tree[p * <span class="hljs-number">2</span>] + tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (s == t)<br>        &#123;<br>            tree[p] = (*arr)[s];<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> m = s + (t - s) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">build</span>(s, m, p * <span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">build</span>(m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        tree[p] = tree[p * <span class="hljs-number">2</span>] + tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">explicit</span> <span class="hljs-built_in">SegTreeLazyRangeAdd</span>&lt;T&gt;(vector&lt;T&gt; v)<br>    &#123;<br>        n = v.<span class="hljs-built_in">size</span>();<br>        n4 = n * <span class="hljs-number">4</span>;<br>        tree = <span class="hljs-built_in">vector</span>&lt;T&gt;(n4, <span class="hljs-number">0</span>);<br>        lazy = <span class="hljs-built_in">vector</span>&lt;T&gt;(n4, <span class="hljs-number">0</span>);<br>        arr = &amp;v;<br>        end = n - <span class="hljs-number">1</span>;<br>        root = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">build</span>(<span class="hljs-number">0</span>, end, <span class="hljs-number">1</span>);<br>        arr = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (p &gt; n4 || tree[p] == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">show</span>(p * <span class="hljs-number">2</span>, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; depth; ++i)<br>            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\t&#x27;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d:%d\n&quot;</span>, tree[p], lazy[p]);<br>        <span class="hljs-built_in">show</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, depth + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">range_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">range_sum</span>(l, r, <span class="hljs-number">0</span>, end, root); &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">range_add</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> val)</span> </span>&#123; <span class="hljs-built_in">range_add</span>(l, r, val, <span class="hljs-number">0</span>, end, root); &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ll n, m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);<br>    vector&lt;ll&gt; ans;<br>    ll x;<br>    <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;x);<br>        ans.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>    <span class="hljs-function">SegTreeLazyRangeAdd&lt;ll&gt; <span class="hljs-title">st</span><span class="hljs-params">(ans)</span></span>;<br>    <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        ll op;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;op);<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>)<br>        &#123;<br>            ll x, y, k;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;x, &amp;y, &amp;k);<br>            st.<span class="hljs-built_in">range_add</span>(x - <span class="hljs-number">1</span>, y - <span class="hljs-number">1</span>, k);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ll x, y;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld %lld&quot;</span>, &amp;x, &amp;y);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, st.<span class="hljs-built_in">range_sum</span>(x - <span class="hljs-number">1</span>, y - <span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>srun网络协议分析</title>
    <link href="/2023/03/08/srun%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"/>
    <url>/2023/03/08/srun%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>校园网最近更新，登录方式改用深澜网络协议进行登录。本文根据登录时数据包，对深澜网络协议进行分析。</p><h1 id="请求分析"><a href="#请求分析" class="headerlink" title="请求分析"></a>请求分析</h1><h2 id="获取api请求"><a href="#获取api请求" class="headerlink" title="获取api请求"></a>获取api请求</h2><p>使用抓包软件对srun协议登录请求进行抓包</p><p>登录操作时候主要使用了以下几个请求</p><p><code>GET /cgi-bin/get_challenge?callback=jQuery1124038630846526307305_1678337618278&amp;username=2021440113**&amp;ip=10.202.47.26&amp;_=1678337618280 </code></p><p><img src="https://pic.liahnu.top/img/202303091302292.png"></p><p><code>GET /cgi-bin/srun_portal?callback=jQuery1124038630846526307305_1678337618278&amp;action=login&amp;username=2021440113**&amp;password=%7BMD5%7D01d38ef19265ae9ff199cbafc98e6797&amp;os=Windows+95&amp;name=Windows&amp;double_stack=0&amp; chksum=ffbaed27a7cbf48bcf7c227beae802def6f96901&amp;info=%7BSRBX1%7DQJl6uFy9IkM3%2FI3HaaNP%2FgPkfZWn%2FLUH3ktAZuPhtrF%2BailDbmoRB7oaw4jfeE%2FKR9hTkSoyJ5de6TXw6IpyX8VGiLpiWy6MLBEfu4RdCyg2WSim%2FmIssMlh9cfzJygmNCSiFDNbWiE6uBnn&amp;ac_id=1&amp;ip=10.202.47.26&amp;n=200&amp;type=1&amp;_=1678337618281 </code></p><p><img src="https://pic.liahnu.top/img/202303091534989.png"></p><p>下面具体根据两个请求进行分析</p><h2 id="get-challenge-请求"><a href="#get-challenge-请求" class="headerlink" title="get_challenge 请求"></a>get_challenge 请求</h2><p>根据请求，我们可以初步猜测出这个的参数</p><table><thead><tr><th align="center">参数</th><th align="center">示例值</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">callback</td><td align="center">jQuery1124038630846526307305_1678337618278</td><td align="center">应该是jquery的回调函数标志，可能由函数id+时间戳组成</td></tr><tr><td align="center">username</td><td align="center">2021440113**</td><td align="center">登录用户名</td></tr><tr><td align="center">ip</td><td align="center">10.202.47.26</td><td align="center">登录网站源站ip</td></tr><tr><td align="center">_</td><td align="center">1678337618280</td><td align="center">很明显是当前的时间戳</td></tr></tbody></table><h2 id="srun-portal-请求"><a href="#srun-portal-请求" class="headerlink" title="srun_portal 请求"></a>srun_portal 请求</h2><p>同样根据请求，我们可以初步猜测出这个请求的参数详情</p><table><thead><tr><th align="center">参数</th><th align="center">示例值</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">callback</td><td align="center">jQuery1124038630846526307305_1678337618278</td><td align="center">应该是jquery的回调函数标志，可能由函数id+时间戳组成</td></tr><tr><td align="center">password</td><td align="center">{MD5}01d38ef19265ae9ff199cbafc98e6797</td><td align="center">经过md5加密后的密码，但似乎不同于常规md5加密方法</td></tr><tr><td align="center">os</td><td align="center">Windows+95</td><td align="center">系统</td></tr><tr><td align="center">name</td><td align="center">Windows</td><td align="center">同上，系统参数</td></tr><tr><td align="center">double_stack</td><td align="center">0</td><td align="center">多次抓包后似乎是固定值，查询后应该是ipv4和ipv6双栈登录选项</td></tr><tr><td align="center">chksum</td><td align="center">ffbaed27a7cbf48bcf7c227beae802def6f96901</td><td align="center">某种加密后的参数</td></tr><tr><td align="center">info</td><td align="center">{SRBX1}QJl6uFy9IkM3%2FI3HaaNP%2FgPkfZWn%2FLUH3ktAZuPht rF%2BailDbmoRB7oaw4jfeE%2FKR9hTkSoyJ5de6TXw6Ipy X8VGiLpiWy6MLBEfu4RdCyg2WSim%2FmIssMlh9cfzJygmN CSiFDNbWiE6uBnn</td><td align="center">又是一段加密后的参数</td></tr><tr><td align="center">ac_id</td><td align="center">118</td><td align="center">固定值，可能是加密方式，错误的ac_id可能会导致bas错误</td></tr><tr><td align="center">n</td><td align="center">200</td><td align="center">固定值</td></tr><tr><td align="center">type</td><td align="center">1</td><td align="center">固定值</td></tr><tr><td align="center">_</td><td align="center">1678337618280</td><td align="center">很明显是当前的时间戳</td></tr></tbody></table><p>根据上面的基础分析，初步可以知道我们需要研究参数为 password，chksum，info字段</p><h2 id="js分析"><a href="#js分析" class="headerlink" title="js分析"></a>js分析</h2><p>根据上面的基础分析，在js的代码中寻找关键的代码信息</p><p>以下是寻找的相关代码(省略部分细节)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;#login-account&#x27;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> username = $(<span class="hljs-string">&#x27;#username&#x27;</span>).<span class="hljs-title function_">val</span>().<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/ /g</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>        <span class="hljs-keyword">var</span> password = $(<span class="hljs-string">&#x27;#password&#x27;</span>).<span class="hljs-title function_">val</span>();<br>        <span class="hljs-comment">// 若页面不存在 domain，则 domain 为空</span><br>        <span class="hljs-keyword">var</span> domain   = $(<span class="hljs-string">&#x27;#domain&#x27;</span>).<span class="hljs-title function_">val</span>();<br><br>        <span class="hljs-comment">// 写入用户信息</span><br>        portal.<span class="hljs-property">userInfo</span>.<span class="hljs-property">username</span> = username;<br>        portal.<span class="hljs-property">userInfo</span>.<span class="hljs-property">password</span> = password;<br>        portal.<span class="hljs-property">userInfo</span>.<span class="hljs-property">domain</span>   = domain || <span class="hljs-string">&#x27;&#x27;</span>;<br><br>        <span class="hljs-comment">// Portal 认证方法</span><br>        portal.<span class="hljs-title function_">login</span>(&#123;<br>            <span class="hljs-comment">// 认证方式为账号认证</span><br>            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;account&#x27;</span>,<br>            <span class="hljs-comment">// 认证成功</span><br>            <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-comment">// 若勾选记住密码</span><br>                <span class="hljs-keyword">if</span> ($(<span class="hljs-string">&#x27;#remember&#x27;</span>).<span class="hljs-title function_">prop</span>(<span class="hljs-string">&#x27;checked&#x27;</span>))  portal.<span class="hljs-title function_">remember</span>(<span class="hljs-literal">true</span>);<br>                <span class="hljs-comment">// 若未勾选记住密码 或 不存在记住密码功能</span><br>                <span class="hljs-keyword">if</span> (!$(<span class="hljs-string">&#x27;#remember&#x27;</span>).<span class="hljs-title function_">prop</span>(<span class="hljs-string">&#x27;checked&#x27;</span>)) portal.<span class="hljs-title function_">remember</span>(<span class="hljs-literal">false</span>);<br>                <span class="hljs-comment">// 重定向至成功页</span><br>                portal.<span class="hljs-title function_">toSuccess</span>();<br>            &#125;<br>        &#125;);<br>    &#125;);<br></code></pre></td></tr></table></figure><p>登录调用了portal.login() 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;login&quot;</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">login</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">var</span> obj = <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] !== <span class="hljs-literal">undefined</span> ? <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] : &#123;&#125;;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setLog</span>(<span class="hljs-string">&#x27;正在进行登陆操作&#x27;</span>); <span class="hljs-comment">// 默认进行拦截</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">loading</span>.<span class="hljs-property">login</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 账号认证</span><br><br>      <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;account&#x27;</span>) <span class="hljs-title function_">_classPrivateFieldGet</span>(<span class="hljs-variable language_">this</span>, _loginAccount).<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, obj); <span class="hljs-comment">// 短信认证 - 手机短信</span><br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>接着调用了 this._loginAccount()方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> sendAuth = <span class="hljs-keyword">function</span> <span class="hljs-title function_">sendAuth</span>(<span class="hljs-params">host</span>) &#123;<br>          <span class="hljs-comment">// 双栈认证时 IP 参数为空</span><br>          <span class="hljs-keyword">var</span> ip = _this.<span class="hljs-property">portalInfo</span>.<span class="hljs-property">doub</span> &amp;&amp; host ? <span class="hljs-string">&#x27;&#x27;</span> : _this.<span class="hljs-property">userInfo</span>.<span class="hljs-property">ip</span>; <span class="hljs-comment">// 获取 Token</span><br><br>          <span class="hljs-title function_">_classPrivateFieldGet</span>(<span class="hljs-title function_">_assertThisInitialized</span>(_this), _getToken).<span class="hljs-title function_">call</span>(<span class="hljs-title function_">_assertThisInitialized</span>(_this), host, ip, <span class="hljs-keyword">function</span> (<span class="hljs-params">token</span>) &#123;<br>            <span class="hljs-comment">// 用户密码 MD5 加密</span><br>            <span class="hljs-keyword">var</span> hmd5 = <span class="hljs-title function_">md5</span>(password, token); <span class="hljs-comment">// 用户信息加密</span><br><br>            <span class="hljs-keyword">var</span> i = <span class="hljs-title function_">_classPrivateFieldGet</span>(<span class="hljs-title function_">_assertThisInitialized</span>(_this), _encodeUserInfo).<span class="hljs-title function_">call</span>(<span class="hljs-title function_">_assertThisInitialized</span>(_this), &#123;<br>              <span class="hljs-attr">username</span>: username,<br>              <span class="hljs-attr">password</span>: password,<br>              <span class="hljs-attr">ip</span>: ip,<br>              <span class="hljs-attr">acid</span>: ac_id,<br>              <span class="hljs-attr">enc_ver</span>: enc<br>            &#125;, token);<br><br>            <span class="hljs-keyword">var</span> str = token + username;<br>            str += token + hmd5;<br>            str += token + ac_id;<br>            str += token + ip;<br>            str += token + n;<br>            str += token + type;<br>            str += token + i; <span class="hljs-comment">// 防止 IPv6 请求网络不通进行 try catch</span><br><br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">// 发起认证请求</span><br>              _this.<span class="hljs-property">ajax</span>.<span class="hljs-title function_">jsonp</span>(&#123;<br>                <span class="hljs-attr">host</span>: host,<br>                <span class="hljs-attr">url</span>: <span class="hljs-title function_">_classPrivateFieldGet</span>(<span class="hljs-title function_">_assertThisInitialized</span>(_this), _api).<span class="hljs-property">auth</span>,<br>                <span class="hljs-attr">params</span>: &#123;<br>                  <span class="hljs-attr">action</span>: <span class="hljs-string">&#x27;login&#x27;</span>,<br>                  <span class="hljs-attr">username</span>: username,<br>                  <span class="hljs-attr">password</span>: _this.<span class="hljs-property">userInfo</span>.<span class="hljs-property">otp</span> ? <span class="hljs-string">&#x27;&#123;OTP&#125;&#x27;</span> + password : <span class="hljs-string">&#x27;&#123;MD5&#125;&#x27;</span> + hmd5,<br>                  <span class="hljs-attr">os</span>: _this.<span class="hljs-property">portalInfo</span>.<span class="hljs-property">userDevice</span>.<span class="hljs-property">device</span>,<br>                  <span class="hljs-attr">name</span>: _this.<span class="hljs-property">portalInfo</span>.<span class="hljs-property">userDevice</span>.<span class="hljs-property">platform</span>,<br>                  <span class="hljs-comment">// 未开启双栈认证，参数为 0</span><br>                  <span class="hljs-comment">// 开启双栈认证，向 Portal 当前页面 IP 认证时，参数为 1</span><br>                  <span class="hljs-comment">// 开启双栈认证，向 Portal 另外一种 IP 认证时，参数为 0</span><br>                  <span class="hljs-attr">double_stack</span>: _this.<span class="hljs-property">portalInfo</span>.<span class="hljs-property">doub</span> &amp;&amp; !host ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>,<br>                  <span class="hljs-attr">chksum</span>: <span class="hljs-title function_">sha1</span>(str),<br>                  <span class="hljs-attr">info</span>: i,<br>                  <span class="hljs-attr">ac_id</span>: ac_id,<br>                  <span class="hljs-attr">ip</span>: ip,<br>                  <span class="hljs-attr">n</span>: n,<br>                  <span class="hljs-attr">type</span>: type<br>                &#125;,<br>                <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">success</span>(<span class="hljs-params">res</span>) &#123;<br>                  finishReq += <span class="hljs-number">1</span>; <span class="hljs-comment">// IP 已经在线了 - 给出提示</span><br><br>                  <span class="hljs-keyword">if</span> (res.<span class="hljs-property">suc_msg</span> === <span class="hljs-string">&#x27;ip_already_online_error&#x27;</span> &amp;&amp; obj.<span class="hljs-property">error</span>) <span class="hljs-keyword">return</span> _this.<span class="hljs-title function_">confirm</span>(&#123;<br>                    <span class="hljs-attr">message</span>: _this.<span class="hljs-title function_">translate</span>(<span class="hljs-string">&#x27;ip_already_online_error&#x27;</span>),<br>                    <span class="hljs-attr">confirm</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">confirm</span>(<span class="hljs-params"></span>) &#123;<br>                      <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">error</span>) obj.<span class="hljs-title function_">error</span>();<br>                    &#125;<br>                  &#125;); <span class="hljs-comment">// 翻译后的认证成功信息</span><br><br>                  successMsg = _this.<span class="hljs-title function_">translate</span>(res);<br>                &#125;,<br>                <span class="hljs-comment">/* 常见错误代码 */</span><br>                <span class="hljs-attr">error</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">error</span>(<span class="hljs-params">res</span>) &#123;<br>                  finishReq += <span class="hljs-number">1</span>; <span class="hljs-comment">// 更改登录状态为结束</span><br><br>                  _this.<span class="hljs-property">loading</span>.<span class="hljs-property">login</span> = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 若所有请求均已完成</span><br><br>                  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">noPending</span>()) <span class="hljs-title function_">authClose</span>(); <span class="hljs-comment">// 若 ecode 为 E2620 且开启了在线设备管理功能</span><br>                  <span class="hljs-comment">// E2620: 超出允许的在线数目</span><br><br>                  <span class="hljs-keyword">if</span> (res.<span class="hljs-property">ecode</span> === <span class="hljs-string">&#x27;E2620&#x27;</span> &amp;&amp; <span class="hljs-variable constant_">CREATER</span>.<span class="hljs-property">useOnlineDeviceMgr</span>) <span class="hljs-keyword">return</span> _this.<span class="hljs-title function_">confirm</span>(&#123;<br>                    <span class="hljs-attr">message</span>: _this.<span class="hljs-title function_">translate</span>(<span class="hljs-string">&#x27;E2620Tips&#x27;</span>),<br>                    <span class="hljs-attr">confirm</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">confirm</span>(<span class="hljs-params"></span>) &#123;<br>                      _this.<span class="hljs-property">dialog</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;onlineDeviceMgr&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>                        _this.<span class="hljs-title function_">getOnlineDevice</span>();<br>                      &#125;);<br>                    &#125;<br>                  &#125;); <span class="hljs-comment">// IP 已经在线了 - 重新认证</span><br><br>                  <span class="hljs-keyword">if</span> (res.<span class="hljs-property">error_msg</span> === <span class="hljs-string">&#x27;ip_already_online_error&#x27;</span>) <span class="hljs-keyword">return</span> _this.<span class="hljs-title function_">reAuth</span>(obj); <span class="hljs-comment">// 需要查询日志的情况</span><br><br>                  <span class="hljs-keyword">if</span> (res.<span class="hljs-property">error_msg</span> === <span class="hljs-string">&#x27;not_online_error&#x27;</span>) <span class="hljs-keyword">return</span> _this.<span class="hljs-title function_">showLog</span>();<br>                  <span class="hljs-keyword">if</span> (res.<span class="hljs-property">error_msg</span> === <span class="hljs-string">&#x27;no_response_data_error&#x27;</span>) <span class="hljs-keyword">return</span> _this.<span class="hljs-title function_">showLog</span>();<br>                  <span class="hljs-keyword">if</span> (res.<span class="hljs-property">error_msg</span> === <span class="hljs-string">&#x27;RD000&#x27;</span>) <span class="hljs-keyword">return</span> _this.<span class="hljs-title function_">showLog</span>(); <span class="hljs-comment">// 若提示修改密码</span><br><br>                  <span class="hljs-keyword">if</span> (res.<span class="hljs-property">error_msg</span> === <span class="hljs-string">&#x27;user_must_modify_password&#x27;</span> || res.<span class="hljs-property">error</span> === <span class="hljs-string">&#x27;user_must_modify_password&#x27;</span>) <span class="hljs-keyword">return</span> _this.<span class="hljs-title function_">confirm</span>(&#123;<br>                    <span class="hljs-attr">message</span>: _this.<span class="hljs-title function_">translate</span>(res),<br>                    <span class="hljs-attr">confirmText</span>: _this.<span class="hljs-title function_">translate</span>(<span class="hljs-string">&#x27;ToChangePassword&#x27;</span>),<br>                    <span class="hljs-attr">confirm</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">confirm</span>(<span class="hljs-params"></span>) &#123;<br>                      <span class="hljs-keyword">return</span> $(<span class="hljs-string">&#x27;#forget&#x27;</span>).<span class="hljs-title function_">click</span>();<br>                    &#125;,<br>                    <span class="hljs-attr">cancel</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">cancel</span>(<span class="hljs-params"></span>) &#123;&#125;<br>                  &#125;); <span class="hljs-comment">// 错误提示</span><br><br>                  _this.<span class="hljs-title function_">confirm</span>(&#123;<br>                    <span class="hljs-attr">message</span>: _this.<span class="hljs-title function_">translate</span>(res),<br>                    <span class="hljs-attr">confirm</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">confirm</span>(<span class="hljs-params"></span>) &#123;<br>                      <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">error</span>) obj.<span class="hljs-title function_">error</span>(res);<br>                    &#125;<br>                  &#125;);<br>                &#125;<br>              &#125;);<br>            &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>              finishReq += <span class="hljs-number">1</span>; <span class="hljs-comment">// 更改登录状态为结束</span><br><br>              _this.<span class="hljs-property">loading</span>.<span class="hljs-property">login</span> = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 若所有请求均已完成</span><br><br>              <span class="hljs-keyword">if</span> (<span class="hljs-title function_">noPending</span>()) <span class="hljs-title function_">authClose</span>(); <span class="hljs-comment">// 因为 IPv6 网络问题导致的认证失败</span><br><br>              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">err</span>(<span class="hljs-string">&#x27;Network error&#x27;</span>, err);<br>            &#125;<br>          &#125;);<br>        &#125;;<br></code></pre></td></tr></table></figure><p>发现这边多了个token参数，经过与请求对比发现，token参数是get_challenge请求中的challenge参数</p><p>获取到token参数过后，将password和token进行md5加密（应该是使用了hmac算法），得到加密后的md5值<br>参考实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>    String token=<span class="hljs-string">&quot;9175d2a16f2339e60d5e1b4be4df16b1660f79d57009e7adf4422488a2a0439a&quot;</span>;<br>    String password=<span class="hljs-string">&quot;1234567890&quot;</span>;<br><br>    <span class="hljs-type">HMac</span> <span class="hljs-variable">hmac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HMac</span>(HmacAlgorithm.HmacMD5, token.getBytes());<br>    <span class="hljs-type">byte</span>[] result = hmac.digest(password.getBytes());<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> HexUtil.encodeHexStr(result);<br>    System.out.println(s);<br>&#125;<br><br>### info部分<br><br>```js<br>_encodeUserInfo.set(_assertThisInitialized(_this), &#123;<br>  writable: <span class="hljs-literal">true</span>,<br>  value: function <span class="hljs-title function_">value</span><span class="hljs-params">(info, token)</span> &#123;<br>    <span class="hljs-comment">// 克隆自 $.base64，防止污染</span><br>    <span class="hljs-type">var</span> <span class="hljs-variable">base64</span> <span class="hljs-operator">=</span> _this.clone($.base64); <span class="hljs-comment">// base64 设置 Alpha</span><br><br><br>    base64.setAlpha(<span class="hljs-string">&#x27;LVoJPiCN2R8G90yg+hmFHuacZ1OWMnrsSTXkYpUq/3dlbfKwv6xztjI7DeBE45QA&#x27;</span>); <span class="hljs-comment">// 用户信息转 JSON</span><br><br>    info = JSON.stringify(info);<br><br>    function <span class="hljs-title function_">encode</span><span class="hljs-params">(str, key)</span> &#123;<br>      <span class="hljs-keyword">if</span> (str === <span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>      <span class="hljs-type">var</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> s(str, <span class="hljs-literal">true</span>);<br>      <span class="hljs-type">var</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> s(key, <span class="hljs-literal">false</span>);<br>      <span class="hljs-keyword">if</span> (k.length &lt; <span class="hljs-number">4</span>) k.length = <span class="hljs-number">4</span>;<br>      <span class="hljs-type">var</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> v.length - <span class="hljs-number">1</span>,<br>          z = v[n],<br>          y = v[<span class="hljs-number">0</span>],<br>          c = <span class="hljs-number">0x86014019</span> | <span class="hljs-number">0x183639A0</span>,<br>          m,<br>          e,<br>          p,<br>          q = Math.floor(<span class="hljs-number">6</span> + <span class="hljs-number">52</span> / (n + <span class="hljs-number">1</span>)),<br>          d = <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span> &lt; q--) &#123;<br>        d = d + c &amp; (<span class="hljs-number">0x8CE0D9BF</span> | <span class="hljs-number">0x731F2640</span>);<br>        e = d &gt;&gt;&gt; <span class="hljs-number">2</span> &amp; <span class="hljs-number">3</span>;<br><br>        <span class="hljs-keyword">for</span> (p = <span class="hljs-number">0</span>; p &lt; n; p++) &#123;<br>          y = v[p + <span class="hljs-number">1</span>];<br>          m = z &gt;&gt;&gt; <span class="hljs-number">5</span> ^ y &lt;&lt; <span class="hljs-number">2</span>;<br>          m += y &gt;&gt;&gt; <span class="hljs-number">3</span> ^ z &lt;&lt; <span class="hljs-number">4</span> ^ (d ^ y);<br>          m += k[p &amp; <span class="hljs-number">3</span> ^ e] ^ z;<br>          z = v[p] = v[p] + m &amp; (<span class="hljs-number">0xEFB8D130</span> | <span class="hljs-number">0x10472ECF</span>);<br>        &#125;<br><br>        y = v[<span class="hljs-number">0</span>];<br>        m = z &gt;&gt;&gt; <span class="hljs-number">5</span> ^ y &lt;&lt; <span class="hljs-number">2</span>;<br>        m += y &gt;&gt;&gt; <span class="hljs-number">3</span> ^ z &lt;&lt; <span class="hljs-number">4</span> ^ (d ^ y);<br>        m += k[p &amp; <span class="hljs-number">3</span> ^ e] ^ z;<br>        z = v[n] = v[n] + m &amp; (<span class="hljs-number">0xBB390742</span> | <span class="hljs-number">0x44C6F8BD</span>);<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> l(v, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    function <span class="hljs-title function_">s</span><span class="hljs-params">(a, b)</span> &#123;<br>      <span class="hljs-type">var</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a.length;<br>      <span class="hljs-type">var</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> [];<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">var</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; c; i += <span class="hljs-number">4</span>) &#123;<br>        v[i &gt;&gt; <span class="hljs-number">2</span>] = a.charCodeAt(i) | a.charCodeAt(i + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">8</span> | a.charCodeAt(i + <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-number">16</span> | a.charCodeAt(i + <span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-number">24</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (b) v[v.length] = c;<br>      <span class="hljs-keyword">return</span> v;<br>    &#125;<br><br>    function <span class="hljs-title function_">l</span><span class="hljs-params">(a, b)</span> &#123;<br>      <span class="hljs-type">var</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> a.length;<br>      <span class="hljs-type">var</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> d - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;<br><br>      <span class="hljs-keyword">if</span> (b) &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> a[d - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (m &lt; c - <span class="hljs-number">3</span> || m &gt; c) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        c = m;<br>      &#125;<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">var</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; d; i++) &#123;<br>        a[i] = String.fromCharCode(a[i] &amp; <span class="hljs-number">0xff</span>, a[i] &gt;&gt;&gt; <span class="hljs-number">8</span> &amp; <span class="hljs-number">0xff</span>, a[i] &gt;&gt;&gt; <span class="hljs-number">16</span> &amp; <span class="hljs-number">0xff</span>, a[i] &gt;&gt;&gt; <span class="hljs-number">24</span> &amp; <span class="hljs-number">0xff</span>);<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> b ? a.join(<span class="hljs-string">&#x27;&#x27;</span>).substring(<span class="hljs-number">0</span>, c) : a.join(<span class="hljs-string">&#x27;&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#123;SRBX1&#125;&#x27;</span> + base64.encode(encode(info, token));<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs armasm">组合<span class="hljs-keyword">str</span><br>```js<br><span class="hljs-symbol">var</span> <span class="hljs-keyword">str</span> = token + username<span class="hljs-comment">;</span><br><span class="hljs-keyword">str</span> += token + hmd5<span class="hljs-comment">;</span><br><span class="hljs-keyword">str</span> += token + ac_id<span class="hljs-comment">;</span><br><span class="hljs-keyword">str</span> += token + <span class="hljs-built_in">ip</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">str</span> += token + n<span class="hljs-comment">;</span><br><span class="hljs-keyword">str</span> += token + type<span class="hljs-comment">;</span><br><span class="hljs-keyword">str</span> += token + i<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>chksum是通过使用sha1(str)方法进行加密,str是它通过之前各个参数的拼接完成。sha1根据函数名可以猜测为sha1加密方法。</p><p>根据以上方法，我们就可以获得基础登录加密方法组装。</p><h1 id="登录实践"><a href="#登录实践" class="headerlink" title="登录实践"></a>登录实践</h1><p>分析完了srun协议的登录，但是个人懒得写相关源程序，这里借用开源项目</p><p>这里提供一个已经写好的srun登录软件，来自于github开源</p><p><a href="https://github.com/zu1k/srun">srun</a></p><p>同样是借用上面的代码锁实现的<a href="https://github.com/1328411791/GDOUYJ_Internet_Client">安卓的登录器</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录给网站添加cdn</title>
    <link href="/2023/02/12/%E8%AE%B0%E5%BD%95%E7%BB%99%E7%BD%91%E7%AB%99%E6%B7%BB%E5%8A%A0cdn/"/>
    <url>/2023/02/12/%E8%AE%B0%E5%BD%95%E7%BB%99%E7%BD%91%E7%AB%99%E6%B7%BB%E5%8A%A0cdn/</url>
    
    <content type="html"><![CDATA[<h1 id="cdn介绍"><a href="#cdn介绍" class="headerlink" title="cdn介绍"></a>cdn介绍</h1><p>内容分发网络（Content Delivery Network，简称 CDN）是利用最靠近每一位用户的服务器，更快、更可靠地将文件发送给用户分发网络。</p><p>总而言之，cdn可以加速不同地区的用户的访问，同时将网站中的静态资源缓存，以此减轻服务器的负担。</p><pre><code class="mermaid">graph LR;USER1[用户1] -->|访问|CDN[CDN]USER2[用户2] -->|访问|CDNCDN -->|转发| D[源站]</code></pre><h1 id="服务器配置CDN"><a href="#服务器配置CDN" class="headerlink" title="服务器配置CDN"></a>服务器配置CDN</h1><p>这里以腾讯云的为例</p><h2 id="前往云服务器cdn管理器"><a href="#前往云服务器cdn管理器" class="headerlink" title="前往云服务器cdn管理器"></a>前往云服务器cdn管理器</h2><p>在云中控制台中选择 <strong>内容分发网络 CDN 控制台</strong> ，购买或者领取相应的资源包</p><p>选择添加域名</p><p><img src="https://gitee.com/liahnu/img/raw/master/202302112151151.png"></p><p><img src="https://gitee.com/liahnu/img/raw/master/202302112151459.png"></p><p>加速区域选择中国境内，加速域名填写你需要加速的服务器。注意，在加速域名中，*.example.com和example.com是不同的，用户仅访问example.com有加速效果，若访问<a href="http://www.example.com或m.example.com没有加速效果,需要单独填写接入cdn加速后生效./">www.example.com或m.example.com没有加速效果，需要单独填写接入CDN加速后生效。</a></p><p>这里可能会需要验证域名的信息，这需要在域名DNS面板中的域名配置中添加参数的记录，然后点击验证<br><img src="https://gitee.com/liahnu/img/raw/master/202302112200648.png"></p><p>类型选择网页小文件</p><h3 id="源站配置"><a href="#源站配置" class="headerlink" title="源站配置"></a>源站配置</h3><p>源站类型中，选择自有源，因为我的服务器中配置了https证书，所以选择https协议，源站地址填写你的服务器地址。</p><p>填写完成后，保存</p><h2 id="设置缓存文件信息"><a href="#设置缓存文件信息" class="headerlink" title="设置缓存文件信息"></a>设置缓存文件信息</h2><p><img src="https://gitee.com/liahnu/img/raw/master/202302112158598.png"></p><p>这里默认给了配置，如果没有什么需求，默认就可以</p><p>提交配置后，需要在域名的DNS管理面板中添加CNAME转发的参数</p><p><img src="https://gitee.com/liahnu/img/raw/master/202302112201184.png"></p><p>在DNS配置中，添加记录雷系为CNAME的记录，主机记录是转发的三级域名名称，其中CNAME可以代替原先DNS指向源站的A类记录，记录值为是cdn面板中的主机记录。</p><p><img src="https://gitee.com/liahnu/img/raw/master/202302112202269.png"></p><h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>配置完成后，等待3-5分钟，就可以在cdn面板中看到配置状态。可以使用站长工具中的ping工具，检测ping地址中是否有有cdn地址，若有，也可以说明配置成功。</p><p><img src="https://gitee.com/liahnu/img/raw/master/202302112205576.png"></p><h1 id="回源相关"><a href="#回源相关" class="headerlink" title="回源相关"></a>回源相关</h1><h2 id="回源是什么"><a href="#回源是什么" class="headerlink" title="回源是什么"></a>回源是什么</h2><p>cdn向后段源服务器请求资源并缓存，这个请求过程是周期性的，自动的，称为回源。 </p>]]></content>
    
    
    
    <tags>
      
      <tag>运维，CDN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis消息队列</title>
    <link href="/2022/12/08/Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <url>/2022/12/08/Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h1><h2 id="7-1-Redis消息队列-认识消息队列"><a href="#7-1-Redis消息队列-认识消息队列" class="headerlink" title="7.1 Redis消息队列-认识消息队列"></a>7.1 Redis消息队列-认识消息队列</h2><p>什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p><ul><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ul><p>使用队列的好处在于 <strong>解耦：</strong>所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。</p><p>这种场景在我们秒杀中就变成了：我们下单之后，利用redis去进行校验下单条件，再通过队列把消息发送出去，然后再启动一个线程去消费这个消息，完成解耦，同时也加快我们的响应速度。</p><p>这里我们可以使用一些现成的mq，比如kafka，rabbitmq等等，但是呢，如果没有安装mq，我们也可以直接使用redis提供的mq方案，降低我们的部署和学习成本。</p><h2 id="7-2-Redis消息队列-基于List实现消息队列"><a href="#7-2-Redis消息队列-基于List实现消息队列" class="headerlink" title="7.2 Redis消息队列-基于List实现消息队列"></a>7.2 Redis消息队列-基于List实现消息队列</h2><p><strong>基于List结构模拟消息队列</strong></p><p>消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p><p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。<br>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p><p>基于List的消息队列有哪些优缺点？<br>优点：</p><ul><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul><p>缺点：</p><ul><li>无法避免消息丢失</li><li>只支持单消费者</li></ul><h2 id="Redis消息队列-基于PubSub的消息队列"><a href="#Redis消息队列-基于PubSub的消息队列" class="headerlink" title="Redis消息队列-基于PubSub的消息队列"></a>Redis消息队列-基于PubSub的消息队列</h2><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p><p> SUBSCRIBE channel [channel] ：订阅一个或多个频道<br> PUBLISH channel msg ：向一个频道发送消息<br> PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</p><p>基于PubSub的消息队列有哪些优缺点？<br>优点：</p><ul><li>采用发布订阅模型，支持多生产、多消费</li></ul><p>缺点：</p><ul><li>不支持数据持久化</li><li>无法避免消息丢失</li><li>消息堆积有上限，超出时数据丢失</li></ul><h3 id="7-4-Redis消息队列-基于Stream的消息队列"><a href="#7-4-Redis消息队列-基于Stream的消息队列" class="headerlink" title="7.4 Redis消息队列-基于Stream的消息队列"></a>7.4 Redis消息队列-基于Stream的消息队列</h3><p>Stream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p><p>注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题</p><p>STREAM类型消息队列的XREAD命令特点：</p><ul><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有消息漏读的风险</li></ul><h3 id="7-5-Redis消息队列-基于Stream的消息队列-消费者组"><a href="#7-5-Redis消息队列-基于Stream的消息队列-消费者组" class="headerlink" title="7.5 Redis消息队列-基于Stream的消息队列-消费者组"></a>7.5 Redis消息队列-基于Stream的消息队列-消费者组</h3><p>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p><p>key：队列名称<br>groupName：消费者组名称<br>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息<br>MKSTREAM：队列不存在时自动创建队列<br>其它常见命令：</p><p> <strong>删除指定的消费者组</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">XGROUP DESTORY key groupName</span><br></code></pre></td></tr></table></figure><p> <strong>给指定的消费者组添加消费者</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">XGROUP CREATECONSUMER key groupname consumername</span><br></code></pre></td></tr></table></figure><p> <strong>删除消费者组中的指定消费者</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">XGROUP DELCONSUMER key groupname consumername</span><br></code></pre></td></tr></table></figure><p>从消费者组读取消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]<br></code></pre></td></tr></table></figure><ul><li>group：消费组名称</li><li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li><li>count：本次查询的最大数量</li><li>BLOCK milliseconds：当没有消息时最长等待时间</li><li>NOACK：无需手动ACK，获取到消息后自动确认</li><li>STREAMS key：指定队列名称</li><li>ID：获取消息的起始ID：</li></ul><p>“&gt;”：从下一个未消费的消息开始<br>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</p><p>STREAM类型消息队列的XREADGROUP命令特点：</p><ul><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读的风险</li><li>有消息确认机制，保证消息至少被消费一次</li></ul><p>最后我们来个小对比</p><p><img src="https://gitee.com/liahnu/img/raw/master/202212082037030.png"></p><h3 id="7-6-基于Redis的Stream结构作为消息队列，实现异步秒杀下单"><a href="#7-6-基于Redis的Stream结构作为消息队列，实现异步秒杀下单" class="headerlink" title="7.6 基于Redis的Stream结构作为消息队列，实现异步秒杀下单"></a>7.6 基于Redis的Stream结构作为消息队列，实现异步秒杀下单</h3><p>需求：</p><ul><li>创建一个Stream类型的消息队列，名为stream.orders</li><li>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</li><li>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单\</li></ul><p>修改lua表达式,新增3.6</p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redisson入门</title>
    <link href="/2022/11/26/Redisson%E5%85%A5%E9%97%A8/"/>
    <url>/2022/11/26/Redisson%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis中利用setnx实现的分布式锁存在以下问题"><a href="#Redis中利用setnx实现的分布式锁存在以下问题" class="headerlink" title="Redis中利用setnx实现的分布式锁存在以下问题"></a>Redis中利用setnx实现的分布式锁存在以下问题</h1><p><strong>重入问题</strong> 重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong> 是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放</strong> 我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><p>而Redisson帮我们实现了分布式锁的相关功能</p><h1 id="Redisson可重入锁的原理"><a href="#Redisson可重入锁的原理" class="headerlink" title="Redisson可重入锁的原理"></a>Redisson可重入锁的原理</h1><p>Redisson分布式锁中，他采用hash结构用来存储锁，其中大key表示表示这把锁是否存在，用小key表示当前这把锁被哪个线程持有，</p><p><img src="/../img/2.png" alt="流程"></p><h1 id="Redisson可重入锁的锁重试"><a href="#Redisson可重入锁的锁重试" class="headerlink" title="Redisson可重入锁的锁重试"></a>Redisson可重入锁的锁重试</h1><p><img src="/../img/3.png"></p><h1 id="redisson多节点的解决"><a href="#redisson多节点的解决" class="headerlink" title="redisson多节点的解决"></a>redisson多节点的解决</h1><p>将redis各个节点分别拆成独立的节点，向所有节点设置锁，因此节点不会同时失效，参数锁问题。</p><h2 id="红锁"><a href="#红锁" class="headerlink" title="红锁"></a>红锁</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Redis中针对此种情况，引入了红锁的概念。红锁采用主节点过半机制，即获取锁或者释放锁成功的标志为：在过半的节点上操作成功。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在Redis的分布式环境中，我们假设有N个Redis master。这些节点完全互相独立，不存在主从复制或者其他集群协调机制。之前我们已经描述了在Redis单实例下怎么安全地获取和释放锁。我们确保将在每（N）个实例上使用此方法获取和释放锁。</p><h1 id="Redis可重入的锁总结"><a href="#Redis可重入的锁总结" class="headerlink" title="Redis可重入的锁总结"></a>Redis可重入的锁总结</h1><p>抢锁过程中，获得当前线程，通过tryAcquire进行抢锁，该抢锁逻辑和之前逻辑相同</p><p>1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回null</p><p>2、判断当前这把锁是否是属于当前线程，如果是，则返回null</p><p>所以如果返回是null，则代表着当前这哥们已经抢锁完毕，或者可重入完毕，但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，同学们可以自行往下翻一点点，你能发现有个while( true) 再次进行tryAcquire进行抢锁</p><p>如果是没有传入时间，则此时也会进行抢锁， 而且抢锁时间是默认看门狗时间 commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()</p><p>ttlRemainingFuture.onComplete((ttlRemaining, e) 这句话相当于对以上抢锁进行了监听，也就是说当上边抢锁完毕后，此方法会被调用，具体调用的逻辑就是去后台开启一个线程，进行续约逻辑，也就是看门狗线程</p><h2 id="5-5-分布式锁-redission锁的MutiLock原理"><a href="#5-5-分布式锁-redission锁的MutiLock原理" class="headerlink" title="5.5 分布式锁-redission锁的MutiLock原理"></a>5.5 分布式锁-redission锁的MutiLock原理</h2><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p><p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p><p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p><p>那么MutiLock 加锁原理是什么呢？笔者画了一幅图来说明</p><p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo基础指令</title>
    <link href="/2022/11/26/hexo%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/"/>
    <url>/2022/11/26/hexo%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="简写指令"><a href="#简写指令" class="headerlink" title="简写指令:"></a>简写指令:</h1><p>hexo n “我的第一篇文章” 等价于 hexo new “我的第一篇文章” 还等价于 hexo new post “我的第一篇文章”<br>hexo p 等价于 hexo publish<br>hexo g 等价于 hexo generate<br>hexo s等价于 hexo server<br>hexo d 等价于 hexo deploy<br>hexo deploy -g 等价于 hexo deploy –generate<br>hexo generate -d等价于hexo generate –deploy</p><p>注: hexo clean 没有 简写, git –version 没有简写</p><h1 id="指令说明"><a href="#指令说明" class="headerlink" title="指令说明:"></a>指令说明:</h1><p>hexo server #Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。<br>hexo server -s #以静态模式启动<br>hexo server -p 5000 #更改访问端口 (默认端口为4000，’ctrl + c’关闭server)<br>hexo server -i IP地址 #自定义 IP<br>hexo clean #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹<br>hexo g #生成静态网页 (执行 $ hexo g后会在站点根目录下生成public文件夹, hexo会将”&#x2F;blog&#x2F;source&#x2F;“ 下面的.md后缀的文件编译为.html后缀的文件,存放在”&#x2F;blog&#x2F;public&#x2F; “ 路径下)<br>hexo d #将本地数据部署到远端服务器(如github)<br>hexo init 文件夹名称 #初始化XX文件夹名称<br>npm update hexo -g#升级<br>npm install hexo -g#安装<br>node-v #查看node.js版本号<br>npm -v #查看npm版本号<br>git –version #查看git版本号<br>hexo -v #查看hexo版本号</p><h1 id="上传到git仓库指令"><a href="#上传到git仓库指令" class="headerlink" title="上传到git仓库指令"></a>上传到git仓库指令</h1><p><code>hexo clean &amp;&amp; hexo d</code> 清除缓存并上传到git仓库</p><h1 id="便签功能"><a href="#便签功能" class="headerlink" title="便签功能"></a>便签功能</h1><div class="note note-success">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><h1 id="公式编辑器"><a href="#公式编辑器" class="headerlink" title="公式编辑器"></a>公式编辑器</h1><h1 id="Mermaid-相关"><a href="#Mermaid-相关" class="headerlink" title="Mermaid 相关"></a>Mermaid 相关</h1><p><code>&#123;% mermaid %&#125;``&#123;% endmermaid %&#125;</code></p><p>用这个标记把流程图框起来（不知道为什么我这用代码块画会报错）</p><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>参见 <a href="https://hexo.fluid-dev.com/docs/guide/">https://hexo.fluid-dev.com/docs/guide/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis缓存查询</title>
    <link href="/2022/11/16/Redis%E7%BC%93%E5%AD%98%E6%9F%A5%E8%AF%A2/"/>
    <url>/2022/11/16/Redis%E7%BC%93%E5%AD%98%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="缓存的概念"><a href="#缓存的概念" class="headerlink" title="缓存的概念"></a>缓存的概念</h1><h2 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h2><p><strong>缓存</strong>(Cache),就是数据交换的<strong>缓冲区</strong>,俗称的缓存就是<strong>缓冲区内的数据</strong>。在后端开发中,缓存通常会储存在内存之中</p><p>缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低<strong>用户访问并发量带来的</strong>服务器读写压力</p><p>实际开发过程中,可能一个应用的数据量非常大,如果没有缓存来作为”避震器”,系统是几乎撑不住的,所以会大量运用到缓存技术;</p><p>但是缓存也会增加代码复杂度和运营的成本:</p><p>缓存常见的有以下几种:</p><p><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</p><p><strong>应用层缓存：</strong>可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</p><p><strong>数据库缓存：</strong>在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</p><p><strong>CPU缓存：</strong> 当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</p><p><strong>硬盘缓存：</strong> 内存向硬盘读写时候，增加硬盘的性能所产生的缓存</p><p>基本上计算机每一层直接都会有缓存作为中间态进行过度，对于后端开发而言，redis缓存是缓存数据库与应用间的数据。</p><h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p><p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p><p><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</p><p><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p><h3 id="数据库缓存不一致解决方案："><a href="#数据库缓存不一致解决方案：" class="headerlink" title="数据库缓存不一致解决方案："></a>数据库缓存不一致解决方案：</h3><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:</p><p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案</p><p>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p><p>Read&#x2F;Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p><p>Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p><h3 id="数据库和缓存不一致采用什么方案"><a href="#数据库和缓存不一致采用什么方案" class="headerlink" title="数据库和缓存不一致采用什么方案"></a>数据库和缓存不一致采用什么方案</h3><p>综合考虑会使用方案一，但是方案一调用者如何处理呢？这里有几个问题</p><p>操作缓存和数据库时有三个问题需要考虑：</p><p>如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来</p><ul><li><p>删除缓存还是更新缓存？</p><ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li></ul></li><li><p>如何保证缓存与数据库的操作的同时成功或失败？</p><ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用TCC等分布式事务方案</li></ul></li></ul><p>应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p><ul><li>先操作缓存还是先操作数据库？<ul><li>先删除缓存，再操作数据库</li><li>先操作数据库，再删除缓存</li></ul></li></ul><p>通常会使用删除缓存的方式操作</p><h3 id="缓存穿透问题的解决思路"><a href="#缓存穿透问题的解决思路" class="headerlink" title="缓存穿透问题的解决思路"></a>缓存穿透问题的解决思路</h3><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li></ul><p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p><p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p><p>假设布隆过滤器判断这个数据不存在，则直接返回</p><p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p><p><strong>总结</strong>缓存穿透的解决方案有以下这些：</p><ul><li>缓存null值</li><li>布隆过滤</li><li>增强id的复杂度，避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul><h3 id="缓存雪崩问题及解决思路"><a href="#缓存雪崩问题及解决思路" class="headerlink" title="缓存雪崩问题及解决思路"></a>缓存雪崩问题及解决思路</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案：</p><ul><li>给不同的Key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><h3 id="缓存击穿问题及解决思路"><a href="#缓存击穿问题及解决思路" class="headerlink" title="缓存击穿问题及解决思路"></a>缓存击穿问题及解决思路</h3><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>常见的解决方案有两种：</p><ul><li>互斥锁</li><li>逻辑过期</li></ul><p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p><p><strong>解决方案一、使用互斥锁来解决：</strong></p><p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p><p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p><p><strong>解决方案二、逻辑过期方案</strong></p><p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p><p>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个线程2去进行以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3直接返回数据，只有等到新开的线程2把重建数据后，其他线程才能走返回正确的数据。</p><p>两种方案的对比：</p><p><strong>互斥锁方案：</strong>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p><p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇博客</title>
    <link href="/2022/11/16/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/11/16/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>终于把github上面的github page大概搞了，大概去年这个时候创的仓库，拖到今年才开始，都快一年了了。</p><p>未来可能会把手头上做过的一些笔记整理一波扔上去。</p>]]></content>
    
    
    
    <tags>
      
      <tag>建站</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dijkstra算法</title>
    <link href="/2022/10/08/dijkstra%E7%AE%97%E6%B3%95/"/>
    <url>/2022/10/08/dijkstra%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="dijkstra算法"><a href="#dijkstra算法" class="headerlink" title="dijkstra算法"></a>dijkstra算法</h1><p>Dijkstra 算法，用于对有权图进行搜索，找出图中两点的最短距离，既不是DFS搜索，也不是BFS搜索。把Dijkstra 算法应用于无权图，或者所有边的权都相等的图，Dijkstra 算法等同于BFS搜索。<br>dijkstra算法时间复杂度为$O(n^2)$</p><h2 id="算法的思路："><a href="#算法的思路：" class="headerlink" title="算法的思路："></a>算法的思路：</h2><p>设G&#x3D;(V,E)是一个带权有向图，把图中顶点集合V分成两组第一组为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，以后每求得一条最短路径,就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了）第二组为其余未确定最短路径的顶点集合（用U表示），按最短路径长度的递增次序依次把第二组的顶点加入S中。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离，是从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。</p><h3 id="简单来说就是："><a href="#简单来说就是：" class="headerlink" title="简单来说就是："></a>简单来说就是：</h3><ol><li>先定义dist[1]&#x3D;0,dist[i]&#x3D;INF(0x3f);</li><li>for 1~n i判断不在S中，且距离最近的点，把他加入s中</li><li>然后开始更新一下它到其他点的距离</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstrac</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    <span class="hljs-comment">//初始化</span><br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//设置A--&gt;A=0开始距离</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> t=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        <span class="hljs-comment">//寻找</span><br>        <span class="hljs-keyword">if</span>(!st[j]&amp;&amp;(t==<span class="hljs-number">-1</span>||dist[j]&lt;dist[t]))<br>                t=j;<br>       st[t]=<span class="hljs-literal">true</span>;<br>       <span class="hljs-comment">//最优路径</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>       dist[j]=<span class="hljs-built_in">min</span>(dist[j],dist[t]+g[t][j]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n]==<span class="hljs-number">0x3f3f3f3f</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><pre><code class="hljs">acwing849 模板题</code></pre><p>给定一个 n 个点 m条边的有向图，图中可能存在重边和自环，所有边权均为正值。<br>请你求出 1号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含整数 n和 m。<br>接下来 m行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示 1号点到 n号点的最短距离。如果路径不存在，则输出 −1。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤n≤500,1≤m≤105,图中涉及边长均不超过10000。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs">3 31 2 22 3 11 3 4</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs">3</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 1000</span><br><span class="hljs-type">bool</span> vis[MAX];<br><span class="hljs-type">int</span> dist[MAX],g[MAX][MAX];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstrac</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[start]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> t=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>            <span class="hljs-comment">//寻找</span><br>            <span class="hljs-keyword">if</span>(!vis[j]&amp;&amp;(t==<span class="hljs-number">-1</span>||dist[j]&lt;dist[t]))<br>                t=j;<br><br>       vis[t]=<span class="hljs-literal">true</span>;<br>       <span class="hljs-comment">//最优路径</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>            dist[j]=<span class="hljs-built_in">min</span>(dist[j],dist[t]+g[t][j]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n]==<span class="hljs-number">0x3f3f3f3f</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(g));<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-type">int</span> u,v,dis;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        cin&gt;&gt;u&gt;&gt;v&gt;&gt;dis;<br>        g[u][v]=<span class="hljs-built_in">min</span>(g[u][v],dis);<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-built_in">dijkstrac</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用邻接链表"><a href="#使用邻接链表" class="headerlink" title="使用邻接链表"></a>使用邻接链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 300</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-type">int</span> n,m,num_edge;<br><span class="hljs-type">int</span> dis[MAX],head[MAX];<br><span class="hljs-type">bool</span> vis[MAX];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> from,to,dis,next;<br>&#125;edge[MAX];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>    dis[start]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> u;<br>        <span class="hljs-type">int</span> minn=INF;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        <span class="hljs-keyword">if</span>(!vis[j]&amp;&amp;dis[j]&lt;minn)&#123;<br>                u=j;<br>                minn=dis[j];<br>        &#125;<br>        vis[u]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=head[u];j!=<span class="hljs-number">0</span>;j=edge[j].next)<br>            <span class="hljs-keyword">if</span>(!vis[edge[j].to]&amp;&amp;(dis[u]+edge[j].dis&lt;dis[edge[j].to]))<br>                dis[edge[j].to]=dis[u]+edge[j].dis;<br><br>    &#125; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> from,<span class="hljs-type">int</span> to,<span class="hljs-type">int</span> dis)</span></span>&#123;<br>edge[++num_edge].next=head[from];<br>edge[num_edge].from=from;<br>edge[num_edge].to=to;<br>edge[num_edge].dis=dis;<br>head[from]=num_edge;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> u,v,w;<br>    cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)  head[i]=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;<br>            cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>            <span class="hljs-built_in">add</span>(u,v,w);<br>&#125;<br><span class="hljs-built_in">dijkstra</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(dis[n]==<span class="hljs-number">0x3f3f3f3f</span>)cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br><span class="hljs-keyword">else</span> cout&lt;&lt;dis[n];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用邻接表-堆优化"><a href="#使用邻接表-堆优化" class="headerlink" title="使用邻接表+堆优化"></a>使用邻接表+堆优化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> N,M,X;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX=<span class="hljs-number">100001</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">bool</span> vis[MAX];<br><span class="hljs-type">int</span> head[MAX],dis1[MAX],dis[MAX],num_edge;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>&#123;<br>    <span class="hljs-type">int</span> from,to,next,dis;<br>&#125;edge[MAX];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> id;<br><span class="hljs-type">int</span> d;<br><span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (node a,node b)&#123;<br><span class="hljs-keyword">return</span> a.d&gt;b.d;<br>&#125;<br>&#125;;<br>priority_queue&lt;node&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span>&#123;<br>    edge[++num_edge].next=head[u];<br>    edge[num_edge].from=u;<br>    edge[num_edge].to=v;<br>    edge[num_edge].dis=w;<br>    head[u]=num_edge;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span></span>&#123;<br><span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis)); <br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dis));<span class="hljs-comment">//初始化距离数组 </span><br>    node st;<br>    st.id=start;st.d=dis[start]=<span class="hljs-number">0</span>;<span class="hljs-comment">//1点入队 </span><br>    q.<span class="hljs-built_in">push</span>(st);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>    node hh=q.<span class="hljs-built_in">top</span>();<br>    <span class="hljs-type">int</span> u=hh.id;<br>    q.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span>(vis[u]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//若该点已经已知最短距离，访问过，则继续看下一个点</span><br>    vis[u]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=head[u];j!=<span class="hljs-number">0</span>;j=edge[j].next)&#123;<span class="hljs-comment">//松弛操作</span><br>    <span class="hljs-type">int</span> temp=edge[j].to;<br>    <span class="hljs-keyword">if</span>(!vis[temp]&amp;&amp;(dis[u]+edge[j].dis&lt;dis[temp]))<span class="hljs-comment">//更新，入队</span><br>       &#123;<br>        dis[temp]=dis[u]+edge[j].dis;<br>        node tt;<br>        tt.id=temp;tt.d=dis[temp];<br>        q.<span class="hljs-built_in">push</span>(tt);<br>        &#125;<br>    &#125;        <br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> u,v,w;<br>    cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)  head[i]=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;<br>            cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>            <span class="hljs-built_in">add</span>(u,v,w);<br>&#125;<br><span class="hljs-built_in">dijkstra</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(dis[n]==<span class="hljs-number">0x3f3f3f3f</span>)cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br><span class="hljs-keyword">else</span> cout&lt;&lt;dis[n];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包入门</title>
    <link href="/2022/07/16/%E8%83%8C%E5%8C%85%E5%85%A5%E9%97%A8/"/>
    <url>/2022/07/16/%E8%83%8C%E5%8C%85%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="背包笔记"><a href="#背包笔记" class="headerlink" title="背包笔记"></a>背包笔记</h1><p>大部分内容参考来自这篇文章<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="背包九讲 https://www.cnblogs.com/jbelial/articles/2116074.html">[1]</span></a></sup>和wiki上的内容<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="OI-WIKI">[2]</span></a></sup>。</p><h1 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h1><blockquote><p>题目:有N件物品和一个容量为V的背包。第i件物品的费用是v[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </p></blockquote><p>这是最基础的背包问题，后面的背包问题都由01背包问题衍生。问题的特点是：每种物品仅有一件，只能选择放或不放。 </p><p>如果这个问题采用枚举的思想，他的时间复杂度为$O(n^2)$，我们可以利用一张二维表记录数据，运用递推，这样时间复杂度就降低为$O(N*V)$</p><p>基本思路：用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：f[i][v]&#x3D;max{f[i-1][v],f[i-1][v-c[i]]+w[i]}。 具体来说就是我们就利用一张二位表，记录了整个题目中每一个问题的解答。</p><p>用一个例子来讲大致是什么</p><blockquote><p>输入</p><blockquote><p>4 5<br>1 2<br>2 4<br>3 4<br>4 5</p></blockquote></blockquote><blockquote><p>输出</p><blockquote><p>8</p></blockquote></blockquote><p>这个例子我们可以利用一张二维表来直观展示表示</p><p><img src="https://gitee.com/liahnu/img/raw/master/img/202112251111153.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> w[<span class="hljs-number">1002</span>],v[<span class="hljs-number">1002</span>];<br><span class="hljs-type">int</span> f[<span class="hljs-number">1002</span>][<span class="hljs-number">1002</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> N,V;<br>    cin&gt;&gt;N&gt;&gt;V;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)&#123;<br>        cin&gt;&gt;v[i]&gt;&gt;w[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j &lt; v[i]) <br>                f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">else</span>    <br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i - <span class="hljs-number">1</span>][j - v[i]] + w[i]);<br>        &#125; <br>    &#125;<br>    cout&lt;&lt;f[N][V];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>对于这个代码的优化,其中时间复杂度基本已经不能再优化了，我们可以将他改为一维数组,这样空间复杂度却可以优化到O(V)。</p><p>注意改成一维数组后要从后往前逆序推，如果正推一个物品会取多次，这也是完全背包的解法。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> w[<span class="hljs-number">1002</span>],v[<span class="hljs-number">1002</span>];<br><span class="hljs-type">int</span> f[<span class="hljs-number">1002</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> N,V;<br>    cin&gt;&gt;N&gt;&gt;V;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)&#123;<br>        cin&gt;&gt;v[i]&gt;&gt;w[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = V; j &gt;= v[i]; j--)<br>        &#123;<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>        &#125; <br>    &#125;<br>    cout&lt;&lt;f[V];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。 </p><h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><p>完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。</p><p>我们可以借鉴 0-1 背包的思路，进行状态定义。其状态转移方程依然还是：<code>f[i][v]=max&#123;f[i-1][v],f[i-1][v-c[i]]+w[i]&#125;</code>。但其推到方式与0-1背包不同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> w[<span class="hljs-number">1002</span>],v[<span class="hljs-number">1002</span>];<br><span class="hljs-type">int</span> f[<span class="hljs-number">1002</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> N,V;<br>    cin&gt;&gt;N&gt;&gt;V;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)&#123;<br>        cin&gt;&gt;v[i]&gt;&gt;w[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = v[i]; j &lt;=M ; j++)<br>        &#123;<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>        &#125; <br>    &#125;<br>    cout&lt;&lt;f[V];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h1><pre><code class="hljs">【题目描述】设有n种物品，每种物品有一个重量及一个价值。但每种物品的数量是无限的，同时有一个背包，最大载重量为M，今从n种物品中选取若干件(同一种物品可以多次选取)，使其重量的和小于等于M，而价值的和为最大。【输入】第一行：两个整数，M(背包容量，M≤200)和N(物品数量，N≤30)；第2..N+1行：每行二个整数Wi,Ci，表示每个物品的重量和价值。【输出】仅一行，一个数，表示最大总价值。【输入样例】10 42 13 34 57 9【输出样例】12</code></pre><p>可以用和01背包一样的方式，f[i][v]表示前i种物品恰放入一个容量为v的背包的最大价值，可以用k表示当前容量下可以装第i种物品的件数，那么k的范围应该是0≤k≤v&#x2F;c[i]，既然要用当前物品i把当前容量装满那需要0≤k≤v&#x2F;c[i]件，其中k表示件数。<br>状态转移方程为：<code>f[i][v] = max&#123;f[i-1][v],f[i-1][j - k * c[i]] + k * w[i]&#125;(0&lt;=k*c[i]&lt;=v)</code></p><p>基于01背包问题的代码进行简单修改，我们可以写出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> c[<span class="hljs-number">1002</span>],w[<span class="hljs-number">1002</span>];<br><span class="hljs-type">int</span> f[<span class="hljs-number">1002</span>][<span class="hljs-number">1002</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> N,V;<br>    cin&gt;&gt;V&gt;&gt;N;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)&#123;<br>        cin&gt;&gt;c[i]&gt;&gt;w[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;=N; i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k*c[i] &lt;= j; k++)&#123;<br>                f[i][j] =<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j],f[i<span class="hljs-number">-1</span>][j-k*c[i]]+k*w[i]) ;<br>        <span class="hljs-comment">//要么不取，要么取0件、取1件、取2件……取k件</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;f[N][V];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二进制分组优化"><a href="#二进制分组优化" class="headerlink" title="二进制分组优化"></a>二进制分组优化</h2><p>在朴素的做法中，一个一个枚举通常效率低下，因为在逐个枚举的过程中，出现了同时选了等效的问题，我们可以对数量进行二进制分组。</p><pre><code class="hljs">例子6=1+2+38=1+2+3+1</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>  <span class="hljs-type">int</span> c = <span class="hljs-number">1</span>, p, h, k;<br>  cin &gt;&gt; p &gt;&gt; h &gt;&gt; k;<br>  <span class="hljs-keyword">while</span> (k - c &gt; <span class="hljs-number">0</span>) &#123;<br>    k -= c;<br>    list[++index].w = c * p;<br>    list[index].v = c * h;<br>    c *= <span class="hljs-number">2</span>;<br>  &#125;<br>  list[++index].w = p * k;<br>  list[index].v = h * k;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h2><p>（不会，暂时空着）</p><h1 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h1><p>混合背包就是将前面三种的背包问题混合起来，有的只能取一次，有的能取无限次，有的只能取  次。</p><p>这种题目看起来很吓人，可是只要领悟了前面几种背包的中心思想，并将其合并在一起就可以了。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>背包九讲 <a href="https://www.cnblogs.com/jbelial/articles/2116074.html">https://www.cnblogs.com/jbelial/articles/2116074.html</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>OI-WIKI<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Floyd算法入门</title>
    <link href="/2022/05/16/Floyd%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"/>
    <url>/2022/05/16/Floyd%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="所有顶点对间的最短路径问题（Floyd算法）"><a href="#所有顶点对间的最短路径问题（Floyd算法）" class="headerlink" title="所有顶点对间的最短路径问题（Floyd算法）"></a>所有顶点对间的最短路径问题（Floyd算法）</h1><p>Floyd算法又称为弗洛伊德算法，插点法，是一种用于寻找给定的加权图中顶点间最短路径的算法。简称Floyed(弗洛伊德)算法，是最简单的最短路径算法，可以计算图中任意两点间的最短路径。</p><p>Floyd的时间复杂度是$O (N^3)$，适用于出现负边权的情况。</p><h2 id="算法的基本思想："><a href="#算法的基本思想：" class="headerlink" title="算法的基本思想："></a>算法的基本思想：</h2><p>开始时，以任意两个顶点之间的有向边的权值作为路径长度，没有有向边时，路径长度为∞<br>以后逐步尝试在原路径中加入其它顶点作为中间顶点，如果增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径，修改矩阵元素。</p><h2 id="算法描述："><a href="#算法描述：" class="headerlink" title="算法描述："></a>算法描述：</h2><p>二维数组存储最短路径，如果要求输出任意两个顶点间的最短路径，经过的顶点也要输出的话，根据题目要求可定义成三维数组存储路径经过的顶点，再进行适当的算法后对这两个数组进行输出即可</p><ol><li><p>初始化：点u、v如果有边相连，则<code>dis[u][v]=w[u][v]</code>。<br>如果不相连则<code>memset(dis,INT_MAX,sizeof(dis))</code></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++) <span class="hljs-comment">//k必须在外层</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)       <br>            <span class="hljs-keyword">if</span>(dis[i][j]&gt;dis[i][k]+dis[k][j])<br>                dis[i][j]=dis[i][k]+dis[k][j];<br></code></pre></td></tr></table></figure></li><li><p>算法结束：dis即为所有点对的最短路径矩阵</p></li></ol><h2 id="算法分析-amp-思想讲解："><a href="#算法分析-amp-思想讲解：" class="headerlink" title="算法分析&amp;思想讲解："></a>算法分析&amp;思想讲解：</h2><p>三层循环，第一层循环中间点k，第二第三层循环起点终点i、j<br>算法的思想很容易理解：如果点i到点k的距离加上点k到点j的距离小于原先点i到点j的距离，那么就用这个更短的路径长度来更新原先点i到点j的距离。</p><p>在下图中，因为<code>dis[1][3]+dis[3][2]&lt;dis[1][2]</code>，所以就用<code>dis[1][3]+dis[3][2]</code>来更新原先1到2的距离。</p><p>我们在初始化时，把不相连的点之间的距离设为一个很大的数，不妨可以看作这两点相隔很远很远，如果两者之间有最短路径的话，就会更新成最短路径的长度。<br>Floyed算法的时间复杂度是$O(N^3)$ 。</p><pre class="mermaid">graph LRA(1) -->|6|B(2)B(2) -->|1|C(3)C(3) -->|2|A(1);</pre><h2 id="Floyed算法优缺点分析"><a href="#Floyed算法优缺点分析" class="headerlink" title="Floyed算法优缺点分析"></a>Floyed算法优缺点分析</h2><p>Floyd算法适用于APSP(All Pairs Shortest Paths)，是一种动态规划算法，稠密图效果最佳，边权可正可负,适用于解决所有顶点对间的最短路径问题。此算法简单有效，由于三重循环结构紧凑，对于稠密图，效率要高于执行$V$次DijkStra算法。<br>注意同坐标求长度的公式（三角形勾股定理）<br>但不能解决带有“负权环路”（或者叫“负权环”）的图。如下图：</p><pre class="mermaid">graph LRA(1) -->|-6|B(2)B(2) -->|1|C(3)C(3) -->|2|A(1);</pre><p><strong>优点</strong>：容易理解，可以算出任意两个节点之间的最短距离，代码编写简单； </p><p><strong>缺点</strong>：时间复杂度比较高，不适合计算大量数据。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
