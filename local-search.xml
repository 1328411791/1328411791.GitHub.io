<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机网络期末复习</title>
    <link href="/2023/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="互联网组成"><a href="#互联网组成" class="headerlink" title="互联网组成"></a>互联网组成</h2><p>互联网组成：核心部分——路由器为主、边缘部分——终端为主</p><p>边缘：网络服务模式；P2P——对等网、C&#x2F;S——客户机&#x2F;服务器</p><p>核心：交换方式； 电路交换与分组交换、面向连接与面向无连接</p><p>电路交换过程：一条通路，传输效率？交换机雏形，人工交换——&gt;程控交换，计算机程控交换</p><p>分组交换过程：多路并发，数据传输效率高，但转发有时延</p><p>报文转发可理解为一个分组的转发，效率低、时延大，……</p><p>我国计算机网络应用发展：后来居上</p><h2 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h2><p><strong>LAN（PAN）、MAN、WAN地理范围</strong><br>LAN——局域网，5~10Km（PAN——个域网10m以内）</p><p>Man——城域网，100Km以下</p><p>WAN——广域网，城市之间</p><p><strong>网络性能指标</strong><br>速率:   bit per second，    如 1Mb&#x2F;s<br>带宽：频带宽度，与速率成正比   用速率描述之。同上<br>呑吐量：单位时间内正确接收的bit数，1秒发1Mbit，正确接收6Kbit，……</p><p>时延：发送、传播、处理、排队中四类时间延迟，传播时延可忽略，发送时延取于带宽，处理时延、排队时两者延取决于主机和网络。总时延由此四部分组成，具体问题要按实际分析得出。</p><p>通信原语——请求(Request) 、指示(Indication)、响应(Response)、确认(Confirm) </p><p>通信协议：——约定、规则、规程，……，统一称之为“协议”，双方通信开始时，要进行“协商”（用什么通信规则、统一文件格式、纠错、流量控制，……）</p><p>OSI七层模型：ISO7498标准，理想模型； TCP&#x2F;IP模型，实用模型，两者特点与差异分析</p><p>通信协议分层的作用：分而治之、降低难度。</p><p>协议三要素是：语法、主义、同步</p><p>分层原则：每层功能独立、层数合适，上下层之间有接口，上层调用下层的服务，下层为上层提供服务。以快递一本书为例，用户层，快递层，物流层。对等层有协议，上下层之间有接口，最底层是真实通信，上面的对等层是虚通信。</p><p>实体：在某一对等层上收、发的规则集合，通常是一个特定的模块</p><p>协议：对等层之间通信的规则（Protocol），是通信模型中的水平关系</p><p>服务：收、发某一方上下层次之间的服务接口（SAP），是垂直关系。</p><p>网络体系结构就是：网络通信模型中的各层（层数、层名）+对等层协议、层间接口、……、相关内容的集合。</p><h2 id="重点概念"><a href="#重点概念" class="headerlink" title="重点概念"></a>重点概念</h2><p><strong>internet与Internet之区别</strong><br>“internet”是一个通用名词，指的是由多个计算机网络相互连接而成的全球性网络。它是一个广义的概念，可以用来描述任何由多个网络组成的互联网络。</p><p>“Internet”是一个特定的名词，指的是全球范围内最大的计算机网络，由许多互联的计算机网络组成。它是由大写字母”I”开头的专有名词，用来指代我们通常所说的互联网。</p><p><strong>电路交换与分组交换的物点对比</strong><br>电路交换是一种传输方式，其中在通信开始之前，建立了一个专用的物理连接，该连接在整个通信过程中保持不变。这意味着在通信期间，发送方和接收方之间的通信路径是专用的，不会被其他用户共享。这种方式类似于电话系统中的拨号连接，其中在通话期间，电话线路是专门为两个用户保留的。</p><p>分组交换是另一种传输方式，其中数据被分割成小的数据包（或称为分组），然后通过网络传输。每个数据包都包含有关发送方和接收方的地址信息，以便在网络中正确路由。这些数据包可以通过不同的路径传输，并且在接收方重新组装以恢复原始数据。这种方式类似于邮件系统，其中信件被分成小的信封，并通过邮递员逐个传递。</p><p><strong>C&#x2F;S模式与P2P模式的区别与相同点</strong><br>C&#x2F;S模式与P2P模式的区别与相同点 C&#x2F;S模式（Client&#x2F;Server模式）是一种网络服务模式，其中客户端和服务器之间存在明确的角色分工。客户端向服务器发送请求，服务器提供相应的服务和资源。P2P模式（Peer-to-Peer模式）是一种对等网络模式，其中所有参与者都可以充当客户端和服务器的角色，彼此之间共享资源和服务。</p><p><strong>LAN（PAN）、MAN、WAN之地理范围</strong><br>LAN——局域网，5~10Km（PAN——个域网10m以内）</p><p>Man——城域网，100Km以下</p><p>WAN——广域网，城市之间</p><p><strong>带宽、时延</strong></p><p>时延：发送、传播、处理、排队中四类时间延迟，传播时延可忽略，发送时延取于带宽，处理时延、排队时两者延取决于主机和网络。总时延由此四部分组成，具体问题要按实际分析得出。</p><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><h1 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h1><h2 id="物理层功能"><a href="#物理层功能" class="headerlink" title="物理层功能"></a>物理层功能</h2><p>物理层是网络通信的最底层，是真实的通信</p><p>物理层要研究的是：屏蔽不同通信媒体之间的差异，提出其共性的技术要求，使上层感觉不到底层差异。</p><p>实际上，物理层研究的是接口特性：如通信接口的机械、电气、功能、过程四方面特性。</p><p>物理层通信都是在一根 线上“串行”传输的，收、发可一个信道，也可丰不同的信道上。</p><p>物理层协议早期称之为“规程”</p><p>物理层因具体抛入媒体及方式众多，物理层规程（协议）也很多。</p><p>接口与通信课程中，有更详细的介绍。</p><h2 id="物理层基础"><a href="#物理层基础" class="headerlink" title="物理层基础"></a>物理层基础</h2><p>通信系统模型：源、发送器，传输系统，接收器、终点</p><p>常用概念：Data、信号（模拟、数字），单工、双工、半双工通信</p><p>基带、调制、编码，调制（带通）信号</p><p>几种编码方式：归零、不归零编码，曼彻思特、差分曼彻思特编码，……</p><p>带通调制：调幅、调频、调相</p><p>信道极限容量——失真，通信频带确定，信噪比，</p><p>Nyquist定理——理想信道速率；</p><p>Shannon公式工——实际信道，有噪声的最大速率。</p><h2 id="通信媒体"><a href="#通信媒体" class="headerlink" title="通信媒体"></a>通信媒体</h2><p>电磁波谱</p><p>双绞线：UTP 100Base-T（100米）的解释，10GBASE-T（35~100米），……，</p><p>同轴电缆</p><p>光纤：工作原理，单模&#x2F;多模</p><p>无线（非引导型）媒体：方便。</p><p>微波（1mm~1m）,50km-，需要中继，特点：容量大，质量高；但视距内，环境影响大，维护成本高。</p><p>卫星通信：距离远（3万km+）,三颗卫星覆盖全球，有固定时延（250~300ms）。特点：发射成本高，维护成本低；</p><p>高轨（3万+），低轨（2千-），星链系统是低轨首卫星通信系统。</p><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><p>复用：在一条线路上开辟多条信道，传送多信号；</p><p>频分FDM：分成多个子频带，每个子频带传送一路信号</p><p>时分TDM：分成11 个时间片，每个时间片传送一路信号</p><p>波分WDM：光的频分复用</p><p>码分CDMA：每个站点一个特定码片，+1发码片，0发反码片，（自学）……</p><p>工作原理，复用器、分用器，以有线电话为例：电话频带267KHz，每个话带4KHz，实用中最多分出24个子频带</p><h2 id="数字传输与带宽接入"><a href="#数字传输与带宽接入" class="headerlink" title="数字传输与带宽接入"></a>数字传输与带宽接入</h2><p>数字传输系统：承载语音、图像、视频多种数据，现在均用光纤网络媒体</p><p>高速宽带网络的关键技术：</p><p>速率统一问题：T1（北美、日本） 1.544Mbit&#x2F;s，E1（欧洲）2.048Mbit&#x2F;s；</p><p>全球同步问题：全球时钟一致问题，</p><p>同步光纤网（美国）SONET，第一级 51.840Mbit&#x2F;s，其它见教材P62 表2-2</p><p>ITU-T推出SDH（国际标准同步系列），与SONET有关联，划分等级不一样。同上查表2-2</p><p>SDH&#x2F;SONET使得北美，日本，欧洲的标准统一起来。对世界电信网络的发展意义重大</p><p>ADSL／ＶSDL，10Ｍ／５0Ｍ，</p><p>宽带网接入：以太网互连</p><p>光纤接入　200～1000MBit&#x2F;s</p><h2 id="重点概念-1"><a href="#重点概念-1" class="headerlink" title="重点概念"></a>重点概念</h2><p><strong>通信系统模型，通信方式（单 工、双工、半双工）</strong></p><ul><li><p>单工（Simplex）：数据只能在一个方向上流动，不能双向传输。例如，广播就是单工通信，信息只能从广播站传输到接收者，接收者不能向广播站发送信息。</p></li><li><p>双工（Duplex）：数据可以同时在两个方向上流动，即设备可以同时发送和接收数据。例如，电话就是双工通信，两个人可以同时说话和听对方说话。</p></li><li><p>半双工（Half Duplex）：数据可以在两个方向上流动，但不能同时。在任何时候，数据只能在一个方向上流动。例如，对讲机就是半双工通信，一方说话时，另一方只能听，不能同时说话。</p></li></ul><p><strong>带宽调制——调幅、调频、调相及复合调制</strong></p><ul><li><p>调幅（Amplitude Modulation）：在调幅中，信号的幅度或强度会根据要发送的信息进行变化。这是最早的和最简单的无线电广播技术。</p></li><li><p>调频（Frequency Modulation）：在调频中，信号的频率会根据要发送的信息进行变化。这种技术通常用于FM广播。</p></li><li><p>调相（Phase Modulation）：在调相中，信号的相位会根据要发送的信息进行变化。这种技术常用于数字数据的传输。</p></li><li><p>复合调制（Composite Modulation）：复合调制是指同时使用两种或更多种调制技术。例如，调幅调相键控（AM-PSK）就是一种复合调制技术。</p></li></ul><p><strong>双绞线、光纤的性能特点与应用</strong></p><ul><li><p>双绞线（Twisted Pair）：双绞线是一种常见的有线传输介质，由两根互相绞合的铜线组成。双绞线的主要优点是成本低，安装简单。然而，双绞线的传输距离和速度都相对较低，而且容易受到电磁干扰。双绞线通常用于电话线和局域网（LAN）。</p></li><li><p>光纤（Optical Fiber）：光纤是一种使用光信号进行数据传输的介质。光纤的主要优点是传输距离远，速度快，不受电磁干扰。然而，光纤的成本较高，安装和维护也相对复杂。光纤通常用于广域网（WAN），如互联网的主干网络。</p></li></ul><p><strong>微波、卫星通信的特点</strong></p><ul><li><p>微波（Microwave）：微波通信是一种使用高频率的无线电波进行数据传输的方式。微波通信的主要优点是传输速度快，延迟低，而且设备成本相对较低。然而，微波通信的传输距离受到限制，通常需要直线视距（LOS）连接，而且容易受到天气和其他无线电设备的干扰。微波通信通常用于城市之间或大楼之间的数据连接。</p></li><li><p>卫星通信（Satellite Communication）：卫星通信是一种使用地球轨道上的卫星进行数据传输的方式。卫星通信的主要优点是覆盖范围广，可以覆盖地球的大部分地区。然而，卫星通信的延迟较高，而且设备和运营成本也较高。卫星通信通常用于电视广播、全球定位系统（GPS）和远程通信。</p></li></ul><p><strong>信道复用——FDM、TDM、WDM、CDMA</strong></p><p><strong>SONET与SDH的关系及区别</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySql的表空间</title>
    <link href="/2023/09/14/MySql%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4/"/>
    <url>/2023/09/14/MySql%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="独立表空间结构"><a href="#独立表空间结构" class="headerlink" title="独立表空间结构"></a>独立表空间结构</h1><h2 id="区（extent）"><a href="#区（extent）" class="headerlink" title="区（extent）"></a>区（extent）</h2><p>空间中的页实在是太多了，为了更好的管理这些页面，设计InnoDB的提出了区（英文名：extent）的概念。对于16KB的页来说，连续的64个页就是一个区，也就是说一个区默认占用1MB空间大小。不论是系统表空间还是独立表空间，都可以看成是由若干个区组成的，每256个区被划分成一组。</p><p><img src="https://pic.liahnu.top/img/202309142121057.png"></p><p>第一个组最开始的3个页面的类型是固定的，也就是说extent 0这个区最开始的3个页面的类型是固定的，分别是：</p><ul><li><p>FSP_HDR类型：这个类型的页面是用来登记整个表空间的一些整体属性以及本组所有的区，也就是extent 0 ~ extent 255这256个区的属性。需要注意的一点是，整个表空间只有一个FSP_HDR类型的页面。</p></li><li><p>IBUF_BITMAP类型：这个类型的页面是存储本组所有的区的所有页面关于INSERT BUFFER的信息。</p></li><li><p>INODE类型：这个类型的页面存储了许多称为INODE的数据结构。</p></li></ul><p>其余各组最开始的2个页面的类型是固定的，也就是说extent 256、extent 512这些区最开始的2个页面的类型是固定的，分别是：</p><ul><li><p>XDES类型：全称是extent descriptor，用来登记本组256个区的属性，也就是说对于在extent 256区中的该类型页面存储的就是extent 256 ~ extent 511这些区的属性，对于在extent 512区中的该类型页面存储的就是extent 512 ~ extent 767这些区的属性。上边介绍的FSP_HDR类型的页面其实和XDES类型的页面的作用类似，只不过FSP_HDR类型的页面还会额外存储一些表空间的属性。</p></li><li><p>IBUF_BITMAP类型：上边介绍过了。</p></li></ul><h3 id="为什么要提出区"><a href="#为什么要提出区" class="headerlink" title="为什么要提出区"></a>为什么要提出区</h3><p>我们每向表中插入一条记录时，也就是想索引添加记录，B+树的每一层中的页都会形成一个双向链表，如果是以页为单位来分配存储空间的话，双向链表相邻的两个页之间的物理位置可能离得非常远。我们介绍B+树索引的适用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的随机I&#x2F;O。这对于速度影响恒大，所以我们需要尽量减少随机I&#x2F;O的次数。</p><p>引入了区（extent）的概念，一个区就是在物理位置上连续的64个页。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区为单位分配，甚至在表中的数据十分非常特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费，但是从性能角度看，可以消除很多的随机I&#x2F;O，功大于过嘛！</p><h2 id="段（segment）"><a href="#段（segment）" class="headerlink" title="段（segment）"></a>段（segment）</h2><p>InnoDB对B+树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个段（segment），存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。</p><p>默认情况下一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的。，一个区默认占用1M存储空间，对于不足以填满一个区的情况，提出了碎片（fragment）区的概念。也就是在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。所以此后为某个段分配存储空间的策略是这样的：</p><ul><li><p>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</p></li><li><p>当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间。</p></li></ul><h3 id="区的分类"><a href="#区的分类" class="headerlink" title="区的分类"></a>区的分类</h3><ul><li><p><strong>空闲的区（FREE）</strong>现在还没有用到这个区中的任何页面。</p></li><li><p><strong>有剩余空间的碎片区（FREE_FRAG）</strong>表示碎片区中还有可用的页面。</p></li><li><p><strong>没有剩余空间的碎片区（FULL_FRAG）</strong>表示碎片区中的所有页面都被使用，没有空闲页面。</p></li><li><p><strong>附属于某个段的区（FSEG）</strong>每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位。</p></li></ul><p>为了方便管理这些区，设计InnoDB的设计了一个称为XDES Entry的结构（全称就是Extent Descriptor Entry），每一个区都对应着一个XDES Entry结构，这个结构记录了对应的区的一些属性。</p><p><img src="https://pic.liahnu.top/img/202309181643532.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC与多线程</title>
    <link href="/2023/09/04/RPC%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2023/09/04/RPC%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么使用Go不使用C-等语言"><a href="#为什么使用Go不使用C-等语言" class="headerlink" title="为什么使用Go不使用C++等语言"></a>为什么使用Go不使用C++等语言</h1><ol><li>因为Go语言有go程，可以方便创建以及使用线程</li><li>Go是类型安全和内存安全的，不需要像c++一样处理复杂的内存问题</li><li>同时，这门语言比C++简单</li></ol><h1 id="分布式下的多线程操作"><a href="#分布式下的多线程操作" class="headerlink" title="分布式下的多线程操作"></a>分布式下的多线程操作</h1><p>在分布式下，客户端可能需要对多个进行处理，这时候就要使用多线程对其进行操作。</p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><h2 id="并行性"><a href="#并行性" class="headerlink" title="并行性"></a>并行性</h2>]]></content>
    
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySql-索引</title>
    <link href="/2023/07/17/MySql-%E7%B4%A2%E5%BC%95/"/>
    <url>/2023/07/17/MySql-%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="没有索引的情况"><a href="#没有索引的情况" class="headerlink" title="没有索引的情况"></a>没有索引的情况</h1><h2 id="在一个页中的查找"><a href="#在一个页中的查找" class="headerlink" title="在一个页中的查找"></a>在一个页中的查找</h2><p>假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p><ul><li>以主键为搜索条件</li></ul><p>在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p><ul><li>以其他列作为搜索条件</li></ul><p>对非主键列的查找的过程可就不这么幸运了，因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</p><h2 id="在很多页中查找"><a href="#在很多页中查找" class="headerlink" title="在很多页中查找"></a>在很多页中查找</h2><p>大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：</p><p>定位到记录所在的页。<br>从所在的页内中查找相应的记录。<br>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们刚刚唠叨过的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是非常耗时的，这时候就要用到索引了。</p><h1 id="InnoDB中的索引方案"><a href="#InnoDB中的索引方案" class="headerlink" title="InnoDB中的索引方案"></a>InnoDB中的索引方案</h1><h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>InnoDB是使用页来作为管理存储空间的基本单位，也就是最多能保证16KB的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。</p><p>InnoDB中，目录页索引复用了最基础的页。只不过目录项中的两个列是主键和页号而已，所以他们复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为目录项记录。</p><p>同时，InnoDB会将所有的目录项记录都存放到一张叫做聚集索引的B+树中，这棵B+树的叶子节点就是目录项记录，而非叶子节点则是目录项记录的页号。这样，我们就可以通过B+树来快速的定位到目录项记录所在的页，然后再根据目录项记录中的页号找到对应的数据页，最后再在数据页中查找相应的记录。</p><p><img src="https://pic.liahnu.top/img/202307190018774.png"></p><p>我们上边介绍的B+树本身就是一个目录，或者说本身就是一个索引。它有两个特点：</p><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p><ol><li><p>页内的记录是按照主键的大小顺序排成一个单向链表。</p></li><li><p>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。</p></li><li><p>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</p></li></ol><p>B+树的叶子节点存储的是完整的用户记录。</p><p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p><p>我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX语句去创建（后边会介绍索引相关的语句），InnoDB存储引擎会自动的为我们创建聚簇索引。另外有趣的一点是，在InnoDB存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据，数据即索引。</p><h2 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h2><p>上边介绍的聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件时，这时候就需要用到二级索引了。</p><p>我们可以多建几棵B+树，不同的B+树中的数据采用不同的排序规则。如下图</p><p><img src="https://pic.liahnu.top/img/202309102235281.png"></p><p>这颗B+树与聚类索引的树有以下几方面的不同</p><ol><li><p>页内的记录是按照<strong>索引参数</strong>的大小顺序排成一个单向链表。</p></li><li><p>各个存放用户记录的页也是根据页中记录的<strong>索引参数</strong>大小顺序排成一个双向链表。</p></li><li><p>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的<strong>索引参数</strong>列大小顺序排成一个双向链表。</p></li><li><p>B+树的叶子节点存储的并不是完整的用户记录，而只是<strong>索引参数</strong>+主键这两个列的值。</p></li><li><p>目录项记录中不再是主键+页号的搭配，而变成了<strong>索引参数</strong>列+页号的搭配</p></li></ol><p>因为这个B+树的叶子节点中的记录只存储了<strong>索引参数</strong>和主键两个列，所以我们必须再根据主键值去聚簇索引中再查找一遍，才能得到完整的用户记录。这个过程也被称为回表。因为需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为二级索引（英文名secondary index），或者辅助索引。</p><div class="note note-success">            <p><strong>为什么不能把用户记录放到叶子节点中</strong></p><p>如果把完整的用户记录放到叶子节点是可以不用回表，但是太占地方。相当于于每建立一棵B+树都需要把所有的用户记录再都拷贝一遍。</p>          </div><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引,此时建立的索引叫做联合索引。但是其任然属于二级索引的一种。</p><p><img src="https://pic.liahnu.top/img/202309102244158.png"></p><p>每条目录项记录都由c2、c3、页号这三个部分组成，页面和记录先按照联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序。</p><h2 id="InnoDB的B-树索引的注意事项"><a href="#InnoDB的B-树索引的注意事项" class="headerlink" title="InnoDB的B+树索引的注意事项"></a>InnoDB的B+树索引的注意事项</h2><h3 id="根页面万年不动窝"><a href="#根页面万年不动窝" class="headerlink" title="根页面万年不动窝"></a>根页面万年不动窝</h3><p>一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是InnoDB存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。</p><h3 id="内节点中目录项记录的唯一性"><a href="#内节点中目录项记录的唯一性" class="headerlink" title="内节点中目录项记录的唯一性"></a>内节点中目录项记录的唯一性</h3><p>为了让新插入记录能找到自己在那个页里，我们需要保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><p>这样我们再插入记录(9, 1, ‘c’)时，由于页3中存储的目录项记录是由c2列 + 主键 + 页号的值构成的，可以先把新记录的c2列的值和页3中各目录项记录的c2列的值作比较，如果c2列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的c2列 + 主键的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到页5中。</p><h3 id="一个页面最少存储2条记录"><a href="#一个页面最少存储2条记录" class="headerlink" title="一个页面最少存储2条记录"></a>一个页面最少存储2条记录</h3><p>我们前边说过一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度杠杠的！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中只能存放一条记录。费了半天劲只能存放一条真实的用户记录？逗我呢？所以InnoDB的一个数据页至少可以存放两条记录。</p><h1 id="B-树索引的使用"><a href="#B-树索引的使用" class="headerlink" title="B+树索引的使用"></a>B+树索引的使用</h1><h2 id="使用的代价"><a href="#使用的代价" class="headerlink" title="使用的代价"></a>使用的代价</h2><ul><li><strong>空间上的代价</strong></li></ul><p>这个是显而易见的，每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用16KB的存储空间，一棵很大的B+树由许多数据页组成，那可是很大的一片存储空间呢。</p><ul><li><strong>时间上的代价</strong></li></ul><p>每次对表中的数据进行增、删、改操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收啥的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，这还能不给性能拖后腿么？</p><p>所以说，一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。</p><h2 id="B-树索引适用查找匹配的情况"><a href="#B-树索引适用查找匹配的情况" class="headerlink" title="B+树索引适用查找匹配的情况"></a>B+树索引适用查找匹配的情况</h2><p><strong>全值匹配</strong><br>如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM person_info WHERE name = &#x27;Ashburn&#x27; AND birthday = &#x27;1990-09-27&#x27; AND phone_number = &#x27;15123983239&#x27;;<br></code></pre></td></tr></table></figure><p>在查询过程中会按照<code>name</code>、<code>birthday</code>、<code>phone_number</code>的顺序进行查找，因为这三个列都是联合索引的一部分，所以可以快速的定位到目录项记录所在的页，然后再根据页号找到对应的数据页，最后再在数据页中查找相应的记录。</p><p>其中,查询的顺序对索引是没有影响的,MySQL有一个叫查询优化器,可以优化查询语句.</p><p><strong>匹配左边的列</strong></p><p>在搜索中,包含匹配左边的项,就可以使用到这个索引,原因和上面的一样,mysql会按照索引从左到右的顺序进行查找.</p><p><strong>匹配范围值</strong></p><p>在搜索中,包含匹配范围值,就可以使用到这个索引,原因和上面的一样,mysql会按照索引从左到右的顺序进行查找.</p><p><strong>字符串前缀匹配</strong></p><p>在搜索中,字符串是按照其的值进行排序,所以可以使用到这个索引进行排序,但是如果使用到了字符串的后缀,就不能使用到这个索引了.</p><p><strong>精确匹配某一列并范围匹配另外一列</strong></p><p>对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找.</p><p><strong>用于排序</strong></p><p>使用ORDER BY子句按照某种规则进行排序时,一般情况下，我们只能把记录都加载到内存中(或者文件做暂存)，通过排序算法对其进行排序，然后再返回给客户端。</p><p>但是如果ORDER BY子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤,直接输出排序结果</p><p><strong>用于分组</strong></p><p>然后针对那些分组进行统计，比如在我们这个查询语句中就是统计每个分组包含的记录条数。如果没有索引的话，这个分组过程全部需要在内存里实现，而如果有了索引的话，恰巧这个分组顺序又和我们的B+树中的索引列的顺序是一致的，而我们的B+树索引又是按照索引列排好序的，这不正好么，所以可以直接使用B+树索引进行分组。</p><h3 id="使用索引的总结"><a href="#使用索引的总结" class="headerlink" title="使用索引的总结"></a>使用索引的总结</h3><p>能不能使用索引关键在于查询的列是否是索引的一部分,同时其排序与索引结构相同.那么就可以使用索引，如果不是索引的一部分，那么就不能使用索引。</p><h3 id="回表的代价"><a href="#回表的代价" class="headerlink" title="回表的代价"></a>回表的代价</h3><p>回表的代价是非常高的，因为回表的过程需要再次访问数据页，而且还需要再次访问数据页中的目录项记录，这个过程需要进行两次磁盘IO操作，所以回表的代价是非常高的。</p><p>在mysql中有<strong>查询优化器</strong>,查询优化器会事先对表中的记录计算一些统计数据,然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数,需要回表的记录数越多，就越倾向于使用全表扫描,反之倾向于使用二级索引 + 回表的方式.</p><p>为了彻底告别回表操作带来的性能损耗，我们最好在查询列表里只包含索引列.</p><h2 id="如何建立索引"><a href="#如何建立索引" class="headerlink" title="如何建立索引"></a>如何建立索引</h2><p><strong>只为用于搜索、排序或分组的列创建索引</strong></p><p>只为出现在WHERE子句中的列、连接子句中的连接列，或者出现在ORDER BY或GROUP BY子句中的列创建索引。</p><p><strong>考虑列的基数</strong></p><p>列的基数指的是某一列中不重复数据的个数,其中基数越大,索引的效果越好.因为当基数小的时候,数的离散程度越小,在排序的时候,需要进行的比较次数越少多,所以效率越低.</p><p><strong>索引列的类型尽量小</strong></p><ul><li><p>数据类型越小，在查询时进行的比较操作越快（这是CPU层次的东东）</p></li><li><p>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I&#x2F;O带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</p></li></ul><p><strong>索引字符串值的前缀</strong></p><p>原因同上,对于字符串只存储前缀,可以减少索引的大小,从而减少磁盘I&#x2F;O带来的性能损耗.</p><p><strong>让索引列在比较表达式中单独出现</strong></p><p>如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。</p><p><strong>主键插入顺序</strong></p><p>当向项中间插入一个页面时候,如果该页面已经存满,此时会发生页面分裂和记录移位,此时就会发生性能损耗.因此最好将主键设置为自动递增的形式</p><p><strong>减少冗余索引</strong></p><p>给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。</p>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法设计课程期末考试笔记</title>
    <link href="/2023/06/28/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/06/28/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="逆序对计算的分治算法"><a href="#逆序对计算的分治算法" class="headerlink" title="逆序对计算的分治算法"></a>逆序对计算的分治算法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 逆序对计算的分治算法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">count_inversions_dc</span>(<span class="hljs-params">A</span>):<br>    lenA = <span class="hljs-built_in">len</span>(A)<br>    <span class="hljs-keyword">if</span> lenA &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, A<br>    middle = lenA // <span class="hljs-number">2</span><br>    leftA = A[:middle]<br>    rightA = A[middle:]<br>    countLA, leftA = count_inversions_dc(leftA)<br>    countRA, rightA = count_inversions_dc(rightA)<br>    countLRA, mergedA = mac(leftA, rightA)<br><br>    <span class="hljs-keyword">return</span> countLA + countRA + countLRA, mergedA<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mac</span>(<span class="hljs-params">A, B</span>):<br>    i, j, count = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    alist = []<br>    lenA = <span class="hljs-built_in">len</span>(A)<br>    lenB = <span class="hljs-built_in">len</span>(B)<br>    <span class="hljs-keyword">while</span> i &lt; lenA <span class="hljs-keyword">and</span> j &lt; lenB:<br>        <span class="hljs-keyword">if</span> A[i] &lt; B[j]:<br>            alist.append(A[i])<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            count += lenA - i<br>            alist.append(B[j])<br>            j += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> i &lt; lenA:<br>        alist.append(A[i])<br>        i += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> j &lt; lenB:<br>        alist.append(B[j])<br>        j += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> count, alist<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    a = [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<br>    c, b = count_inversions_dc(a)<br>    <span class="hljs-built_in">print</span>(c, b)<br><br></code></pre></td></tr></table></figure><h1 id="硬币找零的贪心算法"><a href="#硬币找零的贪心算法" class="headerlink" title="硬币找零的贪心算法"></a>硬币找零的贪心算法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gmc</span>(<span class="hljs-params">amt</span>):<br>    coin = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">25</span>, <span class="hljs-number">100</span>]<br>    cl = []<br>    sc = <span class="hljs-built_in">sorted</span>(coin, reverse=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">for</span> cv <span class="hljs-keyword">in</span> sc:<br>        cc = <span class="hljs-built_in">int</span>(amt / cv)<br>        cl += [cv, ] * cc<br>        amt -= cv * cc<br>        <span class="hljs-keyword">if</span> amt &lt;= <span class="hljs-number">0.0</span>:<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> cl<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(gmc(<span class="hljs-number">38</span>))<br></code></pre></td></tr></table></figure><h1 id="连续子序列和最大值动态规划算法"><a href="#连续子序列和最大值动态规划算法" class="headerlink" title="连续子序列和最大值动态规划算法"></a>连续子序列和最大值动态规划算法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">zxlmax</span>(<span class="hljs-params">alist</span>):<br>    table = [<span class="hljs-number">0</span>] * (<span class="hljs-built_in">len</span>(alist) + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(alist) + <span class="hljs-number">1</span>):<br>        table[i] = <span class="hljs-built_in">max</span>(table[i - <span class="hljs-number">1</span>] + alist[i - <span class="hljs-number">1</span>], alist[i-<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> table<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tbs</span>(<span class="hljs-params">alist, table</span>):<br>    <span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>    select = []<br>    max_sum = <span class="hljs-built_in">max</span>(table)<br>    ind_max = np.argmax(table)<br>    <span class="hljs-keyword">while</span> ind_max &gt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">if</span> table[ind_max] == alist[ind_max - <span class="hljs-number">1</span>] + table[ind_max - <span class="hljs-number">1</span>]:<br>            select.append(alist[ind_max - <span class="hljs-number">1</span>])<br>            ind_max -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            select.append(alist[ind_max - <span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> select<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    a = [<span class="hljs-number">2</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>, <span class="hljs-number">13</span>, -<span class="hljs-number">5</span>]<br>    table = zxlmax(a)<br>    s=tbs(a,table)<br>    <span class="hljs-built_in">print</span>(s, table)<br><br></code></pre></td></tr></table></figure><h1 id="矩阵连乘最优结合问题"><a href="#矩阵连乘最优结合问题" class="headerlink" title="矩阵连乘最优结合问题"></a>矩阵连乘最优结合问题</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">gk = <span class="hljs-keyword">lambda</span> i,j :<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&#x27;,&#x27;</span>+<span class="hljs-built_in">str</span>(j)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mmc</span>(<span class="hljs-params">p</span>):<br>    n=<span class="hljs-built_in">len</span>(p)-<span class="hljs-number">1</span><br>    m=&#123;&#125;<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (i,n+<span class="hljs-number">1</span>):<br>            m[gk(i,j)]=<span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>)<br>    <span class="hljs-keyword">return</span> lc(m,p,<span class="hljs-number">1</span>,n)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lc</span>(<span class="hljs-params">m,p,i,j</span>):<br>    <span class="hljs-keyword">if</span> m[gk(i,j)]&lt;<span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>):<br>        <span class="hljs-keyword">return</span> m[gk(i,j)]<br>    <span class="hljs-keyword">if</span> i==j :<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i,j):<br>            q=lc(m,p,i,k)+lc(m,p,k+<span class="hljs-number">1</span>,j)+p[i-<span class="hljs-number">1</span>]*p[k]*p[j]<br>        <span class="hljs-keyword">if</span> q&lt; m[gk(i,j)]:<br>            m[gk(i,j)]=q<br>    <span class="hljs-keyword">return</span> m[gk(i,j)]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    p=[<span class="hljs-number">30</span>,<span class="hljs-number">35</span>,<span class="hljs-number">15</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">25</span>]<br>    <span class="hljs-built_in">print</span>(gk(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<br>    <span class="hljs-built_in">print</span>(mmc(p))<br></code></pre></td></tr></table></figure><h1 id="二维0-1背包问题"><a href="#二维0-1背包问题" class="headerlink" title="二维0-1背包问题"></a>二维0-1背包问题</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bb</span>(<span class="hljs-params">W,wt,val,n</span>):<br>    K=[[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(W+<span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (n+<span class="hljs-number">1</span>)]<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (n+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(W+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> w==<span class="hljs-number">0</span>:<br>                K[i][w]=<span class="hljs-number">0</span><br>            <span class="hljs-keyword">elif</span> wt[i-<span class="hljs-number">1</span>]&lt;=w:<br>                K[i][w]=<span class="hljs-built_in">max</span>(val[i-<span class="hljs-number">1</span>]+K[i-<span class="hljs-number">1</span>][w-wt[i-<span class="hljs-number">1</span>],K[i-<span class="hljs-number">1</span>][w]])<br>            <span class="hljs-keyword">else</span>:<br>                K[i][w]=K[i-<span class="hljs-number">1</span>][w]<br>    <span class="hljs-keyword">return</span> K<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">aa</span>(<span class="hljs-params">w,wt,val,n</span>):<br>    <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> w==<span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> wt[n-<span class="hljs-number">1</span>]&gt;w:<br>        <span class="hljs-keyword">return</span> aa(w,wt,val,n-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(val[n-<span class="hljs-number">1</span>]+aa(w-wt[n-<span class="hljs-number">1</span>],wt,val,n-<span class="hljs-number">1</span>),aa(w,wt,val,n-<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><h1 id="间隔任务规划"><a href="#间隔任务规划" class="headerlink" title="间隔任务规划"></a>间隔任务规划</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gmi</span>(<span class="hljs-params">joblist</span>):<br>    js=[]<br>    nj=<span class="hljs-built_in">len</span>(joblist)<br>    joblist.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">2</span>])<br>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nj):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> js:<br>            js.append(joblist[n])<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> js[-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]&lt;joblist[n][<span class="hljs-number">1</span>]:<br>                js.append(joblist[n])<br>    <span class="hljs-keyword">return</span> js<br><br></code></pre></td></tr></table></figure><h1 id="求最大岛屿问题"><a href="#求最大岛屿问题" class="headerlink" title="求最大岛屿问题"></a>求最大岛屿问题</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python">dx = [<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br>dy = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br>vis = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>)] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>)]<br>res = <span class="hljs-number">0</span><br>ans = <span class="hljs-number">0</span><br>graph = [[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],<br>         [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],<br>         [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>         [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>         [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>         [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>         [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>], ]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x, y</span>):<br>    flag = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">global</span> res<br>    <span class="hljs-keyword">global</span> ans<br>    <span class="hljs-keyword">global</span> graph<br>    <span class="hljs-keyword">global</span> dx<br>    <span class="hljs-keyword">global</span> dy<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>):<br>        tox = x + dx[i]<br>        toy = y + dy[i]<br>        <span class="hljs-keyword">if</span> tox &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> tox &gt; <span class="hljs-number">6</span> <span class="hljs-keyword">or</span> toy &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> toy &gt; <span class="hljs-number">6</span>:<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> vis[tox][toy] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> graph[tox][toy]:<br>            vis[tox][toy] = <span class="hljs-number">1</span><br>            ans = ans + <span class="hljs-number">1</span><br>            dfs(tox, toy)<br>    <span class="hljs-keyword">return</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>):<br>            <span class="hljs-keyword">if</span> graph[i][j] == <span class="hljs-number">1</span>:<br>                vis[i][j] = <span class="hljs-number">1</span><br>                ans = <span class="hljs-number">1</span><br>                dfs(i, j)<br>                res = <span class="hljs-built_in">max</span>(res, ans)<br>    <span class="hljs-built_in">print</span>(res)<br><br></code></pre></td></tr></table></figure><h1 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pdb<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Place</span>(<span class="hljs-params">k</span>):<br>    <span class="hljs-comment"># 注意：k从索引0开始</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(k - j) == <span class="hljs-built_in">abs</span>(rect[k] - rect[j]) <span class="hljs-keyword">or</span> rect[k] == rect[j]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">QueensLV</span>(<span class="hljs-params">n</span>):  <span class="hljs-comment"># 返回一个bool值，得到解返回True，否则False</span><br>    k = <span class="hljs-number">0</span>  <span class="hljs-comment"># 第一个索引为0</span><br>    rect[k] = random.randint(<span class="hljs-number">0</span>, n)<br>    <span class="hljs-keyword">while</span> (Place(k)):<br>        <span class="hljs-keyword">if</span> k == n - <span class="hljs-number">1</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;八皇后问题的一个解为：&#x27;</span>, rect)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        k += <span class="hljs-number">1</span><br>        rect[k] = random.randint(<span class="hljs-number">0</span>, n)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    n = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入皇后数量：&#x27;</span>)<br>    n = <span class="hljs-built_in">int</span>(n)<br>    rect = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;输入的棋盘：&#x27;</span>, rect)<br>    errorcount = <span class="hljs-number">0</span>  <span class="hljs-comment"># 失败次数</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">not</span> QueensLV(n)):<br>        errorcount += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;共尝试了&#123;&#125;次放置皇后的位置&#x27;</span>.<span class="hljs-built_in">format</span>(errorcount))<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL InnoDB存储引擎</title>
    <link href="/2023/06/19/MySQL-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <url>/2023/06/19/MySQL-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h1><h2 id="存储引擎的概念"><a href="#存储引擎的概念" class="headerlink" title="存储引擎的概念"></a>存储引擎的概念</h2><p>MySQL服务器把数据的存储和提取操作都封装到了一个叫存储引擎的模块里。为了实现不同的功能，MySQL提供了各式各样的存储引擎，不同存储引擎管理的表具体的存储结构可能不同，采用的存取算法也可能不同。</p><p>为了管理方便，人们把连接管理、查询缓存、语法解析、查询优化这些并不涉及真实数据存储的功能划分为MySQL server的功能，把真实存取数据的功能划分为存储引擎的功能。各种不同的存储引擎向上边的MySQL server层提供统一的调用接口实现。</p><h2 id="常用存储引擎"><a href="#常用存储引擎" class="headerlink" title="常用存储引擎"></a>常用存储引擎</h2><p><img src="https://pic.liahnu.top/img/202306190246424.png"></p><p>在此之中，最常用的是InnoDB和MyISAM，InnoDB是MySQL的默认存储引擎。</p><h1 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>InnoDB是一个将表中的数据存储到磁盘上的存储引擎。众所周知，磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时，InnoDB存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死，InnoDB采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16 KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。</p><h2 id="InnoDB行格式"><a href="#InnoDB行格式" class="headerlink" title="InnoDB行格式"></a>InnoDB行格式</h2><p>我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为行格式或者记录格式。目前InnoDB存储引擎的有4种不同类型的行格式，分别是Compact、Redundant、Dynamic和Compressed行格式。</p><h3 id="Compact行格式"><a href="#Compact行格式" class="headerlink" title="Compact行格式"></a>Compact行格式</h3><p><img src="https://pic.liahnu.top/img/202306191927854.png"></p><p>Compact行格式分为，记录的额外信息和记录的真实数据两大部分。</p><h4 id="记录的额外信息"><a href="#记录的额外信息" class="headerlink" title="记录的额外信息"></a>记录的额外信息</h4><p>记录的额外信息包括：变长字段长度列表、NULL列列表、记录头信息。</p><p><strong>变长字段长度列表</strong></p><p>变长字段长度列表是一个按照列顺序记录的变长字段的长度列表，每个长度占用1或2个字节，1个字节表示长度小于等于255，2个字节表示长度大于255。</p><p>这个列表的作用是：当我们要获取某条记录的某个变长字段时（例如VARCHAR），其存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。通过这样，形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放。</p><p>另外需要注意的一点是，变长字段长度列表中只存储值为 非NULL 的列内容占用的长度，值为 NULL 的列的长度是不储存的 。</p><p><strong>NULL列列表</strong></p><p>NULL列列表是一个按照列顺序记录的NULL列的列表，每个NULL列占用1个字节，1个字节表示有NULL值，0个字节表示没有NULL值。</p><p>这个列表的作用是：当我们要获取某条记录的某个列时，我们可以通过这个列表快速的定位到该列是否有NULL值。这样可以减少<code>记录的真实数据</code> 存储的空间。</p><p><strong>记录头信息</strong></p><p>记录头信息是由固定的5个字节组成。5个字节也就是40个二进制位，不同的位代表不同的意思</p><p><img src="https://pic.liahnu.top/img/202306191938103.png"></p><h4 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h4><p>记录的真实数据是由各个列的数据组成的，每个列的数据占用的字节数是固定的，不会因为数据的实际长度而改变。</p><p>记录的真实数据除了我们自己定义的列的数据以外，MySQL会为每个记录默认的添加一些列（也称为隐藏列），具体的列如下：</p><p><img src="https://pic.liahnu.top/img/202306201654028.png"></p><p>实际记录的格式如下</p><p><img src="https://pic.liahnu.top/img/202306201657516.png"></p><h3 id="Redundant行格式"><a href="#Redundant行格式" class="headerlink" title="Redundant行格式"></a>Redundant行格式</h3><p><img src="https://pic.liahnu.top/img/202306211215814.png"></p><p>Compact行格式的开头是变长字段长度列表，而Redundant行格式的开头是字段长度偏移列表，与变长字段长度列表有两处不同：</p><p>没有了变长两个字，意味着Redundant行格式会把该条记录中所有列（包括隐藏列）的长度信息都按照逆序存储到字段长度偏移列表。</p><p>多了个偏移两个字，这意味着计算列值长度的方式不像Compact行格式那么直观，它是采用两个相邻数值的差值来计算各个列值的长度。</p><h4 id="Redundant行格式中的char类型"><a href="#Redundant行格式中的char类型" class="headerlink" title="Redundant行格式中的char类型"></a>Redundant行格式中的char类型</h4><p>Compact行格式在CHAR(M)类型时，分变长字符集和定长字符集的情况，而在Redundant行格式中，只要是使用CHAR(M)类型，占用的真实数据空间就是该字符集表示一个字符最多需要的字节数和M的乘积。比方说使用utf8字符集的CHAR(10)类型的列占用的真实数据空间始终为30个字节，使用gbk字符集的CHAR(10)类型的列占用的真实数据空间始终为20个字节。由此可以看出来，使用Redundant行格式的CHAR(M)类型的列是不会产生碎片的。</p><h3 id="Dynamic和Compressed行格式"><a href="#Dynamic和Compressed行格式" class="headerlink" title="Dynamic和Compressed行格式"></a>Dynamic和Compressed行格式</h3><p>这俩行格式和Compact行格式很像，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。</p><h1 id="InnoDB的索引页结构"><a href="#InnoDB的索引页结构" class="headerlink" title="InnoDB的索引页结构"></a>InnoDB的索引页结构</h1><p>页是InnoDB管理存储空间的基本单位，一个页的大小一般是16KB。InnoDB为了不同的目的而设计了许多种不同类型的页，比如存放表空间头部信息的页，存放Insert Buffer信息的页，存放INODE信息的页，存放undo日志信息的页等等。表中记录的那种类型的页叫做索引（INDEX）页。</p><h2 id="页的结构"><a href="#页的结构" class="headerlink" title="页的结构"></a>页的结构</h2><p>InnoDb主要分为以下七个部分，下面是其相关的介绍。</p><p><img src="https://pic.liahnu.top/img/202306301545053.png"></p><h3 id="记录在页中的存储"><a href="#记录在页中的存储" class="headerlink" title="记录在页中的存储"></a>记录在页中的存储</h3><p>在页的7个组成部分中，我们自己存储的记录会按照我们指定的行格式存储到User Records部分。</p><p><img src="https://pic.liahnu.top/img/202307030036212.png"></p><p>mysql的页会在创建的时候生成一个制定大小的Free Space空间；当增加行时候，尚未使用的存储空间中（Free Space）申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了。</p><h3 id="记录在页中的创建"><a href="#记录在页中的创建" class="headerlink" title="记录在页中的创建"></a>记录在页中的创建</h3><p>这里回到刚开始的，Compact行格式中的记录头信息。</p><p><img src="https://pic.liahnu.top/img/202306191938103.png" alt="记录头信息"></p><p>Mysql在创建一个新的页的时候，会自动创建两记录，分别为Infimum Supremum，分别代表最大记录和最小记录。这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成（对应参数）。</p><p>它们并不存放在页的User Records部分，他们被单独放在一个称为Infimum + Supremum的部分。</p><p><img src="https://pic.liahnu.top/img/202307030050368.png"></p><p>在创建了这两条记录之后，我们自己的记录就可以被插入到页的User Records部分了。其中，记录会按照主键的顺序插入到页中，如果主键相同，那么会按照主键以外的唯一索引的顺序插入到页中。</p><p>我们自己的创建的记录会通过单链表的方式连接起来，这个单链表的头部就是Infimum记录，尾部就是Supremum记录。通过<code>next_record</code>指针可以找到下一条记录。<code>next_record</code>值代表与下一条记录的偏移量（实际指向<strong>记录头信息和真实数据之间的位置</strong>），如果<code>next_record</code>值为0，那么就代表这是最后一条记录。</p><div class="note note-success">            <p>因为这个位置对于数据和信息的位置正好，向左读取就是记录头信息，向右读取就是真实数据。</p>          </div><h3 id="记录在页中的删除"><a href="#记录在页中的删除" class="headerlink" title="记录在页中的删除"></a>记录在页中的删除</h3><p>删除一条记录主要有以下几个变化，如图所示：</p><p><img src="https://pic.liahnu.top/img/202307030056362.png"></p><ul><li>第二条记录并没有从存储空间中移除，而是把该条记录的delete_mask值设置为1。</li><li>第二条记录的next_record值变为了0，意味着该记录没有下一条记录了。</li><li>第一条记录的next_record指向了第3条记录。</li><li>最大记录的n_owned值从5变成了4</li></ul><p>主键值为2的记录被我们删掉了，但是存储空间却没有回收，如果我们再次把这条记录插入到表中，会发生什么事呢？</p><p>InnoDB并没有因为新记录的插入而为它申请新的存储空间，而是直接复用了原来被删除记录的存储空间。</p><p>当数据页中存在多条被删除掉的记录时，这些记录的next_record属性将会把这些被删除掉的记录组成一个垃圾链表，以备之后重用这部分存储空间。</p><h3 id="记录在页中的查找"><a href="#记录在页中的查找" class="headerlink" title="记录在页中的查找"></a>记录在页中的查找</h3><p>我们知道记录在页中是以单链表的形式存储的，那么我们如何通过主键值来查找记录呢？</p><p>在数据结构课上学过链表的查找。最为简单的查找是顺序查找。从Infimum记录（最小记录）开始，知道招到链表，但是这种方式显而易见，效率很低。</p><p>因此InnoDB引入了页目录（Page Directory）机制，通过这个来简化查找。</p><ul><li>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。</li><li>每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该记录拥有多少条记录，也就是该组内共有几条记录。</li><li>将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方，这个地方就是所谓的Page Directory，也就是页目录（此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为槽（英文名：Slot），所以这个页面目录就是由槽组成的。</li></ul><p><img src="https://pic.liahnu.top/img/202307030109220.png"></p><p><img src="https://pic.liahnu.top/img/202307030111124.png"></p><p>其中，对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1<del>8 条之间，剩下的分组中记录的条数范围只能在是 4</del>8 条之间。</p><p>通过这样的分组方式，我们就可以通过二分查找的方式来快速定位到我们想要的记录所在的分组，然后再通过顺序查找组的方式快速定位到我们想要的记录。</p><h3 id="Page-Header（页面头部）"><a href="#Page-Header（页面头部）" class="headerlink" title="Page Header（页面头部）"></a>Page Header（页面头部）</h3><p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，它是页结构的第二部分，这个部分占用固定的56个字节，专门存储各种状态信息。</p><p><img src="https://pic.liahnu.top/img/202307030128384.png"></p><h3 id="File-Header（文件头部）"><a href="#File-Header（文件头部）" class="headerlink" title="File Header（文件头部）"></a>File Header（文件头部）</h3><p>File Header描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁之类的信息，这个部分占用固定的38个字节</p><p><img src="https://pic.liahnu.top/img/202307030130410.png"></p><h3 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h3><p>每个页的尾部都加了一个File Trailer部分，用来校验页信息，这个部分由8个字节组成，可以分成2个小部分：</p><ul><li>前4个字节代表页的校验和</li></ul><p>这个部分是和File Header中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在File Header中的校验和就代表着已经修改过的页，而在File Trailer中的校验和代表着原先的页，二者不同则意味着同步中间出了错。</p><ul><li>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）</li></ul><p>这个File Trailer与File Header类似，都是所有类型的页通用的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><p>InnoDB为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做数据页。</p></li><li><p>InnoDB会把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个槽，存放在Page Directory中，所以在一个页中根据主键查找记录是非常快的，分为两步：通过二分法确定该记录所在的槽；通过记录的next_record属性遍历该槽所在的组中的各个记录。</p></li><li><p>每个数据页的File Header部分都有上一个和下一个页的编号，所以所有的数据页会组成一个双链表。</p></li><li><p>为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的LSN值，如果首部和尾部的校验和和LSN值校验不成功的话，就说明同步过程出现了问题。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2023/05/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/05/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式的目的是帮助我们编写可复用的代码，提高代码的耦合性。降低对其他组件的修改</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/the-relationship-between-design-patterns.jpg"></p><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><p>通过构造一个迭代器来实现对元素的遍历操作</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在java中可以使用util中提供的<code>Iterator&lt;?&gt;</code>接口实现，主要为 hasnext与next方法，分别判断迭代器是否有下一个和获取下一个元素。</p><p>其实java中 拓展for使用使用了迭代器模式，c++中同样存在迭代器for遍历。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>引入迭代器后，可以使遍历与实现分离开，不暴露该对象的内部表示。</li></ol><h1 id="Adapter模式-（适配器模式）"><a href="#Adapter模式-（适配器模式）" class="headerlink" title="Adapter模式 （适配器模式）"></a>Adapter模式 （适配器模式）</h1><p>Adapter模式又称为Wrapper模式，其设计模式的目的是实现两个对象间的互相转换，主要有以下两种</p><ol><li>类适配器模式</li><li>对象适配器模式</li></ol><h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><p>类适配器模式是实现类与接口间实现对接的方式。通过中间类 Banner 类继承对象和实现接口的相关功能实现</p><p><img src="https://pic.liahnu.top/img/202305082019449.png"></p><h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><p>对象适配器模式是实现对类与类间实现对接的方式。由于java中只能单继承，通过中间类 Banner 类继承一个类和保存对象，实现对数据处理的转交。</p><p><img src="https://pic.liahnu.top/img/202305082020330.png"></p><h1 id="Template-Method-模式-（模板方式模式）"><a href="#Template-Method-模式-（模板方式模式）" class="headerlink" title="Template Method 模式 （模板方式模式）"></a>Template Method 模式 （模板方式模式）</h1>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成与设计-第二章-笔记</title>
    <link href="/2023/04/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/04/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="2-1-引言"><a href="#2-1-引言" class="headerlink" title="2.1 引言"></a>2.1 引言</h1><p>计算机语言中的单词称为<strong>指令</strong>，其词汇表称为<strong>指令系统</strong></p><h2 id="RISV-V-指令系统"><a href="#RISV-V-指令系统" class="headerlink" title="RISV-V 指令系统"></a>RISV-V 指令系统</h2><p><img src="https://pic.liahnu.top/img/202304280111811.png" alt="RISV-V 汇编语言 表一"></p><p><img src="https://pic.liahnu.top/img/202304280113631.png" alt="RISV-V 汇编语言 表二"></p><p><a href="http://riscvbook.com/chinese/RISC-V-Reader-Chinese-v2p1.pdf">做pa时候的risv32参考手册</a></p><h1 id="2-2-计算机硬件的操作"><a href="#2-2-计算机硬件的操作" class="headerlink" title="2.2 计算机硬件的操作"></a>2.2 计算机硬件的操作</h1><p>下面就是一个基础的risv指令，固定使用三个变量进行操作；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">add a, b, c<br></code></pre></td></tr></table></figure><p><strong>设计原则1 ：简单源于规整</strong></p><p>操作数数量可变的硬件比固定数拭的硬件更复杂。</p><p>riscv指令主要包含一下几几种指令</p><h1 id="2-3-计算机硬件的操作数"><a href="#2-3-计算机硬件的操作数" class="headerlink" title="2.3 计算机硬件的操作数"></a>2.3 计算机硬件的操作数</h1><p>在RISC-V 体系结构中，寄存器的大小为64 位；成组的64 位频繁出现，因此它们在RISC-V 体系结构中被命名为双字。（另一个常见大小是成组的32位，在RISC-V 体系结构中称为字。）</p><p>相较于变量，在RISC-V处理器中，寄存器数量优先，在当前RISC-V 等计算机上通常为32 个寄存器。</p><p><strong>设计原则2 ：更少则更快</strong></p><p>数量过多的寄存器可能会增加时钟周期，因为电信号传输的距离越远，所花<br>费的时间就越长。</p><h2 id="2-3-1-存储器操作数"><a href="#2-3-1-存储器操作数" class="headerlink" title="2.3.1 存储器操作数"></a>2.3.1 存储器操作数</h2><p>RISC-V 指令中的算术运算只作用于寄存器，因此，RISC-V 必须包含在内存和寄存器之间传输数据的指令。这些指令称为数据传输指令。</p><p>将数据从内存复制到寄存器的数据传输指令通常称为载入指令ld(load);<br>将数据从寄存器复制到内存的数据传输指令通常称为存储指令lw(store);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">ld x9, 8(x22) // 8(x22) 指相对于x22地址，有8个偏移<br><br></code></pre></td></tr></table></figure><p>计算机分为两种， 一种使用最左边或“ 大端”字节的地址作为双字地址，另一种使用最右端或“小端” 字节的地址作为双字地址。RISC-V 属于后者，称为小端编址。由于仅在以双字形式和八个单独字节访问相同数据时， 字节顺序才会有影响， 因此大多数情况下不需要关心”大小端”。</p><h2 id="2-3-2-常数或立即数操作数"><a href="#2-3-2-常数或立即数操作数" class="headerlink" title="2.3.2 常数或立即数操作数"></a>2.3.2 常数或立即数操作数</h2><p>程序经常会在一次操作中用到常数，下列是一些常数指令</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">addi <span class="hljs-keyword">x</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-keyword">x</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>计算机组成与设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>南大 pa2</title>
    <link href="/2023/04/23/%E5%8D%97%E5%A4%A7-pa2/"/>
    <url>/2023/04/23/%E5%8D%97%E5%A4%A7-pa2/</url>
    
    <content type="html"><![CDATA[<h1 id="理解YEMU如何执行程序"><a href="#理解YEMU如何执行程序" class="headerlink" title="理解YEMU如何执行程序"></a>理解YEMU如何执行程序</h1><div class="note note-warning">            <p>YEMU可以看成是一个简化版的NEMU, 它们的原理是相通的, 因此你需要理解YEMU是如何执行程序的. 具体地, 你需要画出在YEMU上执行的加法程序的状态机<br>通过RTFSC理解YEMU如何执行一条指令<br>思考一下, 以上两者有什么联系?</p>          </div><p>YEMU执行指令通过 取值-&gt;译码-&gt;执行-&gt;更新pc操作. 首先从M(内存)中取出一条指令,通过操作码判断所属于的指令类型,然后读取指令内容并更新寄存器执行,最后更新pc指针+1，指向内存中的下1字节数据，通过while(true)指令来实现不断循环。</p><p>状态机不想画了（）</p><h1 id="RTFSC理解指令执行的过程"><a href="#RTFSC理解指令执行的过程" class="headerlink" title="RTFSC理解指令执行的过程"></a>RTFSC理解指令执行的过程</h1><div class="note note-warning">            <p>这一小节的细节非常多, 你可能需要多次阅读讲义和代码才能理解每一处细节. 根据往届学长学姐的反馈, 一种有效的理解方法是通过做笔记的方式来整理这些细节. 事实上, 配合GDB食用效果更佳.</p><p>为了避免你长时间对代码的理解没有任何进展, 我们就增加一道必答题吧:</p><p>请整理一条指令在NEMU中的执行过程.</p><p>除了nemu&#x2F;src&#x2F;device和nemu&#x2F;src&#x2F;isa&#x2F;$ISA&#x2F;system之外, NEMU的其它代码你都已经有能力理解了. 因此不要觉得讲义中没有提到的文件就不需要看, 尝试尽可能地理解每一处细节吧! 在你遇到bug的时候, 这些细节就会成为帮助你调试的线索.</p>          </div><p>指令执行过程类似于YEMU。首先NEMU从内存中读取一条指令数据，然后对对指令中的操作码和操作数依次进行译码。在指令译码阶段结束后，NEMU会执行代码，运用rtl语句，从而完成指令语义层面上的逻辑行为。最后，只需把下一条动态PC赋值给PC即可完成一次指令执行循环。</p><h1 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h1><p>在运行navtic时候报错<br>error: variably modified ‘sigstack’ at file scope</p><p>这个原因是因为版本库更新，数组中的数字不再是常量。</p><p><a href="https://stackoverflow.com/questions/69719688/buildroot-error-when-building-with-ubuntu-21-10/69722830#69722830">https://stackoverflow.com/questions/69719688/buildroot-error-when-building-with-ubuntu-21-10/69722830#69722830</a></p><p>解决方法，手动改为8192</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint8_t</span> sigstack[<span class="hljs-number">8192</span>];<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>校园内vpn模拟登录</title>
    <link href="/2023/04/23/%E6%A0%A1%E5%9B%AD%E5%86%85vpn%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/"/>
    <url>/2023/04/23/%E6%A0%A1%E5%9B%AD%E5%86%85vpn%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用学校webvpn时候，访问内网地址被加密为一串字符串，</p><p>例如：<a href="https://webvpn.gdou.edu.cn/http/77726476706e69737468656265737421a1a70fce77602606305adcf9/">https://webvpn.gdou.edu.cn/http/77726476706e69737468656265737421a1a70fce77602606305adcf9/</a></p><h1 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h1><p>通过前端js代码，可以很清楚的找到加密函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> textRightAppend = <span class="hljs-keyword">function</span> (<span class="hljs-params">text, mode</span>) &#123;<br>    <span class="hljs-keyword">var</span> segmentByteSize = mode === <span class="hljs-string">&#x27;utf8&#x27;</span> ? <span class="hljs-number">16</span> : <span class="hljs-number">32</span><br><br>    <span class="hljs-keyword">if</span> (text.<span class="hljs-property">length</span> % segmentByteSize === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> text<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> appendLength = segmentByteSize - text.<span class="hljs-property">length</span> % segmentByteSize<br>    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> (i++ &lt; appendLength) &#123;<br>        text += <span class="hljs-string">&#x27;0&#x27;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> text<br>&#125;<br><br><span class="hljs-keyword">var</span> encrypt = <span class="hljs-keyword">function</span> (<span class="hljs-params">text, key, iv</span>) &#123;<br>    <span class="hljs-keyword">var</span> textLength = text.<span class="hljs-property">length</span><br>    text = <span class="hljs-title function_">textRightAppend</span>(text, <span class="hljs-string">&#x27;utf8&#x27;</span>)<br>    <span class="hljs-keyword">var</span> keyBytes = utf8.<span class="hljs-title function_">toBytes</span>(key)<br>    <span class="hljs-keyword">var</span> ivBytes = utf8.<span class="hljs-title function_">toBytes</span>(iv)<br>    <span class="hljs-keyword">var</span> textBytes = utf8.<span class="hljs-title function_">toBytes</span>(text)<br>    <span class="hljs-keyword">var</span> aesCfb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AesCfb</span>(keyBytes, ivBytes, <span class="hljs-number">16</span>)<br>    <span class="hljs-keyword">var</span> encryptBytes = aesCfb.<span class="hljs-title function_">encrypt</span>(textBytes)<br>    <span class="hljs-keyword">return</span> hex.<span class="hljs-title function_">fromBytes</span>(ivBytes) + hex.<span class="hljs-title function_">fromBytes</span>(encryptBytes).<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, textLength * <span class="hljs-number">2</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 key &#x3D; “wrdvpnisthebest!” iv &#x3D; “wrdvpnisthebest!” 默认参数</p><p>加密方式根据函数猜测为Aes加密，模式为cfb方式</p>]]></content>
    
    
    
    <tags>
      
      <tag>协议分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github page 自动部署服务器</title>
    <link href="/2023/04/22/github-page-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2023/04/22/github-page-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>这个博客是同时部署在<a href="https://1328411791.github.io/">github page</a> 和 <a href="https://www.liahnu.top/">我自己的服务器</a>上，通常在更新博客内容时，会产生数据同步问题。即使用<code>hexo d</code>指令后，上传到 Github page 仓库，不同时更新自己服务器上的内容。在更新完成仓库后，需要手动登录服务器进行拉取仓库。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>首先，在上传到github仓库时，所产生的网页文件已经是被打包好的了，因此在部署到服务器只需要拉取仓库。因此，可以使用github中Webhooks功能来拉取更新时候的代码。</p><h2 id="Webhooks是什么"><a href="#Webhooks是什么" class="headerlink" title="Webhooks是什么"></a>Webhooks是什么</h2><p>Webhook 允许在某些事件发生时通知外部服务。当指定的事件发生时，我们将向您提供的每个 URL 发送一个 POST 请求。</p><h2 id="启动github-webhook"><a href="#启动github-webhook" class="headerlink" title="启动github webhook"></a>启动github webhook</h2><p>在github的设置页设置webhook参数</p><p><img src="https://pic.liahnu.top/img/202304221908717.png"></p><h2 id="编写sh脚本处理post请求"><a href="#编写sh脚本处理post请求" class="headerlink" title="编写sh脚本处理post请求"></a>编写sh脚本处理post请求</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># 启动 HTTP 监听服务</span><br>nc -l 7000 | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line<br><span class="hljs-keyword">do</span><br>    <span class="hljs-comment"># 检查是否为 POST 请求</span><br>    <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$line</span>&quot;</span> == <span class="hljs-string">&quot;POST&quot;</span>* ]]<br>    <span class="hljs-keyword">then</span><br>        <span class="hljs-comment"># 返回 OK 响应</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;HTTP/1.1 200 OK&quot;</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Content-Length: 2&quot;</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;ok&quot;</span><br>    <br>        <span class="hljs-comment"># 执行 git pull 操作</span><br>        <span class="hljs-built_in">cd</span> /www/hexo/1328411791.GitHub.io/<br>        git pull origin<br><br><br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>这段代码这有基础的功能，没有对请求进行验证，同时也没有http返回状态和参数（shell不如py）</p><p>shell真不如py写脚本，下面是python的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> git<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/update&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>():<br>    <span class="hljs-comment"># github hook 辨别</span><br>    <span class="hljs-keyword">if</span>(request.headers.get(<span class="hljs-string">&#x27;X-GitHub-Hook-ID&#x27;</span>) != <span class="hljs-string">&quot;11&quot;</span>):<br>        <span class="hljs-keyword">return</span> json.dumps(&#123;<span class="hljs-string">&#x27;msg&#x27;</span>: <span class="hljs-string">&#x27;Not a valid github hook&#x27;</span>&#125;)<br>    repo = git.Repo(<span class="hljs-string">&#x27;/path/to/repo&#x27;</span>)<br>    <span class="hljs-comment"># 更新本地仓库</span><br>    origin = repo.remotes.origin<br>    <span class="hljs-comment"># 删除本地仓库</span><br>    repo.git.reset(<span class="hljs-string">&#x27;--hard&#x27;</span>)<br>    <span class="hljs-comment"># 拉取远程仓库内容到本地仓库</span><br>    origin.pull(<span class="hljs-string">&quot;master&quot;</span>)<br>    <span class="hljs-comment"># 输出更新日志  </span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Updated PythonAnywhere source to commit &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">str</span>(repo.head.commit))) <br>    ret = &#123;<span class="hljs-string">&#x27;msg&#x27;</span>: <span class="hljs-string">&#x27;Updated PythonAnywhere source to commit &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">str</span>(repo.head.commit))&#125;<br>    <span class="hljs-keyword">return</span> ret<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run(host= <span class="hljs-string">&#x27;0.0.0.0&#x27;</span>,port= <span class="hljs-number">4000</span>, debug=<span class="hljs-literal">True</span>)<br><br></code></pre></td></tr></table></figure><p>安装对应的依赖，代码仅供参考</p><p>写完后,发送测试请求，发现成功被接收</p><p><img src="https://pic.liahnu.top/img/202304221909827.png"></p><p>下面将脚本进行后台运行即可</p><p>nohup 命令可以用来处理脚本后台运行，将输出重定向到log文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> ./update.sh &gt; ./log 2&gt;&amp;1 &amp; <br></code></pre></td></tr></table></figure><p>查看log 发现代码被正确拉取</p><p><img src="https://pic.liahnu.top/img/202304221912578.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>博客，部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线段树入门</title>
    <link href="/2023/03/28/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/"/>
    <url>/2023/03/28/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。</p><p>线段树是中常用的用来维护区间信息的数据结构。对于其每一个子节点而言，都表示整个序列中的一段子区间；对于每个叶子节点而言，都表示序列中的单个元素信息；子节点不断向自己的父亲节点传递信息，而父节点存储的信息则是他的每一个子节点信息的整合。</p><h2 id="线段树的基本形态"><a href="#线段树的基本形态" class="headerlink" title="线段树的基本形态"></a>线段树的基本形态</h2><p>线段树每个区间所管理的关系图<br><img src="https://pic.liahnu.top/img/202303290823030.png" alt="线段树关系图"></p><h2 id="线段树的构建"><a href="#线段树的构建" class="headerlink" title="线段树的构建"></a>线段树的构建</h2><p>我们可以通过递归的方式构建出一棵二叉树。参考代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-comment">// 对 [s,t] 区间建立线段树,当前根的编号为 p</span><br>  <span class="hljs-keyword">if</span> (s == t) &#123; <br>    <span class="hljs-comment">// s==t时候，说明为叶子节点</span><br>    d[p] = a[s];<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 去s-t的中点分割</span><br>  <span class="hljs-comment">// 移位运算符的优先级小于加减法，所以加上括号</span><br>  <span class="hljs-comment">// 如果写成 (s + t) &gt;&gt; 1 可能会超出 int 范围</span><br>  <span class="hljs-built_in">build</span>(s, m, p * <span class="hljs-number">2</span>), <span class="hljs-built_in">build</span>(m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 递归对左右区间建树</span><br>  d[p] = d[p * <span class="hljs-number">2</span>] + d[(p * <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线段树的区间查询"><a href="#线段树的区间查询" class="headerlink" title="线段树的区间查询"></a>线段树的区间查询</h2><p>再回到开头的图，你会发现，查询[1,10]之间的节点，只需要查询其根节点的值即可。</p><p>如果要查询的区间为 [3,5]，此时就不能直接获取区间的值，但是 [3,5] 可以拆成 [3,3] 和 [4,5]，可以通过合并这两个区间的答案来求得这个区间的答案。</p><p><img src="https://pic.liahnu.top/img/202303290823030.png" alt="线段树关系图"></p><p>参考代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-comment">// [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号</span><br>  <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r)<br>    <span class="hljs-keyword">return</span> d[p];  <span class="hljs-comment">// 当前区间为询问区间的子集时直接返回当前区间的和</span><br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>), sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (l &lt;= m) sum += <span class="hljs-built_in">getsum</span>(l, r, s, m, p * <span class="hljs-number">2</span>);<br>  <span class="hljs-comment">// 如果左儿子代表的区间 [s, m] 与询问区间有交集, 则递归查询左儿子</span><br>  <span class="hljs-keyword">if</span> (r &gt; m) sum += <span class="hljs-built_in">getsum</span>(l, r, m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 如果右儿子代表的区间 [m + 1, t] 与询问区间有交集, 则递归查询右儿子</span><br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线段树的区间修改与懒惰标记"><a href="#线段树的区间修改与懒惰标记" class="headerlink" title="线段树的区间修改与懒惰标记"></a>线段树的区间修改与懒惰标记</h2><p>如果要求修改区间 [l,r]，把所有包含在区间 [l,r] 中的节点都遍历一次、修改一次，时间复杂度无法承受。我们这里引入做 「懒惰标记」。通过延迟对节点信息的更改，从而减少可能不必要的操作次数。每次执行修改时，我们通过打标记的方法表明该节点对应的区间在某一次操作中被更改，但不更新该节点的子节点的信息。实质性的修改则在下一次访问带有标记的节点时才进行。</p><p><strong>区间修改</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-comment">// [l, r] 为修改区间, c 为被修改的元素的变化量, [s, t] 为当前节点包含的区间, p</span><br>  <span class="hljs-comment">// 为当前节点的编号</span><br>  <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) &#123;<br>    <span class="hljs-comment">// 区间内有几个在范围内的点*val值</span><br>    d[p] += (t - s + <span class="hljs-number">1</span>) * c, b[p] += c;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;  <span class="hljs-comment">// 当前区间为修改区间的子集时直接修改当前节点的值,然后打标记,结束修改</span><br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (b[p] &amp;&amp; s != t) &#123;<br>    <span class="hljs-comment">// 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值</span><br>    d[p * <span class="hljs-number">2</span>] += b[p] * (m - s + <span class="hljs-number">1</span>), d[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += b[p] * (t - m);<br>    b[p * <span class="hljs-number">2</span>] += b[p], b[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += b[p];  <span class="hljs-comment">// 将标记下传给子节点</span><br>    b[p] = <span class="hljs-number">0</span>;                                <span class="hljs-comment">// 清空当前节点的标记</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (l &lt;= m) <span class="hljs-built_in">update</span>(l, r, c, s, m, p * <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">if</span> (r &gt; m) <span class="hljs-built_in">update</span>(l, r, c, m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>  d[p] = d[p * <span class="hljs-number">2</span>] + d[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>区间查询</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-comment">// [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号</span><br>  <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) <span class="hljs-keyword">return</span> d[p];<br>  <span class="hljs-comment">// 当前区间为询问区间的子集时直接返回当前区间的和</span><br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (b[p]) &#123;<br>    <span class="hljs-comment">// 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值</span><br>    d[p * <span class="hljs-number">2</span>] += b[p] * (m - s + <span class="hljs-number">1</span>), d[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += b[p] * (t - m);<br>    b[p * <span class="hljs-number">2</span>] += b[p], b[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += b[p];  <span class="hljs-comment">// 将标记下传给子节点</span><br>    b[p] = <span class="hljs-number">0</span>;                                <span class="hljs-comment">// 清空当前节点的标记</span><br>  &#125;<br>  <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (l &lt;= m) sum = <span class="hljs-built_in">getsum</span>(l, r, s, m, p * <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">if</span> (r &gt; m) sum += <span class="hljs-built_in">getsum</span>(l, r, m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一些优化"><a href="#一些优化" class="headerlink" title="一些优化"></a>一些优化</h2><p>一些优化<br>这里总结几个线段树的优化：</p><ol><li><p>在叶子节点处无需下放懒惰标记，所以懒惰标记可以不下传到叶子节点。</p></li><li><p>下放懒惰标记可以写一个专门的函数 pushdown，从儿子节点更新当前节点也可以写一个专门的函数 maintain（或者对称地用 pushup），降低代码编写难度。</p></li><li><p>标记永久化：如果确定懒惰标记不会在中途被加到溢出（即超过了该类型数据所能表示的最大范围），那么就可以将标记永久化。标记永久化可以避免下传懒惰标记，只需在进行询问时把标记的影响加到答案当中，从而降低程序常数。具体如何处理与题目特性相关，需结合题目来写。这也是树套树和可持久化数据结构中会用到的一种技巧。</p></li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P3372">https://www.luogu.com.cn/problem/P3372</a></p><p>具体来说就是在线段树上完成一下操作</p><ol><li>将某区间每一个数加上k。</li><li>求出某区间每一个数的和。</li></ol><p>使用模板的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SegTreeLazyRangeAdd</span><br>&#123;<br>    vector&lt;T&gt; tree, lazy;<br>    vector&lt;T&gt; *arr;<br>    <span class="hljs-type">int</span> n, root, n4, end;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maintain</span><span class="hljs-params">(<span class="hljs-type">int</span> cl, <span class="hljs-type">int</span> cr, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> cm = cl + (cr - cl) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (cl != cr &amp;&amp; lazy[p])<br>        &#123;<br>            lazy[p * <span class="hljs-number">2</span>] += lazy[p];<br>            lazy[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += lazy[p];<br>            tree[p * <span class="hljs-number">2</span>] += lazy[p] * (cm - cl + <span class="hljs-number">1</span>);<br>            tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += lazy[p] * (cr - cm);<br>            lazy[p] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">range_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> cl, <span class="hljs-type">int</span> cr, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r)<br>            <span class="hljs-keyword">return</span> tree[p];<br>        <span class="hljs-type">int</span> m = cl + (cr - cl) / <span class="hljs-number">2</span>;<br>        T sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">maintain</span>(cl, cr, p);<br>        <span class="hljs-keyword">if</span> (l &lt;= m)<br>            sum += <span class="hljs-built_in">range_sum</span>(l, r, cl, m, p * <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (r &gt; m)<br>            sum += <span class="hljs-built_in">range_sum</span>(l, r, m + <span class="hljs-number">1</span>, cr, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">range_add</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, T val, <span class="hljs-type">int</span> cl, <span class="hljs-type">int</span> cr, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r)<br>        &#123;<br>            lazy[p] += val;<br>            tree[p] += (cr - cl + <span class="hljs-number">1</span>) * val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> m = cl + (cr - cl) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">maintain</span>(cl, cr, p);<br>        <span class="hljs-keyword">if</span> (l &lt;= m)<br>            <span class="hljs-built_in">range_add</span>(l, r, val, cl, m, p * <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (r &gt; m)<br>            <span class="hljs-built_in">range_add</span>(l, r, val, m + <span class="hljs-number">1</span>, cr, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        tree[p] = tree[p * <span class="hljs-number">2</span>] + tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (s == t)<br>        &#123;<br>            tree[p] = (*arr)[s];<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> m = s + (t - s) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">build</span>(s, m, p * <span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">build</span>(m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        tree[p] = tree[p * <span class="hljs-number">2</span>] + tree[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">explicit</span> <span class="hljs-built_in">SegTreeLazyRangeAdd</span>&lt;T&gt;(vector&lt;T&gt; v)<br>    &#123;<br>        n = v.<span class="hljs-built_in">size</span>();<br>        n4 = n * <span class="hljs-number">4</span>;<br>        tree = <span class="hljs-built_in">vector</span>&lt;T&gt;(n4, <span class="hljs-number">0</span>);<br>        lazy = <span class="hljs-built_in">vector</span>&lt;T&gt;(n4, <span class="hljs-number">0</span>);<br>        arr = &amp;v;<br>        end = n - <span class="hljs-number">1</span>;<br>        root = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">build</span>(<span class="hljs-number">0</span>, end, <span class="hljs-number">1</span>);<br>        arr = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (p &gt; n4 || tree[p] == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">show</span>(p * <span class="hljs-number">2</span>, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; depth; ++i)<br>            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\t&#x27;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d:%d\n&quot;</span>, tree[p], lazy[p]);<br>        <span class="hljs-built_in">show</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, depth + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">range_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">range_sum</span>(l, r, <span class="hljs-number">0</span>, end, root); &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">range_add</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> val)</span> </span>&#123; <span class="hljs-built_in">range_add</span>(l, r, val, <span class="hljs-number">0</span>, end, root); &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ll n, m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);<br>    vector&lt;ll&gt; ans;<br>    ll x;<br>    <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;x);<br>        ans.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>    <span class="hljs-function">SegTreeLazyRangeAdd&lt;ll&gt; <span class="hljs-title">st</span><span class="hljs-params">(ans)</span></span>;<br>    <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        ll op;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;op);<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>)<br>        &#123;<br>            ll x, y, k;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;x, &amp;y, &amp;k);<br>            st.<span class="hljs-built_in">range_add</span>(x - <span class="hljs-number">1</span>, y - <span class="hljs-number">1</span>, k);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ll x, y;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld %lld&quot;</span>, &amp;x, &amp;y);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, st.<span class="hljs-built_in">range_sum</span>(x - <span class="hljs-number">1</span>, y - <span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>srun网络协议分析</title>
    <link href="/2023/03/08/srun%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"/>
    <url>/2023/03/08/srun%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>校园网最近更新，登录方式改用深澜网络协议进行登录。本文根据登录时数据包，对深澜网络协议进行分析。</p><h1 id="请求分析"><a href="#请求分析" class="headerlink" title="请求分析"></a>请求分析</h1><h2 id="获取api请求"><a href="#获取api请求" class="headerlink" title="获取api请求"></a>获取api请求</h2><p>使用抓包软件对srun协议登录请求进行抓包</p><p>登录操作时候主要使用了以下几个请求</p><p><code>GET /cgi-bin/get_challenge?callback=jQuery1124038630846526307305_1678337618278&amp;username=2021440113**&amp;ip=10.202.47.26&amp;_=1678337618280 </code></p><p><img src="https://pic.liahnu.top/img/202303091302292.png"></p><p><code>GET /cgi-bin/srun_portal?callback=jQuery1124038630846526307305_1678337618278&amp;action=login&amp;username=2021440113**&amp;password=%7BMD5%7D01d38ef19265ae9ff199cbafc98e6797&amp;os=Windows+95&amp;name=Windows&amp;double_stack=0&amp; chksum=ffbaed27a7cbf48bcf7c227beae802def6f96901&amp;info=%7BSRBX1%7DQJl6uFy9IkM3%2FI3HaaNP%2FgPkfZWn%2FLUH3ktAZuPhtrF%2BailDbmoRB7oaw4jfeE%2FKR9hTkSoyJ5de6TXw6IpyX8VGiLpiWy6MLBEfu4RdCyg2WSim%2FmIssMlh9cfzJygmNCSiFDNbWiE6uBnn&amp;ac_id=1&amp;ip=10.202.47.26&amp;n=200&amp;type=1&amp;_=1678337618281 </code></p><p><img src="https://pic.liahnu.top/img/202303091534989.png"></p><p>下面具体根据两个请求进行分析</p><h2 id="get-challenge-请求"><a href="#get-challenge-请求" class="headerlink" title="get_challenge 请求"></a>get_challenge 请求</h2><p>根据请求，我们可以初步猜测出这个的参数</p><table><thead><tr><th align="center">参数</th><th align="center">示例值</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">callback</td><td align="center">jQuery1124038630846526307305_1678337618278</td><td align="center">应该是jquery的回调函数标志，可能由函数id+时间戳组成</td></tr><tr><td align="center">username</td><td align="center">2021440113**</td><td align="center">登录用户名</td></tr><tr><td align="center">ip</td><td align="center">10.202.47.26</td><td align="center">登录网站源站ip</td></tr><tr><td align="center">_</td><td align="center">1678337618280</td><td align="center">很明显是当前的时间戳</td></tr></tbody></table><h2 id="srun-portal-请求"><a href="#srun-portal-请求" class="headerlink" title="srun_portal 请求"></a>srun_portal 请求</h2><p>同样根据请求，我们可以初步猜测出这个请求的参数详情</p><table><thead><tr><th align="center">参数</th><th align="center">示例值</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">callback</td><td align="center">jQuery1124038630846526307305_1678337618278</td><td align="center">应该是jquery的回调函数标志，可能由函数id+时间戳组成</td></tr><tr><td align="center">password</td><td align="center">{MD5}01d38ef19265ae9ff199cbafc98e6797</td><td align="center">经过md5加密后的密码，但似乎不同于常规md5加密方法</td></tr><tr><td align="center">os</td><td align="center">Windows+95</td><td align="center">系统</td></tr><tr><td align="center">name</td><td align="center">Windows</td><td align="center">同上，系统参数</td></tr><tr><td align="center">double_stack</td><td align="center">0</td><td align="center">多次抓包后似乎是固定值，查询后应该是ipv4和ipv6双栈登录选项</td></tr><tr><td align="center">chksum</td><td align="center">ffbaed27a7cbf48bcf7c227beae802def6f96901</td><td align="center">某种加密后的参数</td></tr><tr><td align="center">info</td><td align="center">{SRBX1}QJl6uFy9IkM3%2FI3HaaNP%2FgPkfZWn%2FLUH3ktAZuPht rF%2BailDbmoRB7oaw4jfeE%2FKR9hTkSoyJ5de6TXw6Ipy X8VGiLpiWy6MLBEfu4RdCyg2WSim%2FmIssMlh9cfzJygmN CSiFDNbWiE6uBnn</td><td align="center">又是一段加密后的参数</td></tr><tr><td align="center">ac_id</td><td align="center">118</td><td align="center">固定值，可能是加密方式，错误的ac_id可能会导致bas错误</td></tr><tr><td align="center">n</td><td align="center">200</td><td align="center">固定值</td></tr><tr><td align="center">type</td><td align="center">1</td><td align="center">固定值</td></tr><tr><td align="center">_</td><td align="center">1678337618280</td><td align="center">很明显是当前的时间戳</td></tr></tbody></table><p>根据上面的基础分析，初步可以知道我们需要研究参数为 password，chksum，info字段</p><h2 id="js分析"><a href="#js分析" class="headerlink" title="js分析"></a>js分析</h2><p>根据上面的基础分析，在js的代码中寻找关键的代码信息</p><p>以下是寻找的相关代码(省略部分细节)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;#login-account&#x27;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> username = $(<span class="hljs-string">&#x27;#username&#x27;</span>).<span class="hljs-title function_">val</span>().<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/ /g</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>        <span class="hljs-keyword">var</span> password = $(<span class="hljs-string">&#x27;#password&#x27;</span>).<span class="hljs-title function_">val</span>();<br>        <span class="hljs-comment">// 若页面不存在 domain，则 domain 为空</span><br>        <span class="hljs-keyword">var</span> domain   = $(<span class="hljs-string">&#x27;#domain&#x27;</span>).<span class="hljs-title function_">val</span>();<br><br>        <span class="hljs-comment">// 写入用户信息</span><br>        portal.<span class="hljs-property">userInfo</span>.<span class="hljs-property">username</span> = username;<br>        portal.<span class="hljs-property">userInfo</span>.<span class="hljs-property">password</span> = password;<br>        portal.<span class="hljs-property">userInfo</span>.<span class="hljs-property">domain</span>   = domain || <span class="hljs-string">&#x27;&#x27;</span>;<br><br>        <span class="hljs-comment">// Portal 认证方法</span><br>        portal.<span class="hljs-title function_">login</span>(&#123;<br>            <span class="hljs-comment">// 认证方式为账号认证</span><br>            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;account&#x27;</span>,<br>            <span class="hljs-comment">// 认证成功</span><br>            <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-comment">// 若勾选记住密码</span><br>                <span class="hljs-keyword">if</span> ($(<span class="hljs-string">&#x27;#remember&#x27;</span>).<span class="hljs-title function_">prop</span>(<span class="hljs-string">&#x27;checked&#x27;</span>))  portal.<span class="hljs-title function_">remember</span>(<span class="hljs-literal">true</span>);<br>                <span class="hljs-comment">// 若未勾选记住密码 或 不存在记住密码功能</span><br>                <span class="hljs-keyword">if</span> (!$(<span class="hljs-string">&#x27;#remember&#x27;</span>).<span class="hljs-title function_">prop</span>(<span class="hljs-string">&#x27;checked&#x27;</span>)) portal.<span class="hljs-title function_">remember</span>(<span class="hljs-literal">false</span>);<br>                <span class="hljs-comment">// 重定向至成功页</span><br>                portal.<span class="hljs-title function_">toSuccess</span>();<br>            &#125;<br>        &#125;);<br>    &#125;);<br></code></pre></td></tr></table></figure><p>登录调用了portal.login() 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;login&quot;</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">login</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">var</span> obj = <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] !== <span class="hljs-literal">undefined</span> ? <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] : &#123;&#125;;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setLog</span>(<span class="hljs-string">&#x27;正在进行登陆操作&#x27;</span>); <span class="hljs-comment">// 默认进行拦截</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">loading</span>.<span class="hljs-property">login</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 账号认证</span><br><br>      <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;account&#x27;</span>) <span class="hljs-title function_">_classPrivateFieldGet</span>(<span class="hljs-variable language_">this</span>, _loginAccount).<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, obj); <span class="hljs-comment">// 短信认证 - 手机短信</span><br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>接着调用了 this._loginAccount()方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> sendAuth = <span class="hljs-keyword">function</span> <span class="hljs-title function_">sendAuth</span>(<span class="hljs-params">host</span>) &#123;<br>          <span class="hljs-comment">// 双栈认证时 IP 参数为空</span><br>          <span class="hljs-keyword">var</span> ip = _this.<span class="hljs-property">portalInfo</span>.<span class="hljs-property">doub</span> &amp;&amp; host ? <span class="hljs-string">&#x27;&#x27;</span> : _this.<span class="hljs-property">userInfo</span>.<span class="hljs-property">ip</span>; <span class="hljs-comment">// 获取 Token</span><br><br>          <span class="hljs-title function_">_classPrivateFieldGet</span>(<span class="hljs-title function_">_assertThisInitialized</span>(_this), _getToken).<span class="hljs-title function_">call</span>(<span class="hljs-title function_">_assertThisInitialized</span>(_this), host, ip, <span class="hljs-keyword">function</span> (<span class="hljs-params">token</span>) &#123;<br>            <span class="hljs-comment">// 用户密码 MD5 加密</span><br>            <span class="hljs-keyword">var</span> hmd5 = <span class="hljs-title function_">md5</span>(password, token); <span class="hljs-comment">// 用户信息加密</span><br><br>            <span class="hljs-keyword">var</span> i = <span class="hljs-title function_">_classPrivateFieldGet</span>(<span class="hljs-title function_">_assertThisInitialized</span>(_this), _encodeUserInfo).<span class="hljs-title function_">call</span>(<span class="hljs-title function_">_assertThisInitialized</span>(_this), &#123;<br>              <span class="hljs-attr">username</span>: username,<br>              <span class="hljs-attr">password</span>: password,<br>              <span class="hljs-attr">ip</span>: ip,<br>              <span class="hljs-attr">acid</span>: ac_id,<br>              <span class="hljs-attr">enc_ver</span>: enc<br>            &#125;, token);<br><br>            <span class="hljs-keyword">var</span> str = token + username;<br>            str += token + hmd5;<br>            str += token + ac_id;<br>            str += token + ip;<br>            str += token + n;<br>            str += token + type;<br>            str += token + i; <span class="hljs-comment">// 防止 IPv6 请求网络不通进行 try catch</span><br><br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">// 发起认证请求</span><br>              _this.<span class="hljs-property">ajax</span>.<span class="hljs-title function_">jsonp</span>(&#123;<br>                <span class="hljs-attr">host</span>: host,<br>                <span class="hljs-attr">url</span>: <span class="hljs-title function_">_classPrivateFieldGet</span>(<span class="hljs-title function_">_assertThisInitialized</span>(_this), _api).<span class="hljs-property">auth</span>,<br>                <span class="hljs-attr">params</span>: &#123;<br>                  <span class="hljs-attr">action</span>: <span class="hljs-string">&#x27;login&#x27;</span>,<br>                  <span class="hljs-attr">username</span>: username,<br>                  <span class="hljs-attr">password</span>: _this.<span class="hljs-property">userInfo</span>.<span class="hljs-property">otp</span> ? <span class="hljs-string">&#x27;&#123;OTP&#125;&#x27;</span> + password : <span class="hljs-string">&#x27;&#123;MD5&#125;&#x27;</span> + hmd5,<br>                  <span class="hljs-attr">os</span>: _this.<span class="hljs-property">portalInfo</span>.<span class="hljs-property">userDevice</span>.<span class="hljs-property">device</span>,<br>                  <span class="hljs-attr">name</span>: _this.<span class="hljs-property">portalInfo</span>.<span class="hljs-property">userDevice</span>.<span class="hljs-property">platform</span>,<br>                  <span class="hljs-comment">// 未开启双栈认证，参数为 0</span><br>                  <span class="hljs-comment">// 开启双栈认证，向 Portal 当前页面 IP 认证时，参数为 1</span><br>                  <span class="hljs-comment">// 开启双栈认证，向 Portal 另外一种 IP 认证时，参数为 0</span><br>                  <span class="hljs-attr">double_stack</span>: _this.<span class="hljs-property">portalInfo</span>.<span class="hljs-property">doub</span> &amp;&amp; !host ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>,<br>                  <span class="hljs-attr">chksum</span>: <span class="hljs-title function_">sha1</span>(str),<br>                  <span class="hljs-attr">info</span>: i,<br>                  <span class="hljs-attr">ac_id</span>: ac_id,<br>                  <span class="hljs-attr">ip</span>: ip,<br>                  <span class="hljs-attr">n</span>: n,<br>                  <span class="hljs-attr">type</span>: type<br>                &#125;,<br>                <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">success</span>(<span class="hljs-params">res</span>) &#123;<br>                  finishReq += <span class="hljs-number">1</span>; <span class="hljs-comment">// IP 已经在线了 - 给出提示</span><br><br>                  <span class="hljs-keyword">if</span> (res.<span class="hljs-property">suc_msg</span> === <span class="hljs-string">&#x27;ip_already_online_error&#x27;</span> &amp;&amp; obj.<span class="hljs-property">error</span>) <span class="hljs-keyword">return</span> _this.<span class="hljs-title function_">confirm</span>(&#123;<br>                    <span class="hljs-attr">message</span>: _this.<span class="hljs-title function_">translate</span>(<span class="hljs-string">&#x27;ip_already_online_error&#x27;</span>),<br>                    <span class="hljs-attr">confirm</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">confirm</span>(<span class="hljs-params"></span>) &#123;<br>                      <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">error</span>) obj.<span class="hljs-title function_">error</span>();<br>                    &#125;<br>                  &#125;); <span class="hljs-comment">// 翻译后的认证成功信息</span><br><br>                  successMsg = _this.<span class="hljs-title function_">translate</span>(res);<br>                &#125;,<br>                <span class="hljs-comment">/* 常见错误代码 */</span><br>                <span class="hljs-attr">error</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">error</span>(<span class="hljs-params">res</span>) &#123;<br>                  finishReq += <span class="hljs-number">1</span>; <span class="hljs-comment">// 更改登录状态为结束</span><br><br>                  _this.<span class="hljs-property">loading</span>.<span class="hljs-property">login</span> = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 若所有请求均已完成</span><br><br>                  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">noPending</span>()) <span class="hljs-title function_">authClose</span>(); <span class="hljs-comment">// 若 ecode 为 E2620 且开启了在线设备管理功能</span><br>                  <span class="hljs-comment">// E2620: 超出允许的在线数目</span><br><br>                  <span class="hljs-keyword">if</span> (res.<span class="hljs-property">ecode</span> === <span class="hljs-string">&#x27;E2620&#x27;</span> &amp;&amp; <span class="hljs-variable constant_">CREATER</span>.<span class="hljs-property">useOnlineDeviceMgr</span>) <span class="hljs-keyword">return</span> _this.<span class="hljs-title function_">confirm</span>(&#123;<br>                    <span class="hljs-attr">message</span>: _this.<span class="hljs-title function_">translate</span>(<span class="hljs-string">&#x27;E2620Tips&#x27;</span>),<br>                    <span class="hljs-attr">confirm</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">confirm</span>(<span class="hljs-params"></span>) &#123;<br>                      _this.<span class="hljs-property">dialog</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;onlineDeviceMgr&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>                        _this.<span class="hljs-title function_">getOnlineDevice</span>();<br>                      &#125;);<br>                    &#125;<br>                  &#125;); <span class="hljs-comment">// IP 已经在线了 - 重新认证</span><br><br>                  <span class="hljs-keyword">if</span> (res.<span class="hljs-property">error_msg</span> === <span class="hljs-string">&#x27;ip_already_online_error&#x27;</span>) <span class="hljs-keyword">return</span> _this.<span class="hljs-title function_">reAuth</span>(obj); <span class="hljs-comment">// 需要查询日志的情况</span><br><br>                  <span class="hljs-keyword">if</span> (res.<span class="hljs-property">error_msg</span> === <span class="hljs-string">&#x27;not_online_error&#x27;</span>) <span class="hljs-keyword">return</span> _this.<span class="hljs-title function_">showLog</span>();<br>                  <span class="hljs-keyword">if</span> (res.<span class="hljs-property">error_msg</span> === <span class="hljs-string">&#x27;no_response_data_error&#x27;</span>) <span class="hljs-keyword">return</span> _this.<span class="hljs-title function_">showLog</span>();<br>                  <span class="hljs-keyword">if</span> (res.<span class="hljs-property">error_msg</span> === <span class="hljs-string">&#x27;RD000&#x27;</span>) <span class="hljs-keyword">return</span> _this.<span class="hljs-title function_">showLog</span>(); <span class="hljs-comment">// 若提示修改密码</span><br><br>                  <span class="hljs-keyword">if</span> (res.<span class="hljs-property">error_msg</span> === <span class="hljs-string">&#x27;user_must_modify_password&#x27;</span> || res.<span class="hljs-property">error</span> === <span class="hljs-string">&#x27;user_must_modify_password&#x27;</span>) <span class="hljs-keyword">return</span> _this.<span class="hljs-title function_">confirm</span>(&#123;<br>                    <span class="hljs-attr">message</span>: _this.<span class="hljs-title function_">translate</span>(res),<br>                    <span class="hljs-attr">confirmText</span>: _this.<span class="hljs-title function_">translate</span>(<span class="hljs-string">&#x27;ToChangePassword&#x27;</span>),<br>                    <span class="hljs-attr">confirm</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">confirm</span>(<span class="hljs-params"></span>) &#123;<br>                      <span class="hljs-keyword">return</span> $(<span class="hljs-string">&#x27;#forget&#x27;</span>).<span class="hljs-title function_">click</span>();<br>                    &#125;,<br>                    <span class="hljs-attr">cancel</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">cancel</span>(<span class="hljs-params"></span>) &#123;&#125;<br>                  &#125;); <span class="hljs-comment">// 错误提示</span><br><br>                  _this.<span class="hljs-title function_">confirm</span>(&#123;<br>                    <span class="hljs-attr">message</span>: _this.<span class="hljs-title function_">translate</span>(res),<br>                    <span class="hljs-attr">confirm</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">confirm</span>(<span class="hljs-params"></span>) &#123;<br>                      <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">error</span>) obj.<span class="hljs-title function_">error</span>(res);<br>                    &#125;<br>                  &#125;);<br>                &#125;<br>              &#125;);<br>            &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>              finishReq += <span class="hljs-number">1</span>; <span class="hljs-comment">// 更改登录状态为结束</span><br><br>              _this.<span class="hljs-property">loading</span>.<span class="hljs-property">login</span> = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 若所有请求均已完成</span><br><br>              <span class="hljs-keyword">if</span> (<span class="hljs-title function_">noPending</span>()) <span class="hljs-title function_">authClose</span>(); <span class="hljs-comment">// 因为 IPv6 网络问题导致的认证失败</span><br><br>              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">err</span>(<span class="hljs-string">&#x27;Network error&#x27;</span>, err);<br>            &#125;<br>          &#125;);<br>        &#125;;<br></code></pre></td></tr></table></figure><p>发现这边多了个token参数，经过与请求对比发现，token参数是get_challenge请求中的challenge参数</p><p>获取到token参数过后，将password和token进行md5加密（应该是使用了hmac算法），得到加密后的md5值<br>参考实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>    String token=<span class="hljs-string">&quot;9175d2a16f2339e60d5e1b4be4df16b1660f79d57009e7adf4422488a2a0439a&quot;</span>;<br>    String password=<span class="hljs-string">&quot;1234567890&quot;</span>;<br><br>    <span class="hljs-type">HMac</span> <span class="hljs-variable">hmac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HMac</span>(HmacAlgorithm.HmacMD5, token.getBytes());<br>    <span class="hljs-type">byte</span>[] result = hmac.digest(password.getBytes());<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> HexUtil.encodeHexStr(result);<br>    System.out.println(s);<br>&#125;<br><br>### info部分<br><br>```js<br>_encodeUserInfo.set(_assertThisInitialized(_this), &#123;<br>  writable: <span class="hljs-literal">true</span>,<br>  value: function <span class="hljs-title function_">value</span><span class="hljs-params">(info, token)</span> &#123;<br>    <span class="hljs-comment">// 克隆自 $.base64，防止污染</span><br>    <span class="hljs-type">var</span> <span class="hljs-variable">base64</span> <span class="hljs-operator">=</span> _this.clone($.base64); <span class="hljs-comment">// base64 设置 Alpha</span><br><br><br>    base64.setAlpha(<span class="hljs-string">&#x27;LVoJPiCN2R8G90yg+hmFHuacZ1OWMnrsSTXkYpUq/3dlbfKwv6xztjI7DeBE45QA&#x27;</span>); <span class="hljs-comment">// 用户信息转 JSON</span><br><br>    info = JSON.stringify(info);<br><br>    function <span class="hljs-title function_">encode</span><span class="hljs-params">(str, key)</span> &#123;<br>      <span class="hljs-keyword">if</span> (str === <span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>      <span class="hljs-type">var</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> s(str, <span class="hljs-literal">true</span>);<br>      <span class="hljs-type">var</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> s(key, <span class="hljs-literal">false</span>);<br>      <span class="hljs-keyword">if</span> (k.length &lt; <span class="hljs-number">4</span>) k.length = <span class="hljs-number">4</span>;<br>      <span class="hljs-type">var</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> v.length - <span class="hljs-number">1</span>,<br>          z = v[n],<br>          y = v[<span class="hljs-number">0</span>],<br>          c = <span class="hljs-number">0x86014019</span> | <span class="hljs-number">0x183639A0</span>,<br>          m,<br>          e,<br>          p,<br>          q = Math.floor(<span class="hljs-number">6</span> + <span class="hljs-number">52</span> / (n + <span class="hljs-number">1</span>)),<br>          d = <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span> &lt; q--) &#123;<br>        d = d + c &amp; (<span class="hljs-number">0x8CE0D9BF</span> | <span class="hljs-number">0x731F2640</span>);<br>        e = d &gt;&gt;&gt; <span class="hljs-number">2</span> &amp; <span class="hljs-number">3</span>;<br><br>        <span class="hljs-keyword">for</span> (p = <span class="hljs-number">0</span>; p &lt; n; p++) &#123;<br>          y = v[p + <span class="hljs-number">1</span>];<br>          m = z &gt;&gt;&gt; <span class="hljs-number">5</span> ^ y &lt;&lt; <span class="hljs-number">2</span>;<br>          m += y &gt;&gt;&gt; <span class="hljs-number">3</span> ^ z &lt;&lt; <span class="hljs-number">4</span> ^ (d ^ y);<br>          m += k[p &amp; <span class="hljs-number">3</span> ^ e] ^ z;<br>          z = v[p] = v[p] + m &amp; (<span class="hljs-number">0xEFB8D130</span> | <span class="hljs-number">0x10472ECF</span>);<br>        &#125;<br><br>        y = v[<span class="hljs-number">0</span>];<br>        m = z &gt;&gt;&gt; <span class="hljs-number">5</span> ^ y &lt;&lt; <span class="hljs-number">2</span>;<br>        m += y &gt;&gt;&gt; <span class="hljs-number">3</span> ^ z &lt;&lt; <span class="hljs-number">4</span> ^ (d ^ y);<br>        m += k[p &amp; <span class="hljs-number">3</span> ^ e] ^ z;<br>        z = v[n] = v[n] + m &amp; (<span class="hljs-number">0xBB390742</span> | <span class="hljs-number">0x44C6F8BD</span>);<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> l(v, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    function <span class="hljs-title function_">s</span><span class="hljs-params">(a, b)</span> &#123;<br>      <span class="hljs-type">var</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a.length;<br>      <span class="hljs-type">var</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> [];<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">var</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; c; i += <span class="hljs-number">4</span>) &#123;<br>        v[i &gt;&gt; <span class="hljs-number">2</span>] = a.charCodeAt(i) | a.charCodeAt(i + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">8</span> | a.charCodeAt(i + <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-number">16</span> | a.charCodeAt(i + <span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-number">24</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (b) v[v.length] = c;<br>      <span class="hljs-keyword">return</span> v;<br>    &#125;<br><br>    function <span class="hljs-title function_">l</span><span class="hljs-params">(a, b)</span> &#123;<br>      <span class="hljs-type">var</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> a.length;<br>      <span class="hljs-type">var</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> d - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;<br><br>      <span class="hljs-keyword">if</span> (b) &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> a[d - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (m &lt; c - <span class="hljs-number">3</span> || m &gt; c) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        c = m;<br>      &#125;<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">var</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; d; i++) &#123;<br>        a[i] = String.fromCharCode(a[i] &amp; <span class="hljs-number">0xff</span>, a[i] &gt;&gt;&gt; <span class="hljs-number">8</span> &amp; <span class="hljs-number">0xff</span>, a[i] &gt;&gt;&gt; <span class="hljs-number">16</span> &amp; <span class="hljs-number">0xff</span>, a[i] &gt;&gt;&gt; <span class="hljs-number">24</span> &amp; <span class="hljs-number">0xff</span>);<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> b ? a.join(<span class="hljs-string">&#x27;&#x27;</span>).substring(<span class="hljs-number">0</span>, c) : a.join(<span class="hljs-string">&#x27;&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#123;SRBX1&#125;&#x27;</span> + base64.encode(encode(info, token));<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs armasm">组合<span class="hljs-keyword">str</span><br>```js<br><span class="hljs-symbol">var</span> <span class="hljs-keyword">str</span> = token + username<span class="hljs-comment">;</span><br><span class="hljs-keyword">str</span> += token + hmd5<span class="hljs-comment">;</span><br><span class="hljs-keyword">str</span> += token + ac_id<span class="hljs-comment">;</span><br><span class="hljs-keyword">str</span> += token + <span class="hljs-built_in">ip</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">str</span> += token + n<span class="hljs-comment">;</span><br><span class="hljs-keyword">str</span> += token + type<span class="hljs-comment">;</span><br><span class="hljs-keyword">str</span> += token + i<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>chksum是通过使用sha1(str)方法进行加密,str是它通过之前各个参数的拼接完成。sha1根据函数名可以猜测为sha1加密方法。</p><p>根据以上方法，我们就可以获得基础登录加密方法组装。</p><h1 id="登录实践"><a href="#登录实践" class="headerlink" title="登录实践"></a>登录实践</h1><p>分析完了srun协议的登录，但是个人懒得写相关源程序，这里借用开源项目</p><p>这里提供一个已经写好的srun登录软件，来自于github开源</p><p><a href="https://github.com/zu1k/srun">srun</a></p><p>同样是借用上面的代码锁实现的<a href="https://github.com/1328411791/GDOUYJ_Internet_Client">安卓的登录器</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录给网站添加cdn</title>
    <link href="/2023/02/12/%E8%AE%B0%E5%BD%95%E7%BB%99%E7%BD%91%E7%AB%99%E6%B7%BB%E5%8A%A0cdn/"/>
    <url>/2023/02/12/%E8%AE%B0%E5%BD%95%E7%BB%99%E7%BD%91%E7%AB%99%E6%B7%BB%E5%8A%A0cdn/</url>
    
    <content type="html"><![CDATA[<h1 id="cdn介绍"><a href="#cdn介绍" class="headerlink" title="cdn介绍"></a>cdn介绍</h1><p>内容分发网络（Content Delivery Network，简称 CDN）是利用最靠近每一位用户的服务器，更快、更可靠地将文件发送给用户分发网络。</p><p>总而言之，cdn可以加速不同地区的用户的访问，同时将网站中的静态资源缓存，以此减轻服务器的负担。</p><pre><code class="mermaid">graph LR;USER1[用户1] -->|访问|CDN[CDN]USER2[用户2] -->|访问|CDNCDN -->|转发| D[源站]</code></pre><h1 id="服务器配置CDN"><a href="#服务器配置CDN" class="headerlink" title="服务器配置CDN"></a>服务器配置CDN</h1><p>这里以腾讯云的为例</p><h2 id="前往云服务器cdn管理器"><a href="#前往云服务器cdn管理器" class="headerlink" title="前往云服务器cdn管理器"></a>前往云服务器cdn管理器</h2><p>在云中控制台中选择 <strong>内容分发网络 CDN 控制台</strong> ，购买或者领取相应的资源包</p><p>选择添加域名</p><p><img src="https://gitee.com/liahnu/img/raw/master/202302112151151.png"></p><p><img src="https://gitee.com/liahnu/img/raw/master/202302112151459.png"></p><p>加速区域选择中国境内，加速域名填写你需要加速的服务器。注意，在加速域名中，*.example.com和example.com是不同的，用户仅访问example.com有加速效果，若访问<a href="http://www.example.com或m.example.com没有加速效果,需要单独填写接入cdn加速后生效./">www.example.com或m.example.com没有加速效果，需要单独填写接入CDN加速后生效。</a></p><p>这里可能会需要验证域名的信息，这需要在域名DNS面板中的域名配置中添加参数的记录，然后点击验证<br><img src="https://gitee.com/liahnu/img/raw/master/202302112200648.png"></p><p>类型选择网页小文件</p><h3 id="源站配置"><a href="#源站配置" class="headerlink" title="源站配置"></a>源站配置</h3><p>源站类型中，选择自有源，因为我的服务器中配置了https证书，所以选择https协议，源站地址填写你的服务器地址。</p><p>填写完成后，保存</p><h2 id="设置缓存文件信息"><a href="#设置缓存文件信息" class="headerlink" title="设置缓存文件信息"></a>设置缓存文件信息</h2><p><img src="https://gitee.com/liahnu/img/raw/master/202302112158598.png"></p><p>这里默认给了配置，如果没有什么需求，默认就可以</p><p>提交配置后，需要在域名的DNS管理面板中添加CNAME转发的参数</p><p><img src="https://gitee.com/liahnu/img/raw/master/202302112201184.png"></p><p>在DNS配置中，添加记录雷系为CNAME的记录，主机记录是转发的三级域名名称，其中CNAME可以代替原先DNS指向源站的A类记录，记录值为是cdn面板中的主机记录。</p><p><img src="https://gitee.com/liahnu/img/raw/master/202302112202269.png"></p><h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>配置完成后，等待3-5分钟，就可以在cdn面板中看到配置状态。可以使用站长工具中的ping工具，检测ping地址中是否有有cdn地址，若有，也可以说明配置成功。</p><p><img src="https://gitee.com/liahnu/img/raw/master/202302112205576.png"></p><h1 id="回源相关"><a href="#回源相关" class="headerlink" title="回源相关"></a>回源相关</h1><h2 id="回源是什么"><a href="#回源是什么" class="headerlink" title="回源是什么"></a>回源是什么</h2><p>cdn向后段源服务器请求资源并缓存，这个请求过程是周期性的，自动的，称为回源。 </p>]]></content>
    
    
    
    <tags>
      
      <tag>运维，CDN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis消息队列</title>
    <link href="/2022/12/08/Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <url>/2022/12/08/Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h1><h2 id="7-1-Redis消息队列-认识消息队列"><a href="#7-1-Redis消息队列-认识消息队列" class="headerlink" title="7.1 Redis消息队列-认识消息队列"></a>7.1 Redis消息队列-认识消息队列</h2><p>什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p><ul><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ul><p>使用队列的好处在于 <strong>解耦：</strong>所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。</p><p>这种场景在我们秒杀中就变成了：我们下单之后，利用redis去进行校验下单条件，再通过队列把消息发送出去，然后再启动一个线程去消费这个消息，完成解耦，同时也加快我们的响应速度。</p><p>这里我们可以使用一些现成的mq，比如kafka，rabbitmq等等，但是呢，如果没有安装mq，我们也可以直接使用redis提供的mq方案，降低我们的部署和学习成本。</p><h2 id="7-2-Redis消息队列-基于List实现消息队列"><a href="#7-2-Redis消息队列-基于List实现消息队列" class="headerlink" title="7.2 Redis消息队列-基于List实现消息队列"></a>7.2 Redis消息队列-基于List实现消息队列</h2><p><strong>基于List结构模拟消息队列</strong></p><p>消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p><p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。<br>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p><p>基于List的消息队列有哪些优缺点？<br>优点：</p><ul><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul><p>缺点：</p><ul><li>无法避免消息丢失</li><li>只支持单消费者</li></ul><h2 id="Redis消息队列-基于PubSub的消息队列"><a href="#Redis消息队列-基于PubSub的消息队列" class="headerlink" title="Redis消息队列-基于PubSub的消息队列"></a>Redis消息队列-基于PubSub的消息队列</h2><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p><p> SUBSCRIBE channel [channel] ：订阅一个或多个频道<br> PUBLISH channel msg ：向一个频道发送消息<br> PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</p><p>基于PubSub的消息队列有哪些优缺点？<br>优点：</p><ul><li>采用发布订阅模型，支持多生产、多消费</li></ul><p>缺点：</p><ul><li>不支持数据持久化</li><li>无法避免消息丢失</li><li>消息堆积有上限，超出时数据丢失</li></ul><h3 id="7-4-Redis消息队列-基于Stream的消息队列"><a href="#7-4-Redis消息队列-基于Stream的消息队列" class="headerlink" title="7.4 Redis消息队列-基于Stream的消息队列"></a>7.4 Redis消息队列-基于Stream的消息队列</h3><p>Stream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p><p>注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题</p><p>STREAM类型消息队列的XREAD命令特点：</p><ul><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有消息漏读的风险</li></ul><h3 id="7-5-Redis消息队列-基于Stream的消息队列-消费者组"><a href="#7-5-Redis消息队列-基于Stream的消息队列-消费者组" class="headerlink" title="7.5 Redis消息队列-基于Stream的消息队列-消费者组"></a>7.5 Redis消息队列-基于Stream的消息队列-消费者组</h3><p>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p><p>key：队列名称<br>groupName：消费者组名称<br>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息<br>MKSTREAM：队列不存在时自动创建队列<br>其它常见命令：</p><p> <strong>删除指定的消费者组</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">XGROUP DESTORY key groupName</span><br></code></pre></td></tr></table></figure><p> <strong>给指定的消费者组添加消费者</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">XGROUP CREATECONSUMER key groupname consumername</span><br></code></pre></td></tr></table></figure><p> <strong>删除消费者组中的指定消费者</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">XGROUP DELCONSUMER key groupname consumername</span><br></code></pre></td></tr></table></figure><p>从消费者组读取消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]<br></code></pre></td></tr></table></figure><ul><li>group：消费组名称</li><li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li><li>count：本次查询的最大数量</li><li>BLOCK milliseconds：当没有消息时最长等待时间</li><li>NOACK：无需手动ACK，获取到消息后自动确认</li><li>STREAMS key：指定队列名称</li><li>ID：获取消息的起始ID：</li></ul><p>“&gt;”：从下一个未消费的消息开始<br>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</p><p>STREAM类型消息队列的XREADGROUP命令特点：</p><ul><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读的风险</li><li>有消息确认机制，保证消息至少被消费一次</li></ul><p>最后我们来个小对比</p><p><img src="https://gitee.com/liahnu/img/raw/master/202212082037030.png"></p><h3 id="7-6-基于Redis的Stream结构作为消息队列，实现异步秒杀下单"><a href="#7-6-基于Redis的Stream结构作为消息队列，实现异步秒杀下单" class="headerlink" title="7.6 基于Redis的Stream结构作为消息队列，实现异步秒杀下单"></a>7.6 基于Redis的Stream结构作为消息队列，实现异步秒杀下单</h3><p>需求：</p><ul><li>创建一个Stream类型的消息队列，名为stream.orders</li><li>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</li><li>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单\</li></ul><p>修改lua表达式,新增3.6</p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redisson入门</title>
    <link href="/2022/11/26/Redisson%E5%85%A5%E9%97%A8/"/>
    <url>/2022/11/26/Redisson%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis中利用setnx实现的分布式锁存在以下问题"><a href="#Redis中利用setnx实现的分布式锁存在以下问题" class="headerlink" title="Redis中利用setnx实现的分布式锁存在以下问题"></a>Redis中利用setnx实现的分布式锁存在以下问题</h1><p><strong>重入问题</strong> 重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong> 是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放</strong> 我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><p>而Redisson帮我们实现了分布式锁的相关功能</p><h1 id="Redisson可重入锁的原理"><a href="#Redisson可重入锁的原理" class="headerlink" title="Redisson可重入锁的原理"></a>Redisson可重入锁的原理</h1><p>Redisson分布式锁中，他采用hash结构用来存储锁，其中大key表示表示这把锁是否存在，用小key表示当前这把锁被哪个线程持有，</p><p><img src="/../img/2.png" alt="流程"></p><h1 id="Redisson可重入锁的锁重试"><a href="#Redisson可重入锁的锁重试" class="headerlink" title="Redisson可重入锁的锁重试"></a>Redisson可重入锁的锁重试</h1><p><img src="/../img/3.png"></p><h1 id="redisson多节点的解决"><a href="#redisson多节点的解决" class="headerlink" title="redisson多节点的解决"></a>redisson多节点的解决</h1><p>将redis各个节点分别拆成独立的节点，向所有节点设置锁，因此节点不会同时失效，参数锁问题。</p><h2 id="红锁"><a href="#红锁" class="headerlink" title="红锁"></a>红锁</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Redis中针对此种情况，引入了红锁的概念。红锁采用主节点过半机制，即获取锁或者释放锁成功的标志为：在过半的节点上操作成功。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在Redis的分布式环境中，我们假设有N个Redis master。这些节点完全互相独立，不存在主从复制或者其他集群协调机制。之前我们已经描述了在Redis单实例下怎么安全地获取和释放锁。我们确保将在每（N）个实例上使用此方法获取和释放锁。</p><h1 id="Redis可重入的锁总结"><a href="#Redis可重入的锁总结" class="headerlink" title="Redis可重入的锁总结"></a>Redis可重入的锁总结</h1><p>抢锁过程中，获得当前线程，通过tryAcquire进行抢锁，该抢锁逻辑和之前逻辑相同</p><p>1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回null</p><p>2、判断当前这把锁是否是属于当前线程，如果是，则返回null</p><p>所以如果返回是null，则代表着当前这哥们已经抢锁完毕，或者可重入完毕，但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，同学们可以自行往下翻一点点，你能发现有个while( true) 再次进行tryAcquire进行抢锁</p><p>如果是没有传入时间，则此时也会进行抢锁， 而且抢锁时间是默认看门狗时间 commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()</p><p>ttlRemainingFuture.onComplete((ttlRemaining, e) 这句话相当于对以上抢锁进行了监听，也就是说当上边抢锁完毕后，此方法会被调用，具体调用的逻辑就是去后台开启一个线程，进行续约逻辑，也就是看门狗线程</p><h2 id="5-5-分布式锁-redission锁的MutiLock原理"><a href="#5-5-分布式锁-redission锁的MutiLock原理" class="headerlink" title="5.5 分布式锁-redission锁的MutiLock原理"></a>5.5 分布式锁-redission锁的MutiLock原理</h2><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p><p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p><p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p><p>那么MutiLock 加锁原理是什么呢？笔者画了一幅图来说明</p><p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo基础指令</title>
    <link href="/2022/11/26/hexo%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/"/>
    <url>/2022/11/26/hexo%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="简写指令"><a href="#简写指令" class="headerlink" title="简写指令:"></a>简写指令:</h1><p>hexo n “我的第一篇文章” 等价于 hexo new “我的第一篇文章” 还等价于 hexo new post “我的第一篇文章”<br>hexo p 等价于 hexo publish<br>hexo g 等价于 hexo generate<br>hexo s等价于 hexo server<br>hexo d 等价于 hexo deploy<br>hexo deploy -g 等价于 hexo deploy –generate<br>hexo generate -d等价于hexo generate –deploy</p><p>注: hexo clean 没有 简写, git –version 没有简写</p><h1 id="指令说明"><a href="#指令说明" class="headerlink" title="指令说明:"></a>指令说明:</h1><p>hexo server #Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。<br>hexo server -s #以静态模式启动<br>hexo server -p 5000 #更改访问端口 (默认端口为4000，’ctrl + c’关闭server)<br>hexo server -i IP地址 #自定义 IP<br>hexo clean #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹<br>hexo g #生成静态网页 (执行 $ hexo g后会在站点根目录下生成public文件夹, hexo会将”&#x2F;blog&#x2F;source&#x2F;“ 下面的.md后缀的文件编译为.html后缀的文件,存放在”&#x2F;blog&#x2F;public&#x2F; “ 路径下)<br>hexo d #将本地数据部署到远端服务器(如github)<br>hexo init 文件夹名称 #初始化XX文件夹名称<br>npm update hexo -g#升级<br>npm install hexo -g#安装<br>node-v #查看node.js版本号<br>npm -v #查看npm版本号<br>git –version #查看git版本号<br>hexo -v #查看hexo版本号</p><h1 id="上传到git仓库指令"><a href="#上传到git仓库指令" class="headerlink" title="上传到git仓库指令"></a>上传到git仓库指令</h1><p><code>hexo clean &amp;&amp; hexo d</code> 清除缓存并上传到git仓库</p><h1 id="便签功能"><a href="#便签功能" class="headerlink" title="便签功能"></a>便签功能</h1><div class="note note-success">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><h1 id="公式编辑器"><a href="#公式编辑器" class="headerlink" title="公式编辑器"></a>公式编辑器</h1><h1 id="Mermaid-相关"><a href="#Mermaid-相关" class="headerlink" title="Mermaid 相关"></a>Mermaid 相关</h1><p><code>&#123;% mermaid %&#125;``&#123;% endmermaid %&#125;</code></p><p>用这个标记把流程图框起来（不知道为什么我这用代码块画会报错）</p><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p>参见 <a href="https://hexo.fluid-dev.com/docs/guide/">https://hexo.fluid-dev.com/docs/guide/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis缓存查询</title>
    <link href="/2022/11/16/Redis%E7%BC%93%E5%AD%98%E6%9F%A5%E8%AF%A2/"/>
    <url>/2022/11/16/Redis%E7%BC%93%E5%AD%98%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="缓存的概念"><a href="#缓存的概念" class="headerlink" title="缓存的概念"></a>缓存的概念</h1><h2 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h2><p><strong>缓存</strong>(Cache),就是数据交换的<strong>缓冲区</strong>,俗称的缓存就是<strong>缓冲区内的数据</strong>。在后端开发中,缓存通常会储存在内存之中</p><p>缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低<strong>用户访问并发量带来的</strong>服务器读写压力</p><p>实际开发过程中,可能一个应用的数据量非常大,如果没有缓存来作为”避震器”,系统是几乎撑不住的,所以会大量运用到缓存技术;</p><p>但是缓存也会增加代码复杂度和运营的成本:</p><p>缓存常见的有以下几种:</p><p><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</p><p><strong>应用层缓存：</strong>可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</p><p><strong>数据库缓存：</strong>在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</p><p><strong>CPU缓存：</strong> 当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</p><p><strong>硬盘缓存：</strong> 内存向硬盘读写时候，增加硬盘的性能所产生的缓存</p><p>基本上计算机每一层直接都会有缓存作为中间态进行过度，对于后端开发而言，redis缓存是缓存数据库与应用间的数据。</p><h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p><p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p><p><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</p><p><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p><h3 id="数据库缓存不一致解决方案："><a href="#数据库缓存不一致解决方案：" class="headerlink" title="数据库缓存不一致解决方案："></a>数据库缓存不一致解决方案：</h3><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:</p><p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案</p><p>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p><p>Read&#x2F;Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p><p>Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p><h3 id="数据库和缓存不一致采用什么方案"><a href="#数据库和缓存不一致采用什么方案" class="headerlink" title="数据库和缓存不一致采用什么方案"></a>数据库和缓存不一致采用什么方案</h3><p>综合考虑会使用方案一，但是方案一调用者如何处理呢？这里有几个问题</p><p>操作缓存和数据库时有三个问题需要考虑：</p><p>如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来</p><ul><li><p>删除缓存还是更新缓存？</p><ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li></ul></li><li><p>如何保证缓存与数据库的操作的同时成功或失败？</p><ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用TCC等分布式事务方案</li></ul></li></ul><p>应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p><ul><li>先操作缓存还是先操作数据库？<ul><li>先删除缓存，再操作数据库</li><li>先操作数据库，再删除缓存</li></ul></li></ul><p>通常会使用删除缓存的方式操作</p><h3 id="缓存穿透问题的解决思路"><a href="#缓存穿透问题的解决思路" class="headerlink" title="缓存穿透问题的解决思路"></a>缓存穿透问题的解决思路</h3><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li></ul><p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p><p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p><p>假设布隆过滤器判断这个数据不存在，则直接返回</p><p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p><p><strong>总结</strong>缓存穿透的解决方案有以下这些：</p><ul><li>缓存null值</li><li>布隆过滤</li><li>增强id的复杂度，避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul><h3 id="缓存雪崩问题及解决思路"><a href="#缓存雪崩问题及解决思路" class="headerlink" title="缓存雪崩问题及解决思路"></a>缓存雪崩问题及解决思路</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案：</p><ul><li>给不同的Key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><h3 id="缓存击穿问题及解决思路"><a href="#缓存击穿问题及解决思路" class="headerlink" title="缓存击穿问题及解决思路"></a>缓存击穿问题及解决思路</h3><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>常见的解决方案有两种：</p><ul><li>互斥锁</li><li>逻辑过期</li></ul><p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p><p><strong>解决方案一、使用互斥锁来解决：</strong></p><p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p><p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p><p><strong>解决方案二、逻辑过期方案</strong></p><p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p><p>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个线程2去进行以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3直接返回数据，只有等到新开的线程2把重建数据后，其他线程才能走返回正确的数据。</p><p>两种方案的对比：</p><p><strong>互斥锁方案：</strong>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p><p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇博客</title>
    <link href="/2022/11/16/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/11/16/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>终于把github上面的github page大概搞了，大概去年这个时候创的仓库，拖到今年才开始，都快一年了了。</p><p>未来可能会把手头上做过的一些笔记整理一波扔上去。</p>]]></content>
    
    
    
    <tags>
      
      <tag>建站</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dijkstra算法</title>
    <link href="/2022/10/08/dijkstra%E7%AE%97%E6%B3%95/"/>
    <url>/2022/10/08/dijkstra%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="dijkstra算法"><a href="#dijkstra算法" class="headerlink" title="dijkstra算法"></a>dijkstra算法</h1><p>Dijkstra 算法，用于对有权图进行搜索，找出图中两点的最短距离，既不是DFS搜索，也不是BFS搜索。把Dijkstra 算法应用于无权图，或者所有边的权都相等的图，Dijkstra 算法等同于BFS搜索。<br>dijkstra算法时间复杂度为$O(n^2)$</p><h2 id="算法的思路："><a href="#算法的思路：" class="headerlink" title="算法的思路："></a>算法的思路：</h2><p>设G&#x3D;(V,E)是一个带权有向图，把图中顶点集合V分成两组第一组为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，以后每求得一条最短路径,就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了）第二组为其余未确定最短路径的顶点集合（用U表示），按最短路径长度的递增次序依次把第二组的顶点加入S中。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离，是从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。</p><h3 id="简单来说就是："><a href="#简单来说就是：" class="headerlink" title="简单来说就是："></a>简单来说就是：</h3><ol><li>先定义dist[1]&#x3D;0,dist[i]&#x3D;INF(0x3f);</li><li>for 1~n i判断不在S中，且距离最近的点，把他加入s中</li><li>然后开始更新一下它到其他点的距离</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstrac</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    <span class="hljs-comment">//初始化</span><br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//设置A--&gt;A=0开始距离</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> t=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        <span class="hljs-comment">//寻找</span><br>        <span class="hljs-keyword">if</span>(!st[j]&amp;&amp;(t==<span class="hljs-number">-1</span>||dist[j]&lt;dist[t]))<br>                t=j;<br>       st[t]=<span class="hljs-literal">true</span>;<br>       <span class="hljs-comment">//最优路径</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>       dist[j]=<span class="hljs-built_in">min</span>(dist[j],dist[t]+g[t][j]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n]==<span class="hljs-number">0x3f3f3f3f</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><pre><code class="hljs">acwing849 模板题</code></pre><p>给定一个 n 个点 m条边的有向图，图中可能存在重边和自环，所有边权均为正值。<br>请你求出 1号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含整数 n和 m。<br>接下来 m行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示 1号点到 n号点的最短距离。如果路径不存在，则输出 −1。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤n≤500,1≤m≤105,图中涉及边长均不超过10000。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="hljs">3 31 2 22 3 11 3 4</code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="hljs">3</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 1000</span><br><span class="hljs-type">bool</span> vis[MAX];<br><span class="hljs-type">int</span> dist[MAX],g[MAX][MAX];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstrac</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[start]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> t=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>            <span class="hljs-comment">//寻找</span><br>            <span class="hljs-keyword">if</span>(!vis[j]&amp;&amp;(t==<span class="hljs-number">-1</span>||dist[j]&lt;dist[t]))<br>                t=j;<br><br>       vis[t]=<span class="hljs-literal">true</span>;<br>       <span class="hljs-comment">//最优路径</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>            dist[j]=<span class="hljs-built_in">min</span>(dist[j],dist[t]+g[t][j]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n]==<span class="hljs-number">0x3f3f3f3f</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(g));<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-type">int</span> u,v,dis;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        cin&gt;&gt;u&gt;&gt;v&gt;&gt;dis;<br>        g[u][v]=<span class="hljs-built_in">min</span>(g[u][v],dis);<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-built_in">dijkstrac</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用邻接链表"><a href="#使用邻接链表" class="headerlink" title="使用邻接链表"></a>使用邻接链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 300</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-type">int</span> n,m,num_edge;<br><span class="hljs-type">int</span> dis[MAX],head[MAX];<br><span class="hljs-type">bool</span> vis[MAX];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> from,to,dis,next;<br>&#125;edge[MAX];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>    dis[start]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> u;<br>        <span class="hljs-type">int</span> minn=INF;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        <span class="hljs-keyword">if</span>(!vis[j]&amp;&amp;dis[j]&lt;minn)&#123;<br>                u=j;<br>                minn=dis[j];<br>        &#125;<br>        vis[u]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=head[u];j!=<span class="hljs-number">0</span>;j=edge[j].next)<br>            <span class="hljs-keyword">if</span>(!vis[edge[j].to]&amp;&amp;(dis[u]+edge[j].dis&lt;dis[edge[j].to]))<br>                dis[edge[j].to]=dis[u]+edge[j].dis;<br><br>    &#125; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> from,<span class="hljs-type">int</span> to,<span class="hljs-type">int</span> dis)</span></span>&#123;<br>edge[++num_edge].next=head[from];<br>edge[num_edge].from=from;<br>edge[num_edge].to=to;<br>edge[num_edge].dis=dis;<br>head[from]=num_edge;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> u,v,w;<br>    cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)  head[i]=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;<br>            cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>            <span class="hljs-built_in">add</span>(u,v,w);<br>&#125;<br><span class="hljs-built_in">dijkstra</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(dis[n]==<span class="hljs-number">0x3f3f3f3f</span>)cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br><span class="hljs-keyword">else</span> cout&lt;&lt;dis[n];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用邻接表-堆优化"><a href="#使用邻接表-堆优化" class="headerlink" title="使用邻接表+堆优化"></a>使用邻接表+堆优化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> N,M,X;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX=<span class="hljs-number">100001</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">bool</span> vis[MAX];<br><span class="hljs-type">int</span> head[MAX],dis1[MAX],dis[MAX],num_edge;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>&#123;<br>    <span class="hljs-type">int</span> from,to,next,dis;<br>&#125;edge[MAX];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> id;<br><span class="hljs-type">int</span> d;<br><span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (node a,node b)&#123;<br><span class="hljs-keyword">return</span> a.d&gt;b.d;<br>&#125;<br>&#125;;<br>priority_queue&lt;node&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span>&#123;<br>    edge[++num_edge].next=head[u];<br>    edge[num_edge].from=u;<br>    edge[num_edge].to=v;<br>    edge[num_edge].dis=w;<br>    head[u]=num_edge;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span></span>&#123;<br><span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis)); <br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dis));<span class="hljs-comment">//初始化距离数组 </span><br>    node st;<br>    st.id=start;st.d=dis[start]=<span class="hljs-number">0</span>;<span class="hljs-comment">//1点入队 </span><br>    q.<span class="hljs-built_in">push</span>(st);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>    node hh=q.<span class="hljs-built_in">top</span>();<br>    <span class="hljs-type">int</span> u=hh.id;<br>    q.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span>(vis[u]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//若该点已经已知最短距离，访问过，则继续看下一个点</span><br>    vis[u]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=head[u];j!=<span class="hljs-number">0</span>;j=edge[j].next)&#123;<span class="hljs-comment">//松弛操作</span><br>    <span class="hljs-type">int</span> temp=edge[j].to;<br>    <span class="hljs-keyword">if</span>(!vis[temp]&amp;&amp;(dis[u]+edge[j].dis&lt;dis[temp]))<span class="hljs-comment">//更新，入队</span><br>       &#123;<br>        dis[temp]=dis[u]+edge[j].dis;<br>        node tt;<br>        tt.id=temp;tt.d=dis[temp];<br>        q.<span class="hljs-built_in">push</span>(tt);<br>        &#125;<br>    &#125;        <br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> u,v,w;<br>    cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)  head[i]=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;<br>            cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>            <span class="hljs-built_in">add</span>(u,v,w);<br>&#125;<br><span class="hljs-built_in">dijkstra</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(dis[n]==<span class="hljs-number">0x3f3f3f3f</span>)cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br><span class="hljs-keyword">else</span> cout&lt;&lt;dis[n];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包入门</title>
    <link href="/2022/07/16/%E8%83%8C%E5%8C%85%E5%85%A5%E9%97%A8/"/>
    <url>/2022/07/16/%E8%83%8C%E5%8C%85%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="背包笔记"><a href="#背包笔记" class="headerlink" title="背包笔记"></a>背包笔记</h1><p>大部分内容参考来自这篇文章<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="背包九讲 https://www.cnblogs.com/jbelial/articles/2116074.html">[1]</span></a></sup>和wiki上的内容<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="OI-WIKI">[2]</span></a></sup>。</p><h1 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h1><blockquote><p>题目:有N件物品和一个容量为V的背包。第i件物品的费用是v[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </p></blockquote><p>这是最基础的背包问题，后面的背包问题都由01背包问题衍生。问题的特点是：每种物品仅有一件，只能选择放或不放。 </p><p>如果这个问题采用枚举的思想，他的时间复杂度为$O(n^2)$，我们可以利用一张二维表记录数据，运用递推，这样时间复杂度就降低为$O(N*V)$</p><p>基本思路：用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：f[i][v]&#x3D;max{f[i-1][v],f[i-1][v-c[i]]+w[i]}。 具体来说就是我们就利用一张二位表，记录了整个题目中每一个问题的解答。</p><p>用一个例子来讲大致是什么</p><blockquote><p>输入</p><blockquote><p>4 5<br>1 2<br>2 4<br>3 4<br>4 5</p></blockquote></blockquote><blockquote><p>输出</p><blockquote><p>8</p></blockquote></blockquote><p>这个例子我们可以利用一张二维表来直观展示表示</p><p><img src="https://gitee.com/liahnu/img/raw/master/img/202112251111153.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> w[<span class="hljs-number">1002</span>],v[<span class="hljs-number">1002</span>];<br><span class="hljs-type">int</span> f[<span class="hljs-number">1002</span>][<span class="hljs-number">1002</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> N,V;<br>    cin&gt;&gt;N&gt;&gt;V;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)&#123;<br>        cin&gt;&gt;v[i]&gt;&gt;w[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j &lt; v[i]) <br>                f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">else</span>    <br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i - <span class="hljs-number">1</span>][j - v[i]] + w[i]);<br>        &#125; <br>    &#125;<br>    cout&lt;&lt;f[N][V];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>对于这个代码的优化,其中时间复杂度基本已经不能再优化了，我们可以将他改为一维数组,这样空间复杂度却可以优化到O(V)。</p><p>注意改成一维数组后要从后往前逆序推，如果正推一个物品会取多次，这也是完全背包的解法。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> w[<span class="hljs-number">1002</span>],v[<span class="hljs-number">1002</span>];<br><span class="hljs-type">int</span> f[<span class="hljs-number">1002</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> N,V;<br>    cin&gt;&gt;N&gt;&gt;V;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)&#123;<br>        cin&gt;&gt;v[i]&gt;&gt;w[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = V; j &gt;= v[i]; j--)<br>        &#123;<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>        &#125; <br>    &#125;<br>    cout&lt;&lt;f[V];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。 </p><h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><p>完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。</p><p>我们可以借鉴 0-1 背包的思路，进行状态定义。其状态转移方程依然还是：<code>f[i][v]=max&#123;f[i-1][v],f[i-1][v-c[i]]+w[i]&#125;</code>。但其推到方式与0-1背包不同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> w[<span class="hljs-number">1002</span>],v[<span class="hljs-number">1002</span>];<br><span class="hljs-type">int</span> f[<span class="hljs-number">1002</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> N,V;<br>    cin&gt;&gt;N&gt;&gt;V;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)&#123;<br>        cin&gt;&gt;v[i]&gt;&gt;w[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = v[i]; j &lt;=M ; j++)<br>        &#123;<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>        &#125; <br>    &#125;<br>    cout&lt;&lt;f[V];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h1><pre><code class="hljs">【题目描述】设有n种物品，每种物品有一个重量及一个价值。但每种物品的数量是无限的，同时有一个背包，最大载重量为M，今从n种物品中选取若干件(同一种物品可以多次选取)，使其重量的和小于等于M，而价值的和为最大。【输入】第一行：两个整数，M(背包容量，M≤200)和N(物品数量，N≤30)；第2..N+1行：每行二个整数Wi,Ci，表示每个物品的重量和价值。【输出】仅一行，一个数，表示最大总价值。【输入样例】10 42 13 34 57 9【输出样例】12</code></pre><p>可以用和01背包一样的方式，f[i][v]表示前i种物品恰放入一个容量为v的背包的最大价值，可以用k表示当前容量下可以装第i种物品的件数，那么k的范围应该是0≤k≤v&#x2F;c[i]，既然要用当前物品i把当前容量装满那需要0≤k≤v&#x2F;c[i]件，其中k表示件数。<br>状态转移方程为：<code>f[i][v] = max&#123;f[i-1][v],f[i-1][j - k * c[i]] + k * w[i]&#125;(0&lt;=k*c[i]&lt;=v)</code></p><p>基于01背包问题的代码进行简单修改，我们可以写出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> c[<span class="hljs-number">1002</span>],w[<span class="hljs-number">1002</span>];<br><span class="hljs-type">int</span> f[<span class="hljs-number">1002</span>][<span class="hljs-number">1002</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> N,V;<br>    cin&gt;&gt;V&gt;&gt;N;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)&#123;<br>        cin&gt;&gt;c[i]&gt;&gt;w[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;=N; i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= V; j++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k*c[i] &lt;= j; k++)&#123;<br>                f[i][j] =<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j],f[i<span class="hljs-number">-1</span>][j-k*c[i]]+k*w[i]) ;<br>        <span class="hljs-comment">//要么不取，要么取0件、取1件、取2件……取k件</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;f[N][V];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二进制分组优化"><a href="#二进制分组优化" class="headerlink" title="二进制分组优化"></a>二进制分组优化</h2><p>在朴素的做法中，一个一个枚举通常效率低下，因为在逐个枚举的过程中，出现了同时选了等效的问题，我们可以对数量进行二进制分组。</p><pre><code class="hljs">例子6=1+2+38=1+2+3+1</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>  <span class="hljs-type">int</span> c = <span class="hljs-number">1</span>, p, h, k;<br>  cin &gt;&gt; p &gt;&gt; h &gt;&gt; k;<br>  <span class="hljs-keyword">while</span> (k - c &gt; <span class="hljs-number">0</span>) &#123;<br>    k -= c;<br>    list[++index].w = c * p;<br>    list[index].v = c * h;<br>    c *= <span class="hljs-number">2</span>;<br>  &#125;<br>  list[++index].w = p * k;<br>  list[index].v = h * k;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h2><p>（不会，暂时空着）</p><h1 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h1><p>混合背包就是将前面三种的背包问题混合起来，有的只能取一次，有的能取无限次，有的只能取  次。</p><p>这种题目看起来很吓人，可是只要领悟了前面几种背包的中心思想，并将其合并在一起就可以了。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>背包九讲 <a href="https://www.cnblogs.com/jbelial/articles/2116074.html">https://www.cnblogs.com/jbelial/articles/2116074.html</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>OI-WIKI<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Floyd算法入门</title>
    <link href="/2022/05/16/Floyd%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"/>
    <url>/2022/05/16/Floyd%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="所有顶点对间的最短路径问题（Floyd算法）"><a href="#所有顶点对间的最短路径问题（Floyd算法）" class="headerlink" title="所有顶点对间的最短路径问题（Floyd算法）"></a>所有顶点对间的最短路径问题（Floyd算法）</h1><p>Floyd算法又称为弗洛伊德算法，插点法，是一种用于寻找给定的加权图中顶点间最短路径的算法。简称Floyed(弗洛伊德)算法，是最简单的最短路径算法，可以计算图中任意两点间的最短路径。</p><p>Floyd的时间复杂度是$O (N^3)$，适用于出现负边权的情况。</p><h2 id="算法的基本思想："><a href="#算法的基本思想：" class="headerlink" title="算法的基本思想："></a>算法的基本思想：</h2><p>开始时，以任意两个顶点之间的有向边的权值作为路径长度，没有有向边时，路径长度为∞<br>以后逐步尝试在原路径中加入其它顶点作为中间顶点，如果增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径，修改矩阵元素。</p><h2 id="算法描述："><a href="#算法描述：" class="headerlink" title="算法描述："></a>算法描述：</h2><p>二维数组存储最短路径，如果要求输出任意两个顶点间的最短路径，经过的顶点也要输出的话，根据题目要求可定义成三维数组存储路径经过的顶点，再进行适当的算法后对这两个数组进行输出即可</p><ol><li><p>初始化：点u、v如果有边相连，则<code>dis[u][v]=w[u][v]</code>。<br>如果不相连则<code>memset(dis,INT_MAX,sizeof(dis))</code></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++) <span class="hljs-comment">//k必须在外层</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)       <br>            <span class="hljs-keyword">if</span>(dis[i][j]&gt;dis[i][k]+dis[k][j])<br>                dis[i][j]=dis[i][k]+dis[k][j];<br></code></pre></td></tr></table></figure></li><li><p>算法结束：dis即为所有点对的最短路径矩阵</p></li></ol><h2 id="算法分析-amp-思想讲解："><a href="#算法分析-amp-思想讲解：" class="headerlink" title="算法分析&amp;思想讲解："></a>算法分析&amp;思想讲解：</h2><p>三层循环，第一层循环中间点k，第二第三层循环起点终点i、j<br>算法的思想很容易理解：如果点i到点k的距离加上点k到点j的距离小于原先点i到点j的距离，那么就用这个更短的路径长度来更新原先点i到点j的距离。</p><p>在下图中，因为<code>dis[1][3]+dis[3][2]&lt;dis[1][2]</code>，所以就用<code>dis[1][3]+dis[3][2]</code>来更新原先1到2的距离。</p><p>我们在初始化时，把不相连的点之间的距离设为一个很大的数，不妨可以看作这两点相隔很远很远，如果两者之间有最短路径的话，就会更新成最短路径的长度。<br>Floyed算法的时间复杂度是$O(N^3)$ 。</p><pre class="mermaid">graph LRA(1) -->|6|B(2)B(2) -->|1|C(3)C(3) -->|2|A(1);</pre><h2 id="Floyed算法优缺点分析"><a href="#Floyed算法优缺点分析" class="headerlink" title="Floyed算法优缺点分析"></a>Floyed算法优缺点分析</h2><p>Floyd算法适用于APSP(All Pairs Shortest Paths)，是一种动态规划算法，稠密图效果最佳，边权可正可负,适用于解决所有顶点对间的最短路径问题。此算法简单有效，由于三重循环结构紧凑，对于稠密图，效率要高于执行$V$次DijkStra算法。<br>注意同坐标求长度的公式（三角形勾股定理）<br>但不能解决带有“负权环路”（或者叫“负权环”）的图。如下图：</p><pre class="mermaid">graph LRA(1) -->|-6|B(2)B(2) -->|1|C(3)C(3) -->|2|A(1);</pre><p><strong>优点</strong>：容易理解，可以算出任意两个节点之间的最短距离，代码编写简单； </p><p><strong>缺点</strong>：时间复杂度比较高，不适合计算大量数据。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
