---
layout: p
title: 常见八股文集合
date: 2024-03-20 13:07:17
tags: [Java,Mysql,Redis]
---

# Java

## List、Set、Map的区别

- List：有序，可重复，底层是数组（或链表）
- Set：无序，不可重复，底层是哈希表
- Map：无序，key不可重复，value可重复，底层是哈希表

## ListArrayList和LinkedList的区别

- ArrayList：底层是数组，查询快，增删慢
- LinkedList：底层是链表，查询慢，增删快

## HashMap和HashTable的区别

- HashMap：线程不安全，允许key和value为null
- HashTable：线程安全，不允许key和value为null

## ConcurrentHashMap,HashMap和HashTable的区别

- HashMap：线程不安全，效率高，允许key和value为null
- ConcurrentHashMap：线程安全，效率高，允许key和value为null
- HashTable：线程安全，效率低，不允许key和value为null

## ConcurrentHashMap的实现原理

ConcurrentHashMap是Java中的一个线程安全的哈希表，它的实现原理是分段锁。ConcurrentHashMap中有一个Segment数组，每个Segment都是一个哈希表，每个Segment都是一个独立的锁，这样就可以实现对每个Segment的并发访问，从而提高了并发访问的效率。

## java的反射机制

Java的反射机制是指在运行时动态获取类的信息，比如类的属性、方法、构造器等。Java的反射机制主要是通过Class类来实现的，Class类是Java中的一个类，它是一个类的类，它是一个类的模板，它是一个类的元数据，它是一个类的描述。

## == 和 equals 的区别

- ==：比较的是两个对象的内存地址
- equals：比较的是两个对象的内容

**例子**
```java
String s1 = new String("abc");
String s2 = new String("abc");
System.out.println(s1 == s2); // false
System.out.println(s1.equals(s2)); // true
```

# JUC

## 乐观锁悲观锁

- 乐观锁：乐观锁是一种乐观的思想，它认为并发访问的情况是比较少的，所以在读取数据的时候不加锁，只在更新数据的时候加锁，这样可以提高并发访问的效率。
- 悲观锁：悲观锁是一种悲观的思想，它认为并发访问的情况是比较多的，所以在读取数据的时候加锁，这样可以保证并发访问的安全性。

### 乐观锁的实现
乐观锁的实现主要是通过CAS操作和版本号来实现的，CAS操作是一种乐观锁的实现方式，它的实现是基于CPU的原子操作指令。
CAS操作包括了3个操作数：

- 需要读写的内存位置(V)
- 进行比较的预期值(A)
- 拟写入的新值(B)

当一个线程获取锁的时候，会尝试使用CAS操作来获取锁，如果CAS操作失败，那么就会尝试重新获取锁，直到获取锁成功。

版本号机制是在每次修改数据的时候，都会修改版本号，这样在使用CAS进行检查的时候，就可以检查版本号是否发生变化。

**乐观锁的优缺点**
与悲观锁相比，乐观锁适用的场景受到了更多的限制，无论是CAS还是版本号机制。

例如，CAS只能保证单个变量操作的原子性，当涉及到多个变量时，CAS是无能为力的，而synchronized则可以通过对整个代码块加锁来处理。再比如版本号机制，如果query的时候是针对表1，而update的时候是针对表2，也很难通过简单的版本号来实现乐观锁。

当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。
当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源。

### 悲观锁的实现

悲观锁的实现主要是通过synchronized关键字来实现的，synchronized是Java中最基本的同步手段，它保证了线程的安全性，但是它的性能开销也是比较大的。

# Spring框架

## Spring的IOC和AOP

- IOC：控制反转，是一种设计思想，它的核心思想是将对象的创建和对象之间的依赖关系的管理交给Spring容器来管理，而不是由程序员来管理。
- AOP：面向切面编程，是一种设计思想，它的核心思想是将程序的业务逻辑和系统服务分离，通过对系统服务的封装，将系统服务的功能切面化，然后通过切面的方式将系统服务的功能插入到业务逻辑中。



# 计算机网络

## tcp三次握手，四次挥手

TCP是面向连接的，可靠的，基于字节流的传输层协议。TCP连接的建立和断开都需要经过三次握手和四次挥手。

**TPC的三次握手（建立连接）** 
1. SYN：客户端发送一个SYN（同步）包到服务器，以请求建立连接。这个包包含一个随机的序列号A。
2. SYN-ACK：服务器收到SYN包后，会发送一个SYN-ACK（同步-确认）包到客户端。这个包包含一个自己的随机序列号B，和对客户端序列号A的确认（即A+1）。
3. ACK：客户端收到SYN-ACK包后，会发送一个ACK（确认）包到服务器。这个包包含对服务器序列号B的确认（即B+1）。

**TCP的四次挥手（断开连接）**
1. FIN：当数据传输完毕，客户端会发送一个FIN（结束）包到服务器，请求断开连接。
2. ACK：服务器收到FIN包后，会发送一个ACK（确认）包到客户端，确认收到了FIN包。但是，服务器可能还有数据需要传输到客户端，所以不会立即关闭连接。
3. FIN：当服务器数据都传输完毕，会发送一个FIN（结束）包到客户端，请求断开连接。
4. ACK：客户端收到FIN包后，会发送一个ACK（确认）包到服务器，确认收到了FIN包。然后，客户端会等待一段时间（两个最大段生存时间），确保服务器收到了ACK包，然后关闭连接。

## tcp和udp的区别


# Redis

## Redis的数据结构

Redis支持五种数据结构：String、List、Set、Hash、ZSet。

## 讲一下缓存三兄弟（缓存穿透、缓存击穿、缓存雪崩）

- 缓存穿透：指的是查询一个不存在的数据，由于缓存中没有，所以每次都会去数据库中查询，这样会导致数据库压力过大。
- 缓存击穿：指的是一个热点数据突然失效，导致大量请求直接打到数据库上，这样会导致数据库压力过大。
- 缓存雪崩：指的是缓存中的大量数据同时失效，导致大量请求直接打到数据库上，这样会导致数据库压力过大。

**缓存穿透的解决方法**
1. 布隆过滤器：将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉。
2. 空对象缓存：如果一个查询返回的数据为空（不管是数据不存在还是数据被删除），我们也可以将这个空结果进行缓存，但是需要设置一个较短的过期时间。

**缓存击穿的解决方法**
1. 设置热点数据永不过期。
2. 加互斥锁：在缓存失效的时候，加互斥锁，只允许一个线程去查询数据库，其他线程等待。

**缓存雪崩的解决方法**
1. 加互斥锁：在缓存失效的时候，加互斥锁，只允许一个线程去查询数据库，其他线程等待。
2. 设置不同的过期时间：不同的数据设置不同的过期时间，避免大量数据同时失效。

## Redis的持久化机制（RDD和AOF）

Redis的持久化机制有两种：RDB快照和AOF日志。

- RDB快照：是指在指定的时间间隔内将内存中的数据保存到磁盘上，生成一个快照文件。RDB快照是一个二进制文件，它保存了某个时间点上的所有数据。
- AOF日志：是指在每次写操作时，将写操作的命令追加到AOF文件的末尾。AOF日志是一个文本文件，它保存了所有的写操作命令。

# MySQL

## mysql的锁

MySQL的锁主要有两种：共享锁和排他锁。
- 共享锁：是一种读锁，它允许多个事务同时对同一行数据进行读操作，但是不允许对同一行数据进行写操作。
- 排他锁：是一种写锁，它不允许其他事务对同一行数据进行读操作和写操作。

## Mysql索引优缺点

**优点**
1. 提高查询速度：索引可以大大提高查询速度。
2. 加速表和表之间的连接：通过索引可以加速表和表之间的连接。
3. 唯一性约束：可以保证表中每一行数据的唯一性。

**缺点**
1. 索引会占用磁盘空间：索引会占用磁盘空间。
2. 索引会降低写操作的速度：因为每次写操作都需要更新索引。
3. 索引会降低查询速度：因为每次查询都需要查找索引。

**什么时候能用索引**

- 经常作为查询条件的字段，如果需要同时查找多个字段，可以建立联合索引
- 经常放到GROUP BY或者ORDER BY后面的字段，进行GROUP BY或者ORDER BY都会对数据进行排序，这些字段就可以建立一个索引，这样就不需要每次都进行排序了

**什么情况下不可以使用索引？**

- 不经常作为查询条件的字段
- 不经常放到GROUP BY或者ORDER BY后面的字段
- 重复率高的字段，比如性别，建立索引并不会明显提高查询效率，毕竟索引也需要占空间。
- 表数据量很少的时候，全表查也非常快，你创建维护索引反倒需要开销。
- 经常需要更新的字段，如果建立了索引，索引也需要频繁维护（B+树是要保证数据有序的），会影响数据更新的效率。

## MySQL联合索引

MySQL的联合索引，也被称为复合索引或多列索引，是一种在多个列上创建的索引。联合索引可以提高查询性能，特别是在你需要从多个列中检索数据时。


联合索引的工作原理是，它会根据索引中的列顺序，首先对第一列进行排序，然后在每个相同的第一列值中，对第二列进行排序，以此类推。因此，你可以在查询中使用任何前缀列（即索引中的第一列，第一列和第二列，等等）来利用联合索引。