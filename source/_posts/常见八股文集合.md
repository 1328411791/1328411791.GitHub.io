---
layout: p
title: 常见八股文集合
date: 2024-03-20 13:07:17
tags: [Java,Mysql,Redis]
---

# Java

## == 和 equals的区别

1. ==针对基本类型时比较的是对象的值，针对引用类型比较的是对象的指向的内存地址是否相等。

2. equals针对的比较对象是引用类型， 在Java中Object对象是所有对象的父类，所以每个类都会有个equals的方法，如果你没有重写它那些它与==的效果是一样的，可以通过源代码查看。


**例子**
```java
String s1 = new String("abc");
String s2 = new String("abc");
System.out.println(s1 == s2); // false
System.out.println(s1.equals(s2)); // true
```

## String StringBuilder StringBuffer的区别

- String：不可变的字符序列，线程安全，适用于字符串不经常改变的场景。
- StringBuilder：可变的字符序列，线程不安全，适用于字符串经常改变的场景。
- StringBuffer：可变的字符序列，线程安全，适用于字符串经常改变的场景。

1、String类型的字符串对象是不可变的，一旦String对象创建后，包含在这个对象中的字符系列是不可以改变的，直到这个对象被销毁。
2、StringBuilder和StringBuffer类型的字符串是可变的，不同的是StringBuffer类型的是线程安全的，而StringBuilder不是线程安全的
3、如果是多线程环境下涉及到共享变量的插入和删除操作，StringBuffer则是首选。如果是非多线程操作并且有大量的字符串拼接，插入，删除操作则StringBuilder是首选。毕竟String类是通过创建临时变量来实现字符串拼接的，耗内存还效率不高，怎么说StringBuilder是通过JNI方式实现终极操作的。
4、StringBuilder和StringBuffer的“可变”特性总结如下：
（1）append，insert，delete方法最根本上都是调用System.arraycopy()这个方法来达到目的
（2）substring(int, int)方法是通过重新new String(value, start, end - start)的方式来达到目的。


## List、Set、Map的区别

- List：有序，可重复，底层是数组（或链表）
- Set：无序，不可重复，底层是哈希表
- Map：无序，key不可重复，value可重复，底层是哈希表

## ArrayList和LinkedList的区别

- ArrayList：底层是数组，查询快，增删慢
- LinkedList：底层是链表，查询慢，增删快

**ArrayList的扩容策略**

ArrayList的扩容策略是每次扩容为原来的1.5倍，当数组长度小于10时，每次扩容为原来的2倍。
最大容量为Integer.MAX_VALUE - 8。

**ArrayList的默认大小**
如果使用无参构造函数ArrayList()创建一个空的ArrayList对象,那么它的初始容量为10。

## 介绍一下Stream流的并行API Parallelstream

ParallelStream通过内部使用Fork/Join框架实现并行处理。当你调用Collection的parallelStream方法时，你会得到一个ParallelStream对象。


## HashMap和HashTable的区别

- HashMap：线程不安全，允许key和value为null
- HashTable：线程安全，不允许key和value为null

## ConcurrentHashMap,HashMap和HashTable的区别

- HashMap：线程不安全，效率高，允许key和value为null
- ConcurrentHashMap：线程安全，效率高，允许key和value为null
- HashTable：线程安全，效率低，不允许key和value为null

## ConcurrentHashMap的实现原理

ConcurrentHashMap是Java中的一个线程安全的哈希表，它的实现原理是分段锁。ConcurrentHashMap中有一个Segment数组，每个Segment都是一个哈希表，每个Segment都是一个独立的锁，这样就可以实现对每个Segment的并发访问，从而提高了并发访问的效率。

## java的反射机制

Java的反射机制是指在运行时动态获取类的信息，比如类的属性、方法、构造器等。Java的反射机制主要是通过Class类来实现的，Class类是Java中的一个类，它是一个类的类，它是一个类的模板，它是一个类的元数据，它是一个类的描述。

## ThreadLocal的使用场景有哪些？原理？内存泄漏？

ThreadLocal，即线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。

ThreadLocal原理

- Thread对象中持有一个ThreadLocal.里面有个ThreadLocalMap的成员变量。
- ThreadLocalMap内部维护了Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal本身，value是ThreadLocal的泛型值。
- 每个线程在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。

**内存泄漏**
因为ThreadLocalMap中使用的 key 为 ThreadLocal 的弱引用：

**弱引用：**只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存。

弱引用比较容易被回收。因此，如果ThreadLocal（ThreadLocalMap的Key）被垃圾回收器回收了，但是因为ThreadLocalMap生命周期和Thread是一样的，它这时候如果不被回收，就会出现这种情况：ThreadLocalMap的key没了，value还在，这就会造成了内存泄漏问题。

解决内存泄漏问题，使用完ThreadLocal后，**及时调用remove()方法**释放内存空间。

# JVM

## JVM的内存结构

JVM的内存结构大致分为五个部分，分别是程序计数器、虚拟机栈、本地方法栈、堆和方法区。除此之外，还有由堆中引用的JVM外的直接内存。

**JDK1.7以前的内存区域**
![](https://pic.liahnu.top/img/202403281536095.png)

**JDK1.8以后的内存区域**
![](https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png)

1.8之后的内存区域中，永久代被元空间取代，字符串常量池和运行时常量池被合并为一个运行时常量池。

## 堆的内存结构

Java堆是Java虚拟机管理的内存中最大的一块，主要用于存放对象实例。Java堆是垃圾收集器管理的主要区域，因此也被称为GC堆。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。

**对象什么时候进入Survivor区**
当Eden区满时，会触发Minor GC，将Eden区中的存活对象复制到S0或S1中，然后清理掉Eden区中的所有对象。在多次Minor GC之后，存活时间较长的对象会被移动到老年代。

**对象什么情况下一直不会进入老年代**
如果对象在Eden区被创建，那么它在第一次Minor GC后，会被移动到Survivor区，如果在Survivor区被创建，那么它在第二次Minor GC后，会被移动到老年代。

## JVM的垃圾回收器

JVM的垃圾回收器主要分为两大类：串行垃圾回收器和并行垃圾回收器。

**Serial垃圾收集器**
Serial垃圾回收器是串行垃圾回收器，它是单线程的，只会使用一个线程来进行垃圾回收。Serial垃圾回收器适用于单核CPU的环境。

新生代采用标记-复制算法，老年代采用标记-整理算法。

**ParNew垃圾收集器**

ParNew垃圾回收器是Serial垃圾回收器的多线程版本，它是并行垃圾回收器，适用于多核CPU的环境。

**Parallel Scavenge 垃圾收集器**

Parallel Scavenge垃圾回收器是并行垃圾回收器，它适用于多核CPU的环墋，它的特点是吞吐量优先，适用于后台运行的应用。

**Serial Old垃圾收集器**

Serial Old垃圾回收器是Serial垃圾回收器的老年代版本，它是单线程的，适用于单核CPU的环境。

**Parallel Old垃圾收集器**

Parallel Old垃圾回收器是Parallel Scavenge垃圾回收器的老年代版本，它是并行垃圾回收器，适用于多核CPU的环境。

**CMS垃圾收集器**

CMS垃圾回收器是并发垃圾回收器，它是一种以获取最短回收停顿时间为目标的收集器，适用于对响应时间有要求的应用。

**G1垃圾收集器**

G1垃圾回收器是一种面向服务端应用的垃圾回收器，它是一种并发的、基于标记-整理算法的垃圾回收器，适用于多核CPU的环境。

**ZGC垃圾收集器**

ZGC垃圾回收器是一种低延迟的垃圾回收器，它是一种并发的、基于标记-整理算法的垃圾回收器，适用于对响应时间有要求的应用。

## JVM的垃圾回收算法


# JUC

## Runable和Callable有什么区别

1. Runnable是Java中的一个接口，它只有一个run方法，没有返回值，不能抛出异常。
2. Callable是Java中的一个接口，它有一个call方法，有返回值，可以抛出异常。

## 启动一个线程是用start()还是run()方法

启动一个线程是用start()方法，而不是run()方法。如果你调用run()方法，那么这个方法就会在当前线程中执行，而不会启动一个新的线程。

## 线程池原理？各个参数的作用

```java
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime,TimeUnit unit,
   BlockingQueue<Runnable> workQueue,
   ThreadFactory threadFactory,
   RejectedExecutionHandler handler) 
```

**几个核心参数的作用：**

- corePoolSize：线程池核心线程数最大值
- maximumPoolSize：线程池最大线程数大小
- keepAliveTime：线程池中非核心线程空闲的存活时间大小
- unit：线程空闲存活时间单位
- workQueue：存放任务的阻塞队列
- threadFactory：用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。
- handler： 线城池的饱和策略事件，主要有四种类型。

**四种饱和拒绝策略**

- AbortPolicy(抛出一个异常，默认的)
- DiscardPolicy(直接丢弃任务)
- DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）
- CallerRunsPolicy（交给线程池调用所在的线程进行处理)

**工作队列的类型**
- ArrayBlockingQueue：基于数组的有界阻塞队列
- LinkedBlockingQueue：基于链表的有界阻塞队列
- SynchronousQueue：不存储元素的阻塞队列
- PriorityBlockingQueue：具有优先级的无界阻塞队列

**几种线程池**

- newFixedThreadPool：固定大小的线程池
- newSingleThreadExecutor：单个线程的线程池
- newCachedThreadPool：可缓存的线程池，线程池的大小是没有限制的
- newScheduledThreadPool：定时任务的线程池

## Cpu密集型和IO密集型  N+1  2N  具体是如何计算的

- CPU密集型：CPU密集型是指CPU的使用率非常高，而I/O操作非常少的程序。CPU密集型程序的特点是CPU使用率很高，而内存和硬盘I/O操作的使用率很低。
- IO密集型：IO密集型是指I/O操作非常频繁的程序。IO密集型程序的特点是CPU使用率很低，而内存和硬盘I/O操作的使用率很高。

其中n+1和2n是上文中线程池设置线程的数量；

主要是因为，如果线程数量太多的话，线程的竞争大，会导致大量上下文切换，因为CPU是分配给时间片给线程来处理任务的，时间片一到，那么线程就得保存当前任务，等待下一次CPU分配时间片，那么下一次线程获取到CPU时间片之后，会重新加载任务来处理，保存到加载的过程就称之为上问下切换。

**CPU n+1**
如果程序的计算量特别高，那么就属于CPU密集型，线程数量可以设置为N（CPU的核心数）+1。

**I/O密集型（2N）**
如果程序的是网络传输或者I/O操作比较多，那么线程池应该设置为2N。

## 乐观锁悲观锁

- 乐观锁：乐观锁是一种乐观的思想，它认为并发访问的情况是比较少的，所以在读取数据的时候不加锁，只在更新数据的时候加锁，这样可以提高并发访问的效率。
- 悲观锁：悲观锁是一种悲观的思想，它认为并发访问的情况是比较多的，所以在读取数据的时候加锁，这样可以保证并发访问的安全性。

### 乐观锁的实现
乐观锁的实现主要是通过CAS操作和版本号来实现的，CAS操作是一种乐观锁的实现方式，它的实现是基于CPU的原子操作指令。
CAS操作包括了3个操作数：

- 需要读写的内存位置(V)
- 进行比较的预期值(A)
- 拟写入的新值(B)

当一个线程获取锁的时候，会尝试使用CAS操作来获取锁，如果CAS操作失败，那么就会尝试重新获取锁，直到获取锁成功。

版本号机制是在每次修改数据的时候，都会修改版本号，这样在使用CAS进行检查的时候，就可以检查版本号是否发生变化。

**乐观锁的优缺点**
与悲观锁相比，乐观锁适用的场景受到了更多的限制，无论是CAS还是版本号机制。

例如，CAS只能保证单个变量操作的原子性，当涉及到多个变量时，CAS是无能为力的，而synchronized则可以通过对整个代码块加锁来处理。再比如版本号机制，如果query的时候是针对表1，而update的时候是针对表2，也很难通过简单的版本号来实现乐观锁。

当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。
当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源。

### 悲观锁的实现

悲观锁的实现主要是通过synchronized关键字来实现的，synchronized是Java中最基本的同步手段，它保证了线程的安全性，但是它的性能开销也是比较大的。

## volatile关键字

volatile是Java中的一个关键字，它的主要作用是保证变量的可见性和防止 JVM 的指令重排序。
在并发控制方面，主要是运用乐观锁的一种实现方式，底层有CAS操作，保证了变量的可见性，但是它并不能保证原子性。

## synchronized关键字

synchronized是Java中的一个关键字，它的主要作用是保证线程的安全性。
synchronized可以修饰代码块，也可以修饰方法，它的底层是通过monitor对象来实现的，monitor对象是每个Java对象都有的一个对象，它是一个互斥锁，保证了线程的安全性。

# Spring框架

## Spring的IOC和AOP

- IOC：控制反转，是一种设计思想，它的核心思想是将对象的创建和对象之间的依赖关系的管理交给Spring容器来管理，而不是由程序员来管理。
- AOP：面向切面编程，是一种设计思想，它的核心思想是将程序的业务逻辑和系统服务分离，通过对系统服务的封装，将系统服务的功能切面化，然后通过切面的方式将系统服务的功能插入到业务逻辑中。

## @Resource和@Autowired的区别是什么？

- @Resource：是JavaEE提供的注解，它是按照名称进行装配的，如果没有指定name属性，那么它会按照类型进行装配。
- @Autowired：是Spring提供的注解，它是按照类型进行装配的，如果有多个类型相同的bean，那么它会按照名称进行装配。

# 计算机网络

## tcp三次握手，四次挥手

TCP是面向连接的，可靠的，基于字节流的传输层协议。TCP连接的建立和断开都需要经过三次握手和四次挥手。

**TPC的三次握手（建立连接）** 
1. SYN：客户端发送一个SYN（同步）包到服务器，以请求建立连接。这个包包含一个随机的序列号A。
2. SYN-ACK：服务器收到SYN包后，会发送一个SYN-ACK（同步-确认）包到客户端。这个包包含一个自己的随机序列号B，和对客户端序列号A的确认（即A+1）。
3. ACK：客户端收到SYN-ACK包后，会发送一个ACK（确认）包到服务器。这个包包含对服务器序列号B的确认（即B+1）。

**TCP的四次挥手（断开连接）**
1. FIN：当数据传输完毕，客户端会发送一个FIN（结束）包到服务器，请求断开连接。
2. ACK：服务器收到FIN包后，会发送一个ACK（确认）包到客户端，确认收到了FIN包。但是，服务器可能还有数据需要传输到客户端，所以不会立即关闭连接。
3. FIN：当服务器数据都传输完毕，会发送一个FIN（结束）包到客户端，请求断开连接。
4. ACK：客户端收到FIN包后，会发送一个ACK（确认）包到服务器，确认收到了FIN包。然后，客户端会等待一段时间（两个最大段生存时间），确保服务器收到了ACK包，然后关闭连接。

## tcp和udp的区别

**连接性：**TCP是一种面向连接的协议，这意味着在数据传输之前，必须先建立连接。而UDP是无连接的，它只是发送数据，而不关心数据是否到达。

**可靠性：**TCP提供了数据传输的可靠性。它通过确认（ACK）、重传、错误检测等机制确保数据正确无误地从发送端传输到接收端。而UDP不提供这种可靠性，它只是简单地发送数据，不进行错误检测和修复。

**顺序：**TCP保证数据的顺序，即数据会按照发送的顺序到达接收端。而UDP不保证数据的顺序，数据报可能会乱序到达。

**速度：**由于TCP的可靠性和顺序保证机制，它的速度通常比UDP慢。而UDP由于其简单的协议结构，通常比TCP快。

**用途：**TCP通常用于需要高可靠性的应用，如Web服务器、邮件服务器等。而UDP通常用于对实时性要求高的应用，如视频流、VoIP等，这些应用可以容忍一些数据丢失，但需要快速传输。

**头部大小：**TCP的头部最小为20字节，而UDP的头部固定为8字节，因此UDP的开销更小。

**流控制和拥塞控制：**TCP有流控制和拥塞控制机制，可以防止发送端发送速度过快导致接收端或网络无法处理。而UDP没有这些控制机制。

# Redis

## Redis的数据结构

Redis支持五种数据结构：String、List、Set、Hash、ZSet。
此外，还有三种特殊的数据结构：HyperLogLog、Geo、Stream。

## 讲一下缓存三兄弟（缓存穿透、缓存击穿、缓存雪崩）

- 缓存穿透：指的是查询一个不存在的数据，由于缓存中没有，所以每次都会去数据库中查询，这样会导致数据库压力过大。
- 缓存击穿：指的是一个热点数据突然失效，导致大量请求直接打到数据库上，这样会导致数据库压力过大。
- 缓存雪崩：指的是缓存中的大量数据同时失效，导致大量请求直接打到数据库上，这样会导致数据库压力过大。

**缓存穿透的解决方法**
1. 布隆过滤器：将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉。
2. 空对象缓存：如果一个查询返回的数据为空（不管是数据不存在还是数据被删除），我们也可以将这个空结果进行缓存，但是需要设置一个较短的过期时间。

**缓存击穿的解决方法**
1. 设置热点数据永不过期。
2. 加互斥锁：在缓存失效的时候，加互斥锁，只允许一个线程去查询数据库，其他线程等待。

**缓存雪崩的解决方法**
1. 加互斥锁：在缓存失效的时候，加互斥锁，只允许一个线程去查询数据库，其他线程等待。
2. 设置不同的过期时间：不同的数据设置不同的过期时间，避免大量数据同时失效。

## Redis的持久化机制（RDB和AOF）

Redis的持久化机制有两种：RDB快照和AOF日志。

- RDB快照：是指在指定的时间间隔内将内存中的数据保存到磁盘上，生成一个快照文件。RDB快照是一个二进制文件，它保存了某个时间点上的所有数据。(有点像mysql的binlog)
- AOF日志：是指在每次写操作时，将写操作的命令追加到AOF文件的末尾。AOF日志是一个文本文件，它保存了所有的写操作命令。（像mysql的redolog）

## Redis宕机哪种恢复的快

RDB快照恢复的速度比AOF日志快，因为RDB快照是一个二进制文件，它保存了某个时间点上的所有数据，所以恢复速度比较快。

# MySQL

## MySQL的索引有哪些

MySQL的索引按照**物理存储**维度划分主要有以下几种：
- B+树索引：最常见的索引类型，适用于等值查询、范围查询、排序查询。
- 哈希索引：适用于等值查询，不适用于范围查询和排序查询。
- 全文索引：对文本的内容进行分词，进行搜索。目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。

MySQL的索引按照**应用**维度划分主要有以下几种：
- 主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。
- 普通索引：仅加速查询。唯一索引：加速查询 + 列值唯一（可以有 NULL）。
- 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。
- 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。
- 全文索引：对文本的内容进行分词，进行搜索。目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。

## MySQL的事物是基于什么实现的

MySQL的事务是基于InnoDB存储引擎实现的，InnoDB存储引擎是MySQL的默认存储引擎，支持事务、行级锁、外键等特性。

对于事务的实现，InnoDB存储引擎主要通过以下几个方面实现：

- **事务日志：** InnoDB存储引擎通过事务日志（redo log）实现事务的持久性，当事务提交时，将事务的操作记录到事务日志中，保证事务的持久性。
- **MVCC：** InnoDB存储引擎通过多版本并发控制（MVCC）实现事务的隔离性，通过保存数据的多个版本，实现事务的隔离性。
- **锁机制：** InnoDB存储引擎通过行级锁实现事务的隔离性，通过锁机制保证事务的隔禽性。

### 事务日志

InnoDB存储引擎通过事务日志（redo log）实现事务的持久性，当事务提交时，将事务的操作记录到事务日志中，保证事务的持久性。

MySQL的日志主要包括：
- 错误日志：记录MySQL的错误信息。
- 查询日志：记录MySQL的查询信息。
- 慢查询日志：记录MySQL的慢查询信息。
- 事务日志：记录MySQL的事务信息。
- 二进制日志：记录MySQL的数据更改信息。

其中比较重要的是**事务日志**和**二进制日志**，事务日志用于实现事务的持久性，二进制日志用于实现数据的备份和恢复。

**归档日志（binlog）**

MySQL的归档日志（redo log）是MySQL的二进制日志，用于记录MySQL的数据更改信息，主要用于数据的备份和恢复。

而 binlog 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。

他有三种格式
- Statement 格式：记录的是 SQL 语句，如 insert、update、delete 等。
- Row 格式：在Statement的基础上，记录的是行的内容，如记录的now()的具体数值。
- Mixed 格式：根据具体的 SQL 语句来决定使用哪种格式。

**重做日志（redo log）**

MySQL的重做日志（redo log）是InnoDB存储引擎的事务日志，用于实现事务的持久性，主要用于事务的恢复。

redo log 是物理日志，记录的是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎层。

**回滚日志（undo log）**

MySQL的回滚日志（undo log）是InnoDB存储引擎的事务日志，用于实现事务的隔离性，主要用于事务的回滚。


### MVCC

MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。

MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。

InnoDB存储引擎通过多版本并发控制（MVCC）实现事务的隔离性，通过保存数据的多个版本，实现事务的隔离性。

MVCC主要通过以下几个方面实现：
- 保存数据的多个版本：InnoDB存储引擎保存数据的多个版本，每个版本对应一个时间戳。
- 读取数据的版本控制：读取数据时，根据事务的隔离级别，读取对应的版本。
- 写入数据的版本控制：写入数据时，根据事务的隔离级别，生成新的版本。

MVCC主要用于实现事务的隔离性，通过保存数据的多个版本，实现事务的隔离性。

### 锁机制

InnoDB存储引擎通过行级锁实现事务的隔离性，通过锁机制保证事务的隔离性。

MySQL的锁主要有两种：共享锁和排他锁。
- 共享锁：是一种读锁，它允许多个事务同时对同一行数据进行读操作，但是不允许对同一行数据进行写操作。
- 排他锁：是一种写锁，它不允许其他事务对同一行数据进行读操作和写操作。

## 索引有哪些种类

MySQL的索引按照数据结构维度可分为：

- B+树索引：是一种多路搜索树，是一种平衡的多路搜索树，能够保持数据稳定有序，其插入和查询的时间复杂度都是O(logN)。
- 哈希索引：是一种哈希表，能够快速定位到数据，其插入和查询的时间复杂度都是O(1)。
- 全文索引：是一种全文搜索索引，能够对文本进行全文搜索。
- R-Tree索引：是一种空间索引，能够对空间数据进行搜索。

按照底层数据结构维度可分为：
- 聚类索引：是一种按照数据存储的物理顺序进行排序的索引。
- 非聚集索引：是一种按照数据存储的逻辑顺序进行排序的索引。

按照索引的应用维度可分为：
- 主键索引：是一种唯一索引，能够保证数据的唯一性。
- 普通索引：是一种普通的索引，能够提高查询速度。
- 唯一索引：是一种唯一索引，能够保证数据的唯一性。
- 覆盖索引：是一种覆盖查询索引，能够减少查询的IO操作。
- 联合索引：是一种联合索引，能够提高查询速度。
- 全文索引：是一种全文搜索索引，能够对文本进行全文搜索。

## Mysql索引优缺点

**优点**
1. 提高查询速度：索引可以大大提高查询速度。
2. 加速表和表之间的连接：通过索引可以加速表和表之间的连接。
3. 唯一性约束：可以保证表中每一行数据的唯一性。

**缺点**
1. 索引会占用磁盘空间：索引会占用磁盘空间。
2. 索引会降低写操作的速度：因为每次写操作都需要更新索引。
3. 索引会降低查询速度：因为每次查询都需要查找索引。

**什么时候能用索引**

- 经常作为查询条件的字段，如果需要同时查找多个字段，可以建立联合索引
- 经常放到GROUP BY或者ORDER BY后面的字段，进行GROUP BY或者ORDER BY都会对数据进行排序，这些字段就可以建立一个索引，这样就不需要每次都进行排序了

**什么情况下不可以使用索引？**

- 不经常作为查询条件的字段
- 不经常放到GROUP BY或者ORDER BY后面的字段
- 重复率高的字段，比如性别，建立索引并不会明显提高查询效率，毕竟索引也需要占空间。
- 表数据量很少的时候，全表查也非常快，你创建维护索引反倒需要开销。
- 经常需要更新的字段，如果建立了索引，索引也需要频繁维护（B+树是要保证数据有序的），会影响数据更新的效率。

## 怎么检测索引是否被使用

可以通过show status命令来查看索引的使用情况。

```sql
SHOW STATUS LIKE 'Handler_read%';

```

也可以通过explain命令来查看SQL语句的执行计划。

```sql
EXPLAIN SELECT * FROM table WHERE id = 1;
```

## MySQL联合索引

MySQL的联合索引，也被称为复合索引或多列索引，是一种在多个列上创建的索引。联合索引可以提高查询性能，特别是在你需要从多个列中检索数据时。

联合索引的工作原理是，它会根据索引中的列顺序，首先对第一列进行排序，然后在每个相同的第一列值中，对第二列进行排序，以此类推。因此，你可以在查询中使用任何前缀列（即索引中的第一列，第一列和第二列，等等）来利用联合索引。

## MySql的四个隔离级别以及默认的隔离级别

MySQL的四个隔离级别分别是：读未提交（Read Uncommitted）、读提交（Read Committed）、可重复读（Repeatable Read）、串行化（Serializable）。

- 读未提交（Read Uncommitted）：允许一个事务读取另一个事务未提交的数据。
- 读提交（Read Committed）：允许一个事务读取另一个事务已提交的数据。
- 可重复读（Repeatable Read）：保证在同一个事务中多次读取同样的数据时，数据是一致的。
- 串行化（Serializable）：最高的隔离级别，它通过强制事务串行执行，避免了幻读的问题。

默认的隔离级别是：可重复读（Repeatable Read）。

隔离等级区分
|---| 脏读 | 不可重复读 | 幻读 |
|---|---|---|---|
|读未提交|是|是|是|
|读提交|否|是|是|
|可重复读|否|否|是|
|串行化|否|否|否|

### 脏读

脏读是指一个事务读取到另一个事务未提交的数据，导致数据不一致。

### 不可重复读

不可重复读是指一个事务多次读取同一数据，但是在读取的过程中，另一个事务对数据进行了更新，导致多次读取的数据不一致。

### 幻读

幻读是指一个事务多次读取同一数据，但是在读取的过程中，另一个事务对数据进行了插入或删除，导致多次读取的数据不一致。

## MySQL的事物是基于什么实现的

MySQL的事务是基于InnoDB存储引擎实现的，InnoDB存储引擎是MySQL的默认存储引擎，支持事务、行级锁、外键等特性。

对于事务的实现，InnoDB存储引擎主要通过以下几个方面实现：

- **事务日志：** InnoDB存储引擎通过事务日志（redo log）实现事务的持久性，当事务提交时，将事务的操作记录到事务日志中，保证事务的持久性。
- **MVCC：** InnoDB存储引擎通过多版本并发控制（MVCC）实现事务的隔离性，通过保存数据的多个版本，实现事务的隔离性。
- **锁机制：** InnoDB存储引擎通过行级锁实现事务的隔离性，通过锁机制保证事务的隔禽性。

### 事务日志

InnoDB存储引擎通过事务日志（redo log）实现事务的持久性，当事务提交时，将事务的操作记录到事务日志中，保证事务的持久性。

MySQL的日志主要包括：
- 错误日志：记录MySQL的错误信息。
- 查询日志：记录MySQL的查询信息。
- 慢查询日志：记录MySQL的慢查询信息。
- 事务日志：记录MySQL的事务信息。
- 二进制日志：记录MySQL的数据更改信息。

其中比较重要的是**事务日志**和**二进制日志**，事务日志用于实现事务的持久性，二进制日志用于实现数据的备份和恢复。

**归档日志（binlog）**

MySQL的归档日志（binlog）是MySQL的二进制日志，用于记录MySQL的数据更改信息，主要用于数据的备份和恢复。

而 binlog 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。

他有三种格式
- Statement 格式：记录的是 SQL 语句，如 insert、update、delete 等。
- Row 格式：在Statement的基础上，记录的是行的内容，如记录的now()的具体数值。
- Mixed 格式：根据具体的 SQL 语句来决定使用哪种格式。

**重做日志（redo log）**

MySQL的重做日志（redo log）是InnoDB存储引擎的事务日志，用于实现事务的持久性，主要用于事务的恢复。

redo log 是物理日志，记录的是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎层。

**回滚日志（undo log）**

MySQL的回滚日志（undo log）是InnoDB存储引擎的事务日志，用于实现事务的隔离性，主要用于事务的回滚。

他有三个隐藏的字段，分别是
- trx_id：事务的ID
- roll_ptr：回滚指针，指向回滚段中的某个回滚段
- db_row_id：行的ID
trx_id 和 db_row_id 用于标识一行数据，roll_ptr 用于标识回滚段中的某个回滚段。


### MVCC

InnoDB存储引擎通过多版本并发控制（MVCC）实现事务的隔离性，通过保存数据的多个版本，实现事务的隔离性。

MVCC主要通过以下几个方面实现：
- 保存数据的多个版本：InnoDB存储引擎通过保存数据的多个版本，实现事务的隔离性。
- 通过版本号实现事务的隔离性：InnoDB存储引擎通过版本号实现事务的隔离性，通过版本号判断数据的可见性。
- 通过undo log实现事务的隔离性：InnoDB存储引擎通过undo log实现事务的隔离性，通过undo log记录数据的修改前的版本，实现事务的回滚。
- 通过回滚段实现事务的隔禽性：InnoDB存储引擎通过回滚段实现事务的隔离性，通过回滚段记录数据的修改前的版本，实现事务的回滚。
- 通过锁机制实现事务的隔离性：InnoDB存储引擎通过锁机制实现事务的隔离性，通过锁机制保证事务的隔禽性。

### 锁机制

InnoDB存储引擎通过行级锁实现事务的隔离性，通过锁机制保证事务的隔禽性。


## 如果有a,b,c 组合为联合索引，查询条件是a和b，这个查询会不会用到索引，a和c呢

- 查询条件是a和b，这个查询会使用到联合索引a,b,c。
- 查询条件是a和c，这个查询不会使用到联合索引a,b,c。

联合索引的使用基于**最左前缀原则**，即查询条件必须是联合索引的最左边的列的子列，才能使用到联合索引。同时最左匹配原则会一直向右匹配直到遇到范围查询(>、<) 就会停止匹配。对于 >=、<=、BETWEEN、like 前缀匹配这四种范围查询，并不会停止匹配。
如(a,b),查询条件是a和b，会使用到索引；查询条件是b，不会使用到索引。

## 索引失效的情况有哪些
- 模糊查询的前导通配符： 当使用模糊查询（如 LIKE ‘%abc’）时，索引失效，因为通配符在前面会导致索引无法使用。
- 未使用索引字段进行过滤： 如果查询条件没有使用到创建的索引字段，数据库可能不会使用该索引。
- 数据类型不匹配： 如果查询条件的数据类型与索引字段的数据类型不匹配，数据库无法使用索引。
- 使用函数操作： 如果查询条件中对字段进行了函数操作（如 LOWER(column)），索引可能失效，因为数据库无法直接使用索引。
- OR 运算： 在 OR 运算中，如果其中一个条件使用了索引，而另一个条件没有使用索引，整个查询可能会导致索引失效
- 使用 NOT 运算： NOT 运算通常会使索引失效，因为数据库无法使用索引来高效处理 NOT 运算。
- 表连接中的索引失效： 如果在表连接查询中，连接条件中的字段没有索引，可能导致索引失效。

# 算法

## 排序

### 快排

```c++
void quickSort(std::vector<int>& nums, int left, int right) {
    if (left >= right) {
        return;
    }

    int i = left, j = right;
    int pivot = nums[left];

    while (i < j) {
        while (i < j && nums[j] > pivot) {
            j--;
        }
        if (i < j) {
            nums[i++] = nums[j];
        }

        while (i < j && nums[i] < pivot) {
            i++;
        }
        if (i < j) {
            nums[j--] = nums[i];
        }
    }

    nums[i] = pivot;
    quickSort(nums, left, i - 1);
    quickSort(nums, i + 1, right);
}
```