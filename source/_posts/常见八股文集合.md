---
layout: p
title: 常见八股文集合
date: 2024-03-20 13:07:17
tags: [Java,Mysql,Redis]
---

# Java

## == 和 equals的区别

1. ==针对基本类型时比较的是对象的值，针对引用类型比较的是对象的指向的内存地址是否相等。

2. equals针对的比较对象是引用类型， 在Java中Object对象是所有对象的父类，所以每个类都会有个equals的方法，如果你没有重写它那些它与==的效果是一样的，可以通过源代码查看。


**例子**
```java
String s1 = new String("abc");
String s2 = new String("abc");
System.out.println(s1 == s2); // false
System.out.println(s1.equals(s2)); // true
```

## String StringBuilder StringBuffer的区别

- String：不可变的字符序列，线程安全，适用于字符串不经常改变的场景。
- StringBuilder：可变的字符序列，线程不安全，适用于字符串经常改变的场景。
- StringBuffer：可变的字符序列，线程安全，适用于字符串经常改变的场景。

1、String类型的字符串对象是不可变的，一旦String对象创建后，包含在这个对象中的字符系列是不可以改变的，直到这个对象被销毁。
2、StringBuilder和StringBuffer类型的字符串是可变的，不同的是StringBuffer类型的是线程安全的，而StringBuilder不是线程安全的
3、如果是多线程环境下涉及到共享变量的插入和删除操作，StringBuffer则是首选。如果是非多线程操作并且有大量的字符串拼接，插入，删除操作则StringBuilder是首选。毕竟String类是通过创建临时变量来实现字符串拼接的，耗内存还效率不高，怎么说StringBuilder是通过JNI方式实现终极操作的。
4、StringBuilder和StringBuffer的“可变”特性总结如下：
（1）append，insert，delete方法最根本上都是调用System.arraycopy()这个方法来达到目的
（2）substring(int, int)方法是通过重新new String(value, start, end - start)的方式来达到目的。


## List、Set、Map的区别

- List：有序，可重复，底层是数组（或链表）
- Set：无序，不可重复，底层是哈希表
- Map：无序，key不可重复，value可重复，底层是哈希表

## ArrayList和LinkedList的区别

- ArrayList：底层是数组，查询快，增删慢
- LinkedList：底层是链表，查询慢，增删快

**ArrayList的扩容策略**

ArrayList的扩容策略是每次扩容为原来的1.5倍，当数组长度小于10时，每次扩容为原来的2倍。
最大容量为Integer.MAX_VALUE - 8。

**ArrayList的默认大小**
如果使用无参构造函数ArrayList()创建一个空的ArrayList对象,那么它的初始容量为10。

## 介绍一下Stream流的并行API Parallelstream

ParallelStream通过内部使用Fork/Join框架实现并行处理。当你调用Collection的parallelStream方法时，你会得到一个ParallelStream对象。


## HashMap和HashTable的区别

- HashMap：线程不安全，允许key和value为null
- HashTable：线程安全，不允许key和value为null

## ConcurrentHashMap,HashMap和HashTable的区别

- HashMap：线程不安全，效率高，允许key和value为null
- ConcurrentHashMap：线程安全，效率高，允许key和value为null
- HashTable：线程安全，效率低，不允许key和value为null

## ConcurrentHashMap的实现原理

ConcurrentHashMap是Java中的一个线程安全的哈希表，它的实现原理是分段锁。ConcurrentHashMap中有一个Segment数组，每个Segment都是一个哈希表，每个Segment都是一个独立的锁，这样就可以实现对每个Segment的并发访问，从而提高了并发访问的效率。

## java的反射机制

Java的反射机制是指在运行时动态获取类的信息，比如类的属性、方法、构造器等。Java的反射机制主要是通过Class类来实现的，Class类是Java中的一个类，它是一个类的类，它是一个类的模板，它是一个类的元数据，它是一个类的描述。

## ThreadLocal的使用场景有哪些？原理？内存泄漏？

ThreadLocal，即线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。

ThreadLocal原理

- Thread对象中持有一个ThreadLocal.ThreadLocalMap的成员变量。
- ThreadLocalMap内部维护了Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal本身，value是ThreadLocal的泛型值。
- 每个线程在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。

**内存泄漏**
因为ThreadLocalMap中使用的 key 为 ThreadLocal 的弱引用：

**弱引用：**只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存。

弱引用比较容易被回收。因此，如果ThreadLocal（ThreadLocalMap的Key）被垃圾回收器回收了，但是因为ThreadLocalMap生命周期和Thread是一样的，它这时候如果不被回收，就会出现这种情况：ThreadLocalMap的key没了，value还在，这就会造成了内存泄漏问题。

如何解决内存泄漏问题？使用完ThreadLocal后，**及时调用remove()方法**释放内存空间。

# JVM

## JVM的内存结构

JVM的内存结构大致分为五个部分，分别是程序计数器、虚拟机栈、本地方法栈、堆和方法区。除此之外，还有由堆中引用的JVM外的直接内存。

**JDK1.7以前的内存区域**
![](https://pic.liahnu.top/img/202403281536095.png)

**JDK1.8以后的内存区域**
![](https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png)

1.8之后的内存区域中，永久代被元空间取代，字符串常量池和运行时常量池被合并为一个运行时常量池。

## 堆的内存结构

Java堆是Java虚拟机管理的内存中最大的一块，主要用于存放对象实例。Java堆是垃圾收集器管理的主要区域，因此也被称为GC堆。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。

**对象什么时候进入Survivor区**
当Eden区满时，会触发Minor GC，将Eden区中的存活对象复制到S0或S1中，然后清理掉Eden区中的所有对象。在多次Minor GC之后，存活时间较长的对象会被移动到老年代。

**对象什么情况下一直不会进入老年代**
如果对象在Eden区被创建，那么它在第一次Minor GC后，会被移动到Survivor区，如果在Survivor区被创建，那么它在第二次Minor GC后，会被移动到老年代。

## JVM的垃圾回收器

JVM的垃圾回收器主要分为两大类：串行垃圾回收器和并行垃圾回收器。

**Serial垃圾收集器**
Serial垃圾回收器是串行垃圾回收器，它是单线程的，只会使用一个线程来进行垃圾回收。Serial垃圾回收器适用于单核CPU的环境。

新生代采用标记-复制算法，老年代采用标记-整理算法。

**ParNew垃圾收集器**

ParNew垃圾回收器是Serial垃圾回收器的多线程版本，它是并行垃圾回收器，适用于多核CPU的环境。

**Parallel Scavenge 垃圾收集器**

Parallel Scavenge垃圾回收器是并行垃圾回收器，它适用于多核CPU的环墋，它的特点是吞吐量优先，适用于后台运行的应用。

**Serial Old垃圾收集器**

Serial Old垃圾回收器是Serial垃圾回收器的老年代版本，它是单线程的，适用于单核CPU的环境。

**Parallel Old垃圾收集器**

Parallel Old垃圾回收器是Parallel Scavenge垃圾回收器的老年代版本，它是并行垃圾回收器，适用于多核CPU的环境。

**CMS垃圾收集器**

CMS垃圾回收器是并发垃圾回收器，它是一种以获取最短回收停顿时间为目标的收集器，适用于对响应时间有要求的应用。

**G1垃圾收集器**

G1垃圾回收器是一种面向服务端应用的垃圾回收器，它是一种并发的、基于标记-整理算法的垃圾回收器，适用于多核CPU的环境。

**ZGC垃圾收集器**

ZGC垃圾回收器是一种低延迟的垃圾回收器，它是一种并发的、基于标记-整理算法的垃圾回收器，适用于对响应时间有要求的应用。

## JVM的垃圾回收算法


# JUC

## Runable和Callable有什么区别

1. Runnable是Java中的一个接口，它只有一个run方法，没有返回值，不能抛出异常。
2. Callable是Java中的一个接口，它有一个call方法，有返回值，可以抛出异常。

## 启动一个线程是用start()还是run()方法

启动一个线程是用start()方法，而不是run()方法。如果你调用run()方法，那么这个方法就会在当前线程中执行，而不会启动一个新的线程。

## 线程池原理？各个参数的作用

```java
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime,TimeUnit unit,
   BlockingQueue<Runnable> workQueue,
   ThreadFactory threadFactory,
   RejectedExecutionHandler handler) 
```

**几个核心参数的作用：**

- corePoolSize：线程池核心线程数最大值
- maximumPoolSize：线程池最大线程数大小
- keepAliveTime：线程池中非核心线程空闲的存活时间大小
- unit：线程空闲存活时间单位
- workQueue：存放任务的阻塞队列
- threadFactory：用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。
- handler： 线城池的饱和策略事件，主要有四种类型。

**四种饱和拒绝策略**

- AbortPolicy(抛出一个异常，默认的)
- DiscardPolicy(直接丢弃任务)
- DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）
- CallerRunsPolicy（交给线程池调用所在的线程进行处理)

**工作队列的类型**
- ArrayBlockingQueue：基于数组的有界阻塞队列
- LinkedBlockingQueue：基于链表的有界阻塞队列
- SynchronousQueue：不存储元素的阻塞队列
- PriorityBlockingQueue：具有优先级的无界阻塞队列

**几种线程池**

- newFixedThreadPool：固定大小的线程池
- newSingleThreadExecutor：单个线程的线程池
- newCachedThreadPool：可缓存的线程池
- newScheduledThreadPool：定时任务的线程池

## Cpu密集型和IO密集型  N+1  2N  具体是如何计算的

- CPU密集型：CPU密集型是指CPU的使用率非常高，而I/O操作非常少的程序。CPU密集型程序的特点是CPU使用率很高，而内存和硬盘I/O操作的使用率很低。
- IO密集型：IO密集型是指I/O操作非常频繁的程序。IO密集型程序的特点是CPU使用率很低，而内存和硬盘I/O操作的使用率很高。

其中n+1和2n是上文中线程池设置线程的数量；

主要是因为，如果线程数量太多的话，线程的竞争大，会导致大量上下文切换，因为CPU是分配给时间片给线程来处理任务的，时间片一到，那么线程就得保存当前任务，等待下一次CPU分配时间片，那么下一次线程获取到CPU时间片之后，会重新加载任务来处理，保存到加载的过程就称之为上问下切换。

**CPU n+1**
如果程序的计算量特别高，那么就属于CPU密集型，线程数量可以设置为N（CPU的核心数）+1。

**I/O密集型（2N）**
如果程序的是网络传输或者I/O操作比较多，那么线程池应该设置为2N。

## 乐观锁悲观锁

- 乐观锁：乐观锁是一种乐观的思想，它认为并发访问的情况是比较少的，所以在读取数据的时候不加锁，只在更新数据的时候加锁，这样可以提高并发访问的效率。
- 悲观锁：悲观锁是一种悲观的思想，它认为并发访问的情况是比较多的，所以在读取数据的时候加锁，这样可以保证并发访问的安全性。

### 乐观锁的实现
乐观锁的实现主要是通过CAS操作和版本号来实现的，CAS操作是一种乐观锁的实现方式，它的实现是基于CPU的原子操作指令。
CAS操作包括了3个操作数：

- 需要读写的内存位置(V)
- 进行比较的预期值(A)
- 拟写入的新值(B)

当一个线程获取锁的时候，会尝试使用CAS操作来获取锁，如果CAS操作失败，那么就会尝试重新获取锁，直到获取锁成功。

版本号机制是在每次修改数据的时候，都会修改版本号，这样在使用CAS进行检查的时候，就可以检查版本号是否发生变化。

**乐观锁的优缺点**
与悲观锁相比，乐观锁适用的场景受到了更多的限制，无论是CAS还是版本号机制。

例如，CAS只能保证单个变量操作的原子性，当涉及到多个变量时，CAS是无能为力的，而synchronized则可以通过对整个代码块加锁来处理。再比如版本号机制，如果query的时候是针对表1，而update的时候是针对表2，也很难通过简单的版本号来实现乐观锁。

当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。
当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源。

### 悲观锁的实现

悲观锁的实现主要是通过synchronized关键字来实现的，synchronized是Java中最基本的同步手段，它保证了线程的安全性，但是它的性能开销也是比较大的。

# Spring框架

## Spring的IOC和AOP

- IOC：控制反转，是一种设计思想，它的核心思想是将对象的创建和对象之间的依赖关系的管理交给Spring容器来管理，而不是由程序员来管理。
- AOP：面向切面编程，是一种设计思想，它的核心思想是将程序的业务逻辑和系统服务分离，通过对系统服务的封装，将系统服务的功能切面化，然后通过切面的方式将系统服务的功能插入到业务逻辑中。

## @Resource和@Autowired的区别是什么？

- @Resource：是JavaEE提供的注解，它是按照名称进行装配的，如果没有指定name属性，那么它会按照类型进行装配。
- @Autowired：是Spring提供的注解，它是按照类型进行装配的，如果有多个类型相同的bean，那么它会按照名称进行装配。

# 计算机网络

## tcp三次握手，四次挥手

TCP是面向连接的，可靠的，基于字节流的传输层协议。TCP连接的建立和断开都需要经过三次握手和四次挥手。

**TPC的三次握手（建立连接）** 
1. SYN：客户端发送一个SYN（同步）包到服务器，以请求建立连接。这个包包含一个随机的序列号A。
2. SYN-ACK：服务器收到SYN包后，会发送一个SYN-ACK（同步-确认）包到客户端。这个包包含一个自己的随机序列号B，和对客户端序列号A的确认（即A+1）。
3. ACK：客户端收到SYN-ACK包后，会发送一个ACK（确认）包到服务器。这个包包含对服务器序列号B的确认（即B+1）。

**TCP的四次挥手（断开连接）**
1. FIN：当数据传输完毕，客户端会发送一个FIN（结束）包到服务器，请求断开连接。
2. ACK：服务器收到FIN包后，会发送一个ACK（确认）包到客户端，确认收到了FIN包。但是，服务器可能还有数据需要传输到客户端，所以不会立即关闭连接。
3. FIN：当服务器数据都传输完毕，会发送一个FIN（结束）包到客户端，请求断开连接。
4. ACK：客户端收到FIN包后，会发送一个ACK（确认）包到服务器，确认收到了FIN包。然后，客户端会等待一段时间（两个最大段生存时间），确保服务器收到了ACK包，然后关闭连接。

## tcp和udp的区别

**连接性：**TCP是一种面向连接的协议，这意味着在数据传输之前，必须先建立连接。而UDP是无连接的，它只是发送数据，而不关心数据是否到达。

**可靠性：**TCP提供了数据传输的可靠性。它通过确认（ACK）、重传、错误检测等机制确保数据正确无误地从发送端传输到接收端。而UDP不提供这种可靠性，它只是简单地发送数据，不进行错误检测和修复。

**顺序：**TCP保证数据的顺序，即数据会按照发送的顺序到达接收端。而UDP不保证数据的顺序，数据报可能会乱序到达。

**速度：**由于TCP的可靠性和顺序保证机制，它的速度通常比UDP慢。而UDP由于其简单的协议结构，通常比TCP快。

**用途：**TCP通常用于需要高可靠性的应用，如Web服务器、邮件服务器等。而UDP通常用于对实时性要求高的应用，如视频流、VoIP等，这些应用可以容忍一些数据丢失，但需要快速传输。

**头部大小：**TCP的头部最小为20字节，而UDP的头部固定为8字节，因此UDP的开销更小。

**流控制和拥塞控制：**TCP有流控制和拥塞控制机制，可以防止发送端发送速度过快导致接收端或网络无法处理。而UDP没有这些控制机制。

# Redis

## Redis的数据结构

Redis支持五种数据结构：String、List、Set、Hash、ZSet。
此外，还有三种特殊的数据结构：HyperLogLog、Geo、Stream。

## 讲一下缓存三兄弟（缓存穿透、缓存击穿、缓存雪崩）

- 缓存穿透：指的是查询一个不存在的数据，由于缓存中没有，所以每次都会去数据库中查询，这样会导致数据库压力过大。
- 缓存击穿：指的是一个热点数据突然失效，导致大量请求直接打到数据库上，这样会导致数据库压力过大。
- 缓存雪崩：指的是缓存中的大量数据同时失效，导致大量请求直接打到数据库上，这样会导致数据库压力过大。

**缓存穿透的解决方法**
1. 布隆过滤器：将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉。
2. 空对象缓存：如果一个查询返回的数据为空（不管是数据不存在还是数据被删除），我们也可以将这个空结果进行缓存，但是需要设置一个较短的过期时间。

**缓存击穿的解决方法**
1. 设置热点数据永不过期。
2. 加互斥锁：在缓存失效的时候，加互斥锁，只允许一个线程去查询数据库，其他线程等待。

**缓存雪崩的解决方法**
1. 加互斥锁：在缓存失效的时候，加互斥锁，只允许一个线程去查询数据库，其他线程等待。
2. 设置不同的过期时间：不同的数据设置不同的过期时间，避免大量数据同时失效。

## Redis的持久化机制（RDB和AOF）

Redis的持久化机制有两种：RDB快照和AOF日志。

- RDB快照：是指在指定的时间间隔内将内存中的数据保存到磁盘上，生成一个快照文件。RDB快照是一个二进制文件，它保存了某个时间点上的所有数据。
- AOF日志：是指在每次写操作时，将写操作的命令追加到AOF文件的末尾。AOF日志是一个文本文件，它保存了所有的写操作命令。

## Redis宕机哪种恢复的快

RDB快照恢复的速度比AOF日志快，因为RDB快照是一个二进制文件，它保存了某个时间点上的所有数据，所以恢复速度比较快。

# MySQL

## MVCC是什么

MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。

MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。


## mysql的锁

MySQL的锁主要有两种：共享锁和排他锁。
- 共享锁：是一种读锁，它允许多个事务同时对同一行数据进行读操作，但是不允许对同一行数据进行写操作。
- 排他锁：是一种写锁，它不允许其他事务对同一行数据进行读操作和写操作。

## 索引有哪些种类

MySQL的索引按照数据结构维度可分为：

- B+树索引：是一种多路搜索树，是一种平衡的多路搜索树，能够保持数据稳定有序，其插入和查询的时间复杂度都是O(logN)。
- 哈希索引：是一种哈希表，能够快速定位到数据，其插入和查询的时间复杂度都是O(1)。
- 全文索引：是一种全文搜索索引，能够对文本进行全文搜索。
- R-Tree索引：是一种空间索引，能够对空间数据进行搜索。

按照底层数据结构维度可分为：
- 聚类索引：是一种按照数据存储的物理顺序进行排序的索引。
- 非聚集索引：是一种按照数据存储的逻辑顺序进行排序的索引。

按照索引的应用维度可分为：
- 主键索引：是一种唯一索引，能够保证数据的唯一性。
- 普通索引：是一种普通的索引，能够提高查询速度。
- 唯一索引：是一种唯一索引，能够保证数据的唯一性。
- 覆盖索引：是一种覆盖查询索引，能够减少查询的IO操作。
- 联合索引：是一种联合索引，能够提高查询速度。
- 全文索引：是一种全文搜索索引，能够对文本进行全文搜索。

## Mysql索引优缺点

**优点**
1. 提高查询速度：索引可以大大提高查询速度。
2. 加速表和表之间的连接：通过索引可以加速表和表之间的连接。
3. 唯一性约束：可以保证表中每一行数据的唯一性。

**缺点**
1. 索引会占用磁盘空间：索引会占用磁盘空间。
2. 索引会降低写操作的速度：因为每次写操作都需要更新索引。
3. 索引会降低查询速度：因为每次查询都需要查找索引。

**什么时候能用索引**

- 经常作为查询条件的字段，如果需要同时查找多个字段，可以建立联合索引
- 经常放到GROUP BY或者ORDER BY后面的字段，进行GROUP BY或者ORDER BY都会对数据进行排序，这些字段就可以建立一个索引，这样就不需要每次都进行排序了

**什么情况下不可以使用索引？**

- 不经常作为查询条件的字段
- 不经常放到GROUP BY或者ORDER BY后面的字段
- 重复率高的字段，比如性别，建立索引并不会明显提高查询效率，毕竟索引也需要占空间。
- 表数据量很少的时候，全表查也非常快，你创建维护索引反倒需要开销。
- 经常需要更新的字段，如果建立了索引，索引也需要频繁维护（B+树是要保证数据有序的），会影响数据更新的效率。

## MySQL联合索引

MySQL的联合索引，也被称为复合索引或多列索引，是一种在多个列上创建的索引。联合索引可以提高查询性能，特别是在你需要从多个列中检索数据时。

联合索引的工作原理是，它会根据索引中的列顺序，首先对第一列进行排序，然后在每个相同的第一列值中，对第二列进行排序，以此类推。因此，你可以在查询中使用任何前缀列（即索引中的第一列，第一列和第二列，等等）来利用联合索引。

## MySql的四个隔离级别以及默认的隔离级别

MySQL的四个隔离级别分别是：读未提交（Read Uncommitted）、读提交（Read Committed）、可重复读（Repeatable Read）、串行化（Serializable）。

- 读未提交（Read Uncommitted）：允许一个事务读取另一个事务未提交的数据。
- 读提交（Read Committed）：允许一个事务读取另一个事务已提交的数据。
- 可重复读（Repeatable Read）：保证在同一个事务中多次读取同样的数据时，数据是一致的。
- 串行化（Serializable）：最高的隔离级别，它通过强制事务串行执行，避免了幻读的问题。

默认的隔离级别是：可重复读（Repeatable Read）。

# 算法

## 排序

### 快排

```c++
void quickSort(std::vector<int>& nums, int left, int right) {
    if (left >= right) {
        return;
    }

    int i = left, j = right;
    int pivot = nums[left];

    while (i < j) {
        while (i < j && nums[j] > pivot) {
            j--;
        }
        if (i < j) {
            nums[i++] = nums[j];
        }

        while (i < j && nums[i] < pivot) {
            i++;
        }
        if (i < j) {
            nums[j--] = nums[i];
        }
    }

    nums[i] = pivot;
    quickSort(nums, left, i - 1);
    quickSort(nums, i + 1, right);
}
```