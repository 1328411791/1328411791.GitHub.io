---
layout: p
title: 设计模式
date: 2023-05-08 19:37:01
tags: [设计模式]
---

# 设计模式
设计模式的目的是帮助我们编写可复用的代码，提高代码的耦合性。降低对其他组件的修改

![](https://www.runoob.com/wp-content/uploads/2014/08/the-relationship-between-design-patterns.jpg)

# 单例模式

单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供了一个全局访问点来访问该实例。

注意
1. 单例类只能有一个实例。
2. 单例类必须自己创建自己的唯一实例。
3. 单例类必须给所有其他对象提供这一实例。

**主要解决：** 一个全局使用的类频繁地创建与销毁。
**何时使用：** 当您想控制实例数目，节省系统资源的时候。
**如何解决：** 判断系统是否已经有这个单例，如果有则返回，如果没有则创建。
**关键代码：** 构造函数是私有的。

![](https://www.runoob.com/wp-content/uploads/2014/08/62576915-36E0-4B67-B078-704699CA980A.jpg)

## 例题

https://kamacoder.com/problempage.php?pid=1074

## 实现
```java
class ShoppingCarft{
    private  String name;
    private  int number;

    public ShoppingCarft(String str){
        this.name = str.split(" ")[0];
        this.number = Integer.parseInt(str.split(" ")[1]);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getNumber() {
        return number;
    }

    public void setNumber(int number) {
        this.number = number;
    }
}

// 饿汉式加载
class  SingleObject{

    private List<ShoppingCarft> list = new ArrayList<>();
    private static final SingleObject instance = new SingleObject();
    private SingleObject(){}
    public static SingleObject getInstance(){
        return instance;
    }

    public void add(ShoppingCarft shop){
        list.add(shop);
    }

    public void show(){
        for (ShoppingCarft shoppingCarft : list) {
            System.out.printf("%s %d\n",shoppingCarft.getName(),shoppingCarft.getNumber());
        }
    }
}
public class SingleModel {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        SingleObject singleObject = SingleObject.getInstance();
        while (scanner.hasNext()){
            String string = scanner.nextLine();
            ShoppingCarft shop = new ShoppingCarft(string);
            singleObject.add(shop);
        }
        singleObject.show();
    }
}
```
# 工厂模式
**意图：** 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
**主要解决：** 主要解决接口选择的问题。

**何时使用：** 我们明确地计划不同条件下创建不同实例时。

**如何解决：** 让其子类实现工厂接口，返回的也是一个抽象的产品。

**关键代码：** 创建过程在其子类执行。

**应用实例：**
1. 您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 
2. Hibernate 换数据库只需换方言和驱动就可以。

**优点** 
1. 一个调用者想创建一个对象，只要知道其名称就可以了
2. 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 
3. 屏蔽产品的具体实现，调用者只关心产品的接口。

**缺点**
每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

**使用场景** 
1. 日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 
2. 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。
3.  设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。
   
**注意事项：** 作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。

![](https://www.runoob.com/wp-content/uploads/2014/08/AB6B814A-0B09-4863-93D6-1E22D6B07FF8.jpg)

## 例题
https://kamacoder.com/problempage.php?pid=1076
## 实现
```java
import java.util.Scanner;

interface Block{
    void build();
}

class SquareBlock implements Block{
    @Override
    public void build() {
        System.out.println("Square Block");
    }
}

class CircleBlock implements Block{
    @Override
    public void build() {
        System.out.println("Circle Block");
    }
}

class BlockFactory{
    public static Block getBlock(String string){
        Block block = null;
        switch (string){
            case "Square":
                block = new SquareBlock();
                break;
            case "Circle":
                block = new CircleBlock();
                break;
        }
        return block;
    }
}

public class SimpleFactorModel {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        for (int i=0;i<n;i++){
            String string = scanner.next();
            int number = scanner.nextInt();
            for(int j=0;j<number;j++) {
                Block block = BlockFactory.getBlock(string);
                block.build();
            }
        }
    }
}

```
# 抽象工厂模式
意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

主要解决：主要解决接口选择的问题。

何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。

如何解决：在一个产品族里面，定义多个产品。

关键代码：在一个工厂里聚合多个同类产品。

应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。

优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。

使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。

注意事项：产品族难扩展，产品等级易扩展。

抽象工厂模式包含以下几个核心角色：

抽象工厂（Abstract Factory）：声明了一组用于创建产品对象的方法，每个方法对应一种产品类型。抽象工厂可以是接口或抽象类。
具体工厂（Concrete Factory）：实现了抽象工厂接口，负责创建具体产品对象的实例。
抽象产品（Abstract Product）：定义了一组产品对象的共同接口或抽象类，描述了产品对象的公共方法。
具体产品（Concrete Product）：实现了抽象产品接口，定义了具体产品的特定行为和属性。
抽象工厂模式通常涉及一族相关的产品，每个具体工厂类负责创建该族中的具体产品。客户端通过使用抽象工厂接口来创建产品对象，而不需要直接使用具体产品的实现类。

## 例题

## 示例
```java
import java.util.Scanner;

// 家具
interface Chair{
    void build();
}

interface Sofa{
    void build();
}
class ModernChair implements Chair{
    @Override
    public void build() {
        System.out.println("modern chair");
    }
}

class ClassicalChair implements Chair{
    @Override
    public void build() {
        System.out.println("classical chair");
    }
}

class ModernSofa implements Sofa{
    @Override
    public void build() {
        System.out.println("modern sofa");
    }
}

class ClassicalSofa implements Sofa{
    @Override
    public void build() {
        System.out.println("classical sofa");
    }
}

interface FurnitureFactory{
    Chair createChair();
    Sofa createSofa();
}
class ModernFactory implements FurnitureFactory{
    @Override
    public Chair createChair() {
        return new ModernChair();
    }

    @Override
    public Sofa createSofa() {
        return new ModernSofa();
    }
}

class ClassicalFactory implements FurnitureFactory{
    @Override
    public Chair createChair() {
        return new ClassicalChair();
    }

    @Override
    public Sofa createSofa() {
        return new ClassicalSofa();
    }
}

class AbstractFactory{
    public static FurnitureFactory getFactory(String string){
        FurnitureFactory factory = null;
        switch (string){
            case "modern":
                factory = new ModernFactory();
                break;
            case "classical":
                factory = new ClassicalFactory();
                break;
        }
        return factory;
    }
}

public class AbstractFactorModel {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        for (int i=0;i<n;i++){
            String string = scanner.next();
            FurnitureFactory factory = AbstractFactory.getFactory(string);
            Chair chair = factory.createChair();
            Sofa sofa = factory.createSofa();
            chair.build();
            sofa.build();
        }
    }
}
```

# 迭代器模式

通过构造一个迭代器来实现对元素的遍历操作

## 实现
在java中可以使用util中提供的`Iterator<?>`接口实现，主要为 hasnext与next方法，分别判断迭代器是否有下一个和获取下一个元素。

其实java中 拓展for使用使用了迭代器模式，c++中同样存在迭代器for遍历。

## 优点
1. 引入迭代器后，可以使遍历与实现分离开，不暴露该对象的内部表示。

# Adapter模式 （适配器模式）

Adapter模式又称为Wrapper模式，其设计模式的目的是实现两个对象间的互相转换，主要有以下两种

1. 类适配器模式
2. 对象适配器模式

## 类适配器模式
类适配器模式是实现类与接口间实现对接的方式。通过中间类 Banner 类继承对象和实现接口的相关功能实现

![](https://pic.liahnu.top/img/202305082019449.png)

## 对象适配器模式
对象适配器模式是实现对类与类间实现对接的方式。由于java中只能单继承，通过中间类 Banner 类继承一个类和保存对象，实现对数据处理的转交。

![](https://pic.liahnu.top/img/202305082020330.png)

# Template Method 模式 （模板方式模式）