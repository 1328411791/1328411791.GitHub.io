---
layout: p
title: 联想一面面试复盘
date: 2024-04-12 14:51:33
tags: [Java]
---

# 联想一面面经

- 英语自我介绍
- 项目介绍
- 项目用了Nacos，他的配置中心能不能动态更新，怎么动态更新
- Dubbo的默认服务调用方式是什么
- MySQL的索引有哪些
- MySQL的事物是基于什么实现的
- 索引失效的情况有哪些
- 如果有a,b,c三个联合索引，查询条件是a和b，这个查询会不会用到索引，a和c呢
- SpringBoot的LOC了解吗
- 提到了SPI，SpringBoot配置创建是怎么实现的
- Spring怎么切换Bean的创建方式
- Etcd中间件和Zookeeper有什么优缺点
- 能不能通过RabbitMQ去拿取指定的数据
- 反问

## 项目用了Nacos，他的配置中心能不能动态更新，怎么动态更新

Nacos的配置中心是支持动态更新的，当配置中心的配置发生变化时，Nacos会主动推送配置变更到客户端，客户端会实时更新配置。

**如何使用**

- 通过RefreshScope接口实现
- 通过ConfigListener接口实现
- 通过@NacosPropertySource注解实现

## Dubbo的默认服务调用方式是什么

（这个问题指的是同步还是异步调用）
Dubbo的默认服务调用方式是同步调用，即服务提供者和消费者之间是一对一的关系，消费者调用服务提供者的服务时，会阻塞等待服务提供者的响应。

（怎么理解成成多个服务提供者的均衡负载之类的问题了）

## MySQL的索引有哪些

MySQL的索引按照**物理存储**维度划分主要有以下几种：
- B+树索引：最常见的索引类型，适用于等值查询、范围查询、排序查询。
- 哈希索引：适用于等值查询，不适用于范围查询和排序查询。
- 全文索引：对文本的内容进行分词，进行搜索。目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。


MySQL的索引按照**应用**维度划分主要有以下几种：
- 主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。
- 普通索引：仅加速查询。唯一索引：加速查询 + 列值唯一（可以有 NULL）。
- 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。
- 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。
- 全文索引：对文本的内容进行分词，进行搜索。目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。

## MySQL的事物是基于什么实现的

MySQL的事务是基于InnoDB存储引擎实现的，InnoDB存储引擎是MySQL的默认存储引擎，支持事务、行级锁、外键等特性。

对于事务的实现，InnoDB存储引擎主要通过以下几个方面实现：

- **事务日志：** InnoDB存储引擎通过事务日志（redo log）实现事务的持久性，当事务提交时，将事务的操作记录到事务日志中，保证事务的持久性。
- **MVCC：** InnoDB存储引擎通过多版本并发控制（MVCC）实现事务的隔离性，通过保存数据的多个版本，实现事务的隔离性。
- **锁机制：** InnoDB存储引擎通过行级锁实现事务的隔离性，通过锁机制保证事务的隔禽性。

### 事务日志

InnoDB存储引擎通过事务日志（redo log）实现事务的持久性，当事务提交时，将事务的操作记录到事务日志中，保证事务的持久性。

MySQL的日志主要包括：
- 错误日志：记录MySQL的错误信息。
- 查询日志：记录MySQL的查询信息。
- 慢查询日志：记录MySQL的慢查询信息。
- 事务日志：记录MySQL的事务信息。
- 二进制日志：记录MySQL的数据更改信息。

其中比较重要的是**事务日志**和**二进制日志**，事务日志用于实现事务的持久性，二进制日志用于实现数据的备份和恢复。

**归档日志（binlog）**

MySQL的归档日志（binlog）是MySQL的二进制日志，用于记录MySQL的数据更改信息，主要用于数据的备份和恢复。

而 binlog 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。

他有三种格式
- Statement 格式：记录的是 SQL 语句，如 insert、update、delete 等。
- Row 格式：在Statement的基础上，记录的是行的内容，如记录的now()的具体数值。
- Mixed 格式：根据具体的 SQL 语句来决定使用哪种格式。

**重做日志（redo log）**

MySQL的重做日志（redo log）是InnoDB存储引擎的事务日志，用于实现事务的持久性，主要用于事务的恢复。

redo log 是物理日志，记录的是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎层。

**回滚日志（undo log）**

MySQL的回滚日志（undo log）是InnoDB存储引擎的事务日志，用于实现事务的隔离性，主要用于事务的回滚。


### MVCC

InnoDB存储引擎通过多版本并发控制（MVCC）实现事务的隔离性，通过保存数据的多个版本，实现事务的隔离性。


### 锁机制

InnoDB存储引擎通过行级锁实现事务的隔离性，通过锁机制保证事务的隔禽性。


## 如果有a,b,c 组合为联合索引，查询条件是a和b，这个查询会不会用到索引，a和c呢

- 查询条件是a和b，这个查询会使用到联合索引a,b,c。
- 查询条件是a和c，这个查询不会使用到联合索引a,b,c。

联合索引的使用基于**最左前缀原则**，即查询条件必须是联合索引的最左边的列的子列，才能使用到联合索引。同时最左匹配原则会一直向右匹配直到遇到范围查询(>、<) 就会停止匹配。对于 >=、<=、BETWEEN、like 前缀匹配这四种范围查询，并不会停止匹配。
如(a,b),查询条件是a和b，会使用到索引；查询条件是b，不会使用到索引。

## 索引失效的情况有哪些
- 模糊查询的前导通配符： 当使用模糊查询（如 LIKE ‘%abc’）时，索引失效，因为通配符在前面会导致索引无法使用。
- 未使用索引字段进行过滤： 如果查询条件没有使用到创建的索引字段，数据库可能不会使用该索引。
- 数据类型不匹配： 如果查询条件的数据类型与索引字段的数据类型不匹配，数据库无法使用索引。
- 使用函数操作： 如果查询条件中对字段进行了函数操作（如 LOWER(column)），索引可能失效，因为数据库无法直接使用索引。
- OR 运算： 在 OR 运算中，如果其中一个条件使用了索引，而另一个条件没有使用索引，整个查询可能会导致索引失效
- 使用 NOT 运算： NOT 运算通常会使索引失效，因为数据库无法使用索引来高效处理 NOT 运算。
- 表连接中的索引失效： 如果在表连接查询中，连接条件中的字段没有索引，可能导致索引失效。

# 提到了SPI，SpringBoot配置创建是怎么实现的

SPI（Service Provider Interface）是Java提供的一种服务发现机制，主要用于在模块化开发中，为模块提供扩展点。

SpringBoot的配置创建是通过SPI机制实现的，SpringBoot提供了`spring.factories`文件，用于配置SpringBoot的自动配置类，SpringBoot在启动时会扫描`spring.factories`文件，加载配置类，实现自动配置。


## Spring怎么切换Bean的创建方式

Spring切换Bean的创建方式主要有两种：
- XML配置文件
- 注解

**XML配置文件**

```xml
<bean id="user" class="com.example.User" scope="prototype" />
```

**使用Scope注解**

```java
@Component
@Scope("prototype")
public class User {
    // ...
}
```

## Etcd做服务发现中间件和Zookeeper比有什么优缺点

Zookeeper是一个分布式协调服务，处理复杂且容易出错的分布式一致性服务，而Etcd是一个高可用的键值存储系统，主要用于共享配置和服务发现。

- **Zookeeper：** 适合做注册中心，因为Zookeeper是一个分布式协调服务，处理复杂且容易出错的分布式一致性服务。Zookeeper的数据是存储在磁盘上的，所以可以存储大量的数据，适合做大型的注册中心。
- **Etcd：** 适合做注册中心，因为Etcd是一个高可用的键值存储系统，主要用于共享配置和服务发现。相较于Zookeeper，Etcd的设计更加简单，性能更好，实现的功能需求更好。




## 能不能通过RabbitMQ去拿取指定的数据，例如拿取时间为2024-04-12的数据

（我感觉应该是想考察广度，RabbitMQ和Kafka）

RabbitMQ是消息队列中间件，主要用于消息的生产和消费，不支持直接查询数据。

如果需要通过RabbitMQ拿取指定的数据的许久，可以通过消息的生产者将数据发送到RabbitMQ，然后消费者消费数据，根据数据的时间进行Topic过滤。但这种只能处理已知的问题。

第二种是更换为Kafka，Kafka支持消息的持久化，可以根据时间戳查询数据。




